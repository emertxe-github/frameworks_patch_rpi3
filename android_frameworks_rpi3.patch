diff -Naur frameworksRaw/base/opengl/java/android/opengl/GLSurfaceView.java.orig frameworksModified/base/opengl/java/android/opengl/GLSurfaceView.java.orig
--- frameworksRaw/base/opengl/java/android/opengl/GLSurfaceView.java.orig	2017-07-06 15:34:15.978007237 +0530
+++ frameworksModified/base/opengl/java/android/opengl/GLSurfaceView.java.orig	1970-01-01 05:30:00.000000000 +0530
@@ -1,1912 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.opengl;
-
-import android.content.Context;
-import android.os.Trace;
-import android.util.AttributeSet;
-import android.util.Log;
-import android.view.SurfaceHolder;
-import android.view.SurfaceView;
-
-import java.io.Writer;
-import java.lang.ref.WeakReference;
-import java.util.ArrayList;
-
-import javax.microedition.khronos.egl.EGL10;
-import javax.microedition.khronos.egl.EGL11;
-import javax.microedition.khronos.egl.EGLConfig;
-import javax.microedition.khronos.egl.EGLContext;
-import javax.microedition.khronos.egl.EGLDisplay;
-import javax.microedition.khronos.egl.EGLSurface;
-import javax.microedition.khronos.opengles.GL;
-import javax.microedition.khronos.opengles.GL10;
-
-/**
- * An implementation of SurfaceView that uses the dedicated surface for
- * displaying OpenGL rendering.
- * <p>
- * A GLSurfaceView provides the following features:
- * <p>
- * <ul>
- * <li>Manages a surface, which is a special piece of memory that can be
- * composited into the Android view system.
- * <li>Manages an EGL display, which enables OpenGL to render into a surface.
- * <li>Accepts a user-provided Renderer object that does the actual rendering.
- * <li>Renders on a dedicated thread to decouple rendering performance from the
- * UI thread.
- * <li>Supports both on-demand and continuous rendering.
- * <li>Optionally wraps, traces, and/or error-checks the renderer's OpenGL calls.
- * </ul>
- *
- * <div class="special reference">
- * <h3>Developer Guides</h3>
- * <p>For more information about how to use OpenGL, read the
- * <a href="{@docRoot}guide/topics/graphics/opengl.html">OpenGL</a> developer guide.</p>
- * </div>
- *
- * <h3>Using GLSurfaceView</h3>
- * <p>
- * Typically you use GLSurfaceView by subclassing it and overriding one or more of the
- * View system input event methods. If your application does not need to override event
- * methods then GLSurfaceView can be used as-is. For the most part
- * GLSurfaceView behavior is customized by calling "set" methods rather than by subclassing.
- * For example, unlike a regular View, drawing is delegated to a separate Renderer object which
- * is registered with the GLSurfaceView
- * using the {@link #setRenderer(Renderer)} call.
- * <p>
- * <h3>Initializing GLSurfaceView</h3>
- * All you have to do to initialize a GLSurfaceView is call {@link #setRenderer(Renderer)}.
- * However, if desired, you can modify the default behavior of GLSurfaceView by calling one or
- * more of these methods before calling setRenderer:
- * <ul>
- * <li>{@link #setDebugFlags(int)}
- * <li>{@link #setEGLConfigChooser(boolean)}
- * <li>{@link #setEGLConfigChooser(EGLConfigChooser)}
- * <li>{@link #setEGLConfigChooser(int, int, int, int, int, int)}
- * <li>{@link #setGLWrapper(GLWrapper)}
- * </ul>
- * <p>
- * <h4>Specifying the android.view.Surface</h4>
- * By default GLSurfaceView will create a PixelFormat.RGB_888 format surface. If a translucent
- * surface is required, call getHolder().setFormat(PixelFormat.TRANSLUCENT).
- * The exact format of a TRANSLUCENT surface is device dependent, but it will be
- * a 32-bit-per-pixel surface with 8 bits per component.
- * <p>
- * <h4>Choosing an EGL Configuration</h4>
- * A given Android device may support multiple EGLConfig rendering configurations.
- * The available configurations may differ in how may channels of data are present, as
- * well as how many bits are allocated to each channel. Therefore, the first thing
- * GLSurfaceView has to do when starting to render is choose what EGLConfig to use.
- * <p>
- * By default GLSurfaceView chooses a EGLConfig that has an RGB_888 pixel format,
- * with at least a 16-bit depth buffer and no stencil.
- * <p>
- * If you would prefer a different EGLConfig
- * you can override the default behavior by calling one of the
- * setEGLConfigChooser methods.
- * <p>
- * <h4>Debug Behavior</h4>
- * You can optionally modify the behavior of GLSurfaceView by calling
- * one or more of the debugging methods {@link #setDebugFlags(int)},
- * and {@link #setGLWrapper}. These methods may be called before and/or after setRenderer, but
- * typically they are called before setRenderer so that they take effect immediately.
- * <p>
- * <h4>Setting a Renderer</h4>
- * Finally, you must call {@link #setRenderer} to register a {@link Renderer}.
- * The renderer is
- * responsible for doing the actual OpenGL rendering.
- * <p>
- * <h3>Rendering Mode</h3>
- * Once the renderer is set, you can control whether the renderer draws
- * continuously or on-demand by calling
- * {@link #setRenderMode}. The default is continuous rendering.
- * <p>
- * <h3>Activity Life-cycle</h3>
- * A GLSurfaceView must be notified when to pause and resume rendering. GLSurfaceView clients
- * are required to call {@link #onPause()} when the activity stops and
- * {@link #onResume()} when the activity starts. These calls allow GLSurfaceView to
- * pause and resume the rendering thread, and also allow GLSurfaceView to release and recreate
- * the OpenGL display.
- * <p>
- * <h3>Handling events</h3>
- * <p>
- * To handle an event you will typically subclass GLSurfaceView and override the
- * appropriate method, just as you would with any other View. However, when handling
- * the event, you may need to communicate with the Renderer object
- * that's running in the rendering thread. You can do this using any
- * standard Java cross-thread communication mechanism. In addition,
- * one relatively easy way to communicate with your renderer is
- * to call
- * {@link #queueEvent(Runnable)}. For example:
- * <pre class="prettyprint">
- * class MyGLSurfaceView extends GLSurfaceView {
- *
- *     private MyRenderer mMyRenderer;
- *
- *     public void start() {
- *         mMyRenderer = ...;
- *         setRenderer(mMyRenderer);
- *     }
- *
- *     public boolean onKeyDown(int keyCode, KeyEvent event) {
- *         if (keyCode == KeyEvent.KEYCODE_DPAD_CENTER) {
- *             queueEvent(new Runnable() {
- *                 // This method will be called on the rendering
- *                 // thread:
- *                 public void run() {
- *                     mMyRenderer.handleDpadCenter();
- *                 }});
- *             return true;
- *         }
- *         return super.onKeyDown(keyCode, event);
- *     }
- * }
- * </pre>
- *
- */
-public class GLSurfaceView extends SurfaceView implements SurfaceHolder.Callback2 {
-    private final static String TAG = "GLSurfaceView";
-    private final static boolean LOG_ATTACH_DETACH = false;
-    private final static boolean LOG_THREADS = false;
-    private final static boolean LOG_PAUSE_RESUME = false;
-    private final static boolean LOG_SURFACE = false;
-    private final static boolean LOG_RENDERER = false;
-    private final static boolean LOG_RENDERER_DRAW_FRAME = false;
-    private final static boolean LOG_EGL = false;
-    /**
-     * The renderer only renders
-     * when the surface is created, or when {@link #requestRender} is called.
-     *
-     * @see #getRenderMode()
-     * @see #setRenderMode(int)
-     * @see #requestRender()
-     */
-    public final static int RENDERMODE_WHEN_DIRTY = 0;
-    /**
-     * The renderer is called
-     * continuously to re-render the scene.
-     *
-     * @see #getRenderMode()
-     * @see #setRenderMode(int)
-     */
-    public final static int RENDERMODE_CONTINUOUSLY = 1;
-
-    /**
-     * Check glError() after every GL call and throw an exception if glError indicates
-     * that an error has occurred. This can be used to help track down which OpenGL ES call
-     * is causing an error.
-     *
-     * @see #getDebugFlags
-     * @see #setDebugFlags
-     */
-    public final static int DEBUG_CHECK_GL_ERROR = 1;
-
-    /**
-     * Log GL calls to the system log at "verbose" level with tag "GLSurfaceView".
-     *
-     * @see #getDebugFlags
-     * @see #setDebugFlags
-     */
-    public final static int DEBUG_LOG_GL_CALLS = 2;
-
-    /**
-     * Standard View constructor. In order to render something, you
-     * must call {@link #setRenderer} to register a renderer.
-     */
-    public GLSurfaceView(Context context) {
-        super(context);
-        init();
-    }
-
-    /**
-     * Standard View constructor. In order to render something, you
-     * must call {@link #setRenderer} to register a renderer.
-     */
-    public GLSurfaceView(Context context, AttributeSet attrs) {
-        super(context, attrs);
-        init();
-    }
-
-    @Override
-    protected void finalize() throws Throwable {
-        try {
-            if (mGLThread != null) {
-                // GLThread may still be running if this view was never
-                // attached to a window.
-                mGLThread.requestExitAndWait();
-            }
-        } finally {
-            super.finalize();
-        }
-    }
-
-    private void init() {
-        // Install a SurfaceHolder.Callback so we get notified when the
-        // underlying surface is created and destroyed
-        SurfaceHolder holder = getHolder();
-        holder.addCallback(this);
-        // setFormat is done by SurfaceView in SDK 2.3 and newer. Uncomment
-        // this statement if back-porting to 2.2 or older:
-        // holder.setFormat(PixelFormat.RGB_565);
-        //
-        // setType is not needed for SDK 2.0 or newer. Uncomment this
-        // statement if back-porting this code to older SDKs.
-        // holder.setType(SurfaceHolder.SURFACE_TYPE_GPU);
-    }
-
-    /**
-     * Set the glWrapper. If the glWrapper is not null, its
-     * {@link GLWrapper#wrap(GL)} method is called
-     * whenever a surface is created. A GLWrapper can be used to wrap
-     * the GL object that's passed to the renderer. Wrapping a GL
-     * object enables examining and modifying the behavior of the
-     * GL calls made by the renderer.
-     * <p>
-     * Wrapping is typically used for debugging purposes.
-     * <p>
-     * The default value is null.
-     * @param glWrapper the new GLWrapper
-     */
-    public void setGLWrapper(GLWrapper glWrapper) {
-        mGLWrapper = glWrapper;
-    }
-
-    /**
-     * Set the debug flags to a new value. The value is
-     * constructed by OR-together zero or more
-     * of the DEBUG_CHECK_* constants. The debug flags take effect
-     * whenever a surface is created. The default value is zero.
-     * @param debugFlags the new debug flags
-     * @see #DEBUG_CHECK_GL_ERROR
-     * @see #DEBUG_LOG_GL_CALLS
-     */
-    public void setDebugFlags(int debugFlags) {
-        mDebugFlags = debugFlags;
-    }
-
-    /**
-     * Get the current value of the debug flags.
-     * @return the current value of the debug flags.
-     */
-    public int getDebugFlags() {
-        return mDebugFlags;
-    }
-
-    /**
-     * Control whether the EGL context is preserved when the GLSurfaceView is paused and
-     * resumed.
-     * <p>
-     * If set to true, then the EGL context may be preserved when the GLSurfaceView is paused.
-     * <p>
-     * Prior to API level 11, whether the EGL context is actually preserved or not
-     * depends upon whether the Android device can support an arbitrary number of
-     * EGL contexts or not. Devices that can only support a limited number of EGL
-     * contexts must release the EGL context in order to allow multiple applications
-     * to share the GPU.
-     * <p>
-     * If set to false, the EGL context will be released when the GLSurfaceView is paused,
-     * and recreated when the GLSurfaceView is resumed.
-     * <p>
-     *
-     * The default is false.
-     *
-     * @param preserveOnPause preserve the EGL context when paused
-     */
-    public void setPreserveEGLContextOnPause(boolean preserveOnPause) {
-        mPreserveEGLContextOnPause = preserveOnPause;
-    }
-
-    /**
-     * @return true if the EGL context will be preserved when paused
-     */
-    public boolean getPreserveEGLContextOnPause() {
-        return mPreserveEGLContextOnPause;
-    }
-
-    /**
-     * Set the renderer associated with this view. Also starts the thread that
-     * will call the renderer, which in turn causes the rendering to start.
-     * <p>This method should be called once and only once in the life-cycle of
-     * a GLSurfaceView.
-     * <p>The following GLSurfaceView methods can only be called <em>before</em>
-     * setRenderer is called:
-     * <ul>
-     * <li>{@link #setEGLConfigChooser(boolean)}
-     * <li>{@link #setEGLConfigChooser(EGLConfigChooser)}
-     * <li>{@link #setEGLConfigChooser(int, int, int, int, int, int)}
-     * </ul>
-     * <p>
-     * The following GLSurfaceView methods can only be called <em>after</em>
-     * setRenderer is called:
-     * <ul>
-     * <li>{@link #getRenderMode()}
-     * <li>{@link #onPause()}
-     * <li>{@link #onResume()}
-     * <li>{@link #queueEvent(Runnable)}
-     * <li>{@link #requestRender()}
-     * <li>{@link #setRenderMode(int)}
-     * </ul>
-     *
-     * @param renderer the renderer to use to perform OpenGL drawing.
-     */
-    public void setRenderer(Renderer renderer) {
-        checkRenderThreadState();
-        if (mEGLConfigChooser == null) {
-            mEGLConfigChooser = new SimpleEGLConfigChooser(true);
-        }
-        if (mEGLContextFactory == null) {
-            mEGLContextFactory = new DefaultContextFactory();
-        }
-        if (mEGLWindowSurfaceFactory == null) {
-            mEGLWindowSurfaceFactory = new DefaultWindowSurfaceFactory();
-        }
-        mRenderer = renderer;
-        mGLThread = new GLThread(mThisWeakRef);
-        mGLThread.start();
-    }
-
-    /**
-     * Install a custom EGLContextFactory.
-     * <p>If this method is
-     * called, it must be called before {@link #setRenderer(Renderer)}
-     * is called.
-     * <p>
-     * If this method is not called, then by default
-     * a context will be created with no shared context and
-     * with a null attribute list.
-     */
-    public void setEGLContextFactory(EGLContextFactory factory) {
-        checkRenderThreadState();
-        mEGLContextFactory = factory;
-    }
-
-    /**
-     * Install a custom EGLWindowSurfaceFactory.
-     * <p>If this method is
-     * called, it must be called before {@link #setRenderer(Renderer)}
-     * is called.
-     * <p>
-     * If this method is not called, then by default
-     * a window surface will be created with a null attribute list.
-     */
-    public void setEGLWindowSurfaceFactory(EGLWindowSurfaceFactory factory) {
-        checkRenderThreadState();
-        mEGLWindowSurfaceFactory = factory;
-    }
-
-    /**
-     * Install a custom EGLConfigChooser.
-     * <p>If this method is
-     * called, it must be called before {@link #setRenderer(Renderer)}
-     * is called.
-     * <p>
-     * If no setEGLConfigChooser method is called, then by default the
-     * view will choose an EGLConfig that is compatible with the current
-     * android.view.Surface, with a depth buffer depth of
-     * at least 16 bits.
-     * @param configChooser
-     */
-    public void setEGLConfigChooser(EGLConfigChooser configChooser) {
-        checkRenderThreadState();
-        mEGLConfigChooser = configChooser;
-    }
-
-    /**
-     * Install a config chooser which will choose a config
-     * as close to 16-bit RGB as possible, with or without an optional depth
-     * buffer as close to 16-bits as possible.
-     * <p>If this method is
-     * called, it must be called before {@link #setRenderer(Renderer)}
-     * is called.
-     * <p>
-     * If no setEGLConfigChooser method is called, then by default the
-     * view will choose an RGB_888 surface with a depth buffer depth of
-     * at least 16 bits.
-     *
-     * @param needDepth
-     */
-    public void setEGLConfigChooser(boolean needDepth) {
-        setEGLConfigChooser(new SimpleEGLConfigChooser(needDepth));
-    }
-
-    /**
-     * Install a config chooser which will choose a config
-     * with at least the specified depthSize and stencilSize,
-     * and exactly the specified redSize, greenSize, blueSize and alphaSize.
-     * <p>If this method is
-     * called, it must be called before {@link #setRenderer(Renderer)}
-     * is called.
-     * <p>
-     * If no setEGLConfigChooser method is called, then by default the
-     * view will choose an RGB_888 surface with a depth buffer depth of
-     * at least 16 bits.
-     *
-     */
-    public void setEGLConfigChooser(int redSize, int greenSize, int blueSize,
-            int alphaSize, int depthSize, int stencilSize) {
-        setEGLConfigChooser(new ComponentSizeChooser(redSize, greenSize,
-                blueSize, alphaSize, depthSize, stencilSize));
-    }
-
-    /**
-     * Inform the default EGLContextFactory and default EGLConfigChooser
-     * which EGLContext client version to pick.
-     * <p>Use this method to create an OpenGL ES 2.0-compatible context.
-     * Example:
-     * <pre class="prettyprint">
-     *     public MyView(Context context) {
-     *         super(context);
-     *         setEGLContextClientVersion(2); // Pick an OpenGL ES 2.0 context.
-     *         setRenderer(new MyRenderer());
-     *     }
-     * </pre>
-     * <p>Note: Activities which require OpenGL ES 2.0 should indicate this by
-     * setting @lt;uses-feature android:glEsVersion="0x00020000" /> in the activity's
-     * AndroidManifest.xml file.
-     * <p>If this method is called, it must be called before {@link #setRenderer(Renderer)}
-     * is called.
-     * <p>This method only affects the behavior of the default EGLContexFactory and the
-     * default EGLConfigChooser. If
-     * {@link #setEGLContextFactory(EGLContextFactory)} has been called, then the supplied
-     * EGLContextFactory is responsible for creating an OpenGL ES 2.0-compatible context.
-     * If
-     * {@link #setEGLConfigChooser(EGLConfigChooser)} has been called, then the supplied
-     * EGLConfigChooser is responsible for choosing an OpenGL ES 2.0-compatible config.
-     * @param version The EGLContext client version to choose. Use 2 for OpenGL ES 2.0
-     */
-    public void setEGLContextClientVersion(int version) {
-        checkRenderThreadState();
-        mEGLContextClientVersion = version;
-    }
-
-    /**
-     * Set the rendering mode. When renderMode is
-     * RENDERMODE_CONTINUOUSLY, the renderer is called
-     * repeatedly to re-render the scene. When renderMode
-     * is RENDERMODE_WHEN_DIRTY, the renderer only rendered when the surface
-     * is created, or when {@link #requestRender} is called. Defaults to RENDERMODE_CONTINUOUSLY.
-     * <p>
-     * Using RENDERMODE_WHEN_DIRTY can improve battery life and overall system performance
-     * by allowing the GPU and CPU to idle when the view does not need to be updated.
-     * <p>
-     * This method can only be called after {@link #setRenderer(Renderer)}
-     *
-     * @param renderMode one of the RENDERMODE_X constants
-     * @see #RENDERMODE_CONTINUOUSLY
-     * @see #RENDERMODE_WHEN_DIRTY
-     */
-    public void setRenderMode(int renderMode) {
-        mGLThread.setRenderMode(renderMode);
-    }
-
-    /**
-     * Get the current rendering mode. May be called
-     * from any thread. Must not be called before a renderer has been set.
-     * @return the current rendering mode.
-     * @see #RENDERMODE_CONTINUOUSLY
-     * @see #RENDERMODE_WHEN_DIRTY
-     */
-    public int getRenderMode() {
-        return mGLThread.getRenderMode();
-    }
-
-    /**
-     * Request that the renderer render a frame.
-     * This method is typically used when the render mode has been set to
-     * {@link #RENDERMODE_WHEN_DIRTY}, so that frames are only rendered on demand.
-     * May be called
-     * from any thread. Must not be called before a renderer has been set.
-     */
-    public void requestRender() {
-        mGLThread.requestRender();
-    }
-
-    /**
-     * This method is part of the SurfaceHolder.Callback interface, and is
-     * not normally called or subclassed by clients of GLSurfaceView.
-     */
-    public void surfaceCreated(SurfaceHolder holder) {
-        mGLThread.surfaceCreated();
-    }
-
-    /**
-     * This method is part of the SurfaceHolder.Callback interface, and is
-     * not normally called or subclassed by clients of GLSurfaceView.
-     */
-    public void surfaceDestroyed(SurfaceHolder holder) {
-        // Surface will be destroyed when we return
-        mGLThread.surfaceDestroyed();
-    }
-
-    /**
-     * This method is part of the SurfaceHolder.Callback interface, and is
-     * not normally called or subclassed by clients of GLSurfaceView.
-     */
-    public void surfaceChanged(SurfaceHolder holder, int format, int w, int h) {
-        mGLThread.onWindowResize(w, h);
-    }
-
-    /**
-     * This method is part of the SurfaceHolder.Callback interface, and is
-     * not normally called or subclassed by clients of GLSurfaceView.
-     */
-    @Override
-    public void surfaceRedrawNeeded(SurfaceHolder holder) {
-        if (mGLThread != null) {
-            mGLThread.requestRenderAndWait();
-        }
-    }
-
-
-    /**
-     * Pause the rendering thread, optionally tearing down the EGL context
-     * depending upon the value of {@link #setPreserveEGLContextOnPause(boolean)}.
-     *
-     * This method should be called when it is no longer desirable for the
-     * GLSurfaceView to continue rendering, such as in response to
-     * {@link android.app.Activity#onStop Activity.onStop}.
-     *
-     * Must not be called before a renderer has been set.
-     */
-    public void onPause() {
-        mGLThread.onPause();
-    }
-
-    /**
-     * Resumes the rendering thread, re-creating the OpenGL context if necessary. It
-     * is the counterpart to {@link #onPause()}.
-     *
-     * This method should typically be called in
-     * {@link android.app.Activity#onStart Activity.onStart}.
-     *
-     * Must not be called before a renderer has been set.
-     */
-    public void onResume() {
-        mGLThread.onResume();
-    }
-
-    /**
-     * Queue a runnable to be run on the GL rendering thread. This can be used
-     * to communicate with the Renderer on the rendering thread.
-     * Must not be called before a renderer has been set.
-     * @param r the runnable to be run on the GL rendering thread.
-     */
-    public void queueEvent(Runnable r) {
-        mGLThread.queueEvent(r);
-    }
-
-    /**
-     * This method is used as part of the View class and is not normally
-     * called or subclassed by clients of GLSurfaceView.
-     */
-    @Override
-    protected void onAttachedToWindow() {
-        super.onAttachedToWindow();
-        if (LOG_ATTACH_DETACH) {
-            Log.d(TAG, "onAttachedToWindow reattach =" + mDetached);
-        }
-        if (mDetached && (mRenderer != null)) {
-            int renderMode = RENDERMODE_CONTINUOUSLY;
-            if (mGLThread != null) {
-                renderMode = mGLThread.getRenderMode();
-            }
-            mGLThread = new GLThread(mThisWeakRef);
-            if (renderMode != RENDERMODE_CONTINUOUSLY) {
-                mGLThread.setRenderMode(renderMode);
-            }
-            mGLThread.start();
-        }
-        mDetached = false;
-    }
-
-    @Override
-    protected void onDetachedFromWindow() {
-        if (LOG_ATTACH_DETACH) {
-            Log.d(TAG, "onDetachedFromWindow");
-        }
-        if (mGLThread != null) {
-            mGLThread.requestExitAndWait();
-        }
-        mDetached = true;
-        super.onDetachedFromWindow();
-    }
-
-    // ----------------------------------------------------------------------
-
-    /**
-     * An interface used to wrap a GL interface.
-     * <p>Typically
-     * used for implementing debugging and tracing on top of the default
-     * GL interface. You would typically use this by creating your own class
-     * that implemented all the GL methods by delegating to another GL instance.
-     * Then you could add your own behavior before or after calling the
-     * delegate. All the GLWrapper would do was instantiate and return the
-     * wrapper GL instance:
-     * <pre class="prettyprint">
-     * class MyGLWrapper implements GLWrapper {
-     *     GL wrap(GL gl) {
-     *         return new MyGLImplementation(gl);
-     *     }
-     *     static class MyGLImplementation implements GL,GL10,GL11,... {
-     *         ...
-     *     }
-     * }
-     * </pre>
-     * @see #setGLWrapper(GLWrapper)
-     */
-    public interface GLWrapper {
-        /**
-         * Wraps a gl interface in another gl interface.
-         * @param gl a GL interface that is to be wrapped.
-         * @return either the input argument or another GL object that wraps the input argument.
-         */
-        GL wrap(GL gl);
-    }
-
-    /**
-     * A generic renderer interface.
-     * <p>
-     * The renderer is responsible for making OpenGL calls to render a frame.
-     * <p>
-     * GLSurfaceView clients typically create their own classes that implement
-     * this interface, and then call {@link GLSurfaceView#setRenderer} to
-     * register the renderer with the GLSurfaceView.
-     * <p>
-     *
-     * <div class="special reference">
-     * <h3>Developer Guides</h3>
-     * <p>For more information about how to use OpenGL, read the
-     * <a href="{@docRoot}guide/topics/graphics/opengl.html">OpenGL</a> developer guide.</p>
-     * </div>
-     *
-     * <h3>Threading</h3>
-     * The renderer will be called on a separate thread, so that rendering
-     * performance is decoupled from the UI thread. Clients typically need to
-     * communicate with the renderer from the UI thread, because that's where
-     * input events are received. Clients can communicate using any of the
-     * standard Java techniques for cross-thread communication, or they can
-     * use the {@link GLSurfaceView#queueEvent(Runnable)} convenience method.
-     * <p>
-     * <h3>EGL Context Lost</h3>
-     * There are situations where the EGL rendering context will be lost. This
-     * typically happens when device wakes up after going to sleep. When
-     * the EGL context is lost, all OpenGL resources (such as textures) that are
-     * associated with that context will be automatically deleted. In order to
-     * keep rendering correctly, a renderer must recreate any lost resources
-     * that it still needs. The {@link #onSurfaceCreated(GL10, EGLConfig)} method
-     * is a convenient place to do this.
-     *
-     *
-     * @see #setRenderer(Renderer)
-     */
-    public interface Renderer {
-        /**
-         * Called when the surface is created or recreated.
-         * <p>
-         * Called when the rendering thread
-         * starts and whenever the EGL context is lost. The EGL context will typically
-         * be lost when the Android device awakes after going to sleep.
-         * <p>
-         * Since this method is called at the beginning of rendering, as well as
-         * every time the EGL context is lost, this method is a convenient place to put
-         * code to create resources that need to be created when the rendering
-         * starts, and that need to be recreated when the EGL context is lost.
-         * Textures are an example of a resource that you might want to create
-         * here.
-         * <p>
-         * Note that when the EGL context is lost, all OpenGL resources associated
-         * with that context will be automatically deleted. You do not need to call
-         * the corresponding "glDelete" methods such as glDeleteTextures to
-         * manually delete these lost resources.
-         * <p>
-         * @param gl the GL interface. Use <code>instanceof</code> to
-         * test if the interface supports GL11 or higher interfaces.
-         * @param config the EGLConfig of the created surface. Can be used
-         * to create matching pbuffers.
-         */
-        void onSurfaceCreated(GL10 gl, EGLConfig config);
-
-        /**
-         * Called when the surface changed size.
-         * <p>
-         * Called after the surface is created and whenever
-         * the OpenGL ES surface size changes.
-         * <p>
-         * Typically you will set your viewport here. If your camera
-         * is fixed then you could also set your projection matrix here:
-         * <pre class="prettyprint">
-         * void onSurfaceChanged(GL10 gl, int width, int height) {
-         *     gl.glViewport(0, 0, width, height);
-         *     // for a fixed camera, set the projection too
-         *     float ratio = (float) width / height;
-         *     gl.glMatrixMode(GL10.GL_PROJECTION);
-         *     gl.glLoadIdentity();
-         *     gl.glFrustumf(-ratio, ratio, -1, 1, 1, 10);
-         * }
-         * </pre>
-         * @param gl the GL interface. Use <code>instanceof</code> to
-         * test if the interface supports GL11 or higher interfaces.
-         * @param width
-         * @param height
-         */
-        void onSurfaceChanged(GL10 gl, int width, int height);
-
-        /**
-         * Called to draw the current frame.
-         * <p>
-         * This method is responsible for drawing the current frame.
-         * <p>
-         * The implementation of this method typically looks like this:
-         * <pre class="prettyprint">
-         * void onDrawFrame(GL10 gl) {
-         *     gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
-         *     //... other gl calls to render the scene ...
-         * }
-         * </pre>
-         * @param gl the GL interface. Use <code>instanceof</code> to
-         * test if the interface supports GL11 or higher interfaces.
-         */
-        void onDrawFrame(GL10 gl);
-    }
-
-    /**
-     * An interface for customizing the eglCreateContext and eglDestroyContext calls.
-     * <p>
-     * This interface must be implemented by clients wishing to call
-     * {@link GLSurfaceView#setEGLContextFactory(EGLContextFactory)}
-     */
-    public interface EGLContextFactory {
-        EGLContext createContext(EGL10 egl, EGLDisplay display, EGLConfig eglConfig);
-        void destroyContext(EGL10 egl, EGLDisplay display, EGLContext context);
-    }
-
-    private class DefaultContextFactory implements EGLContextFactory {
-        private int EGL_CONTEXT_CLIENT_VERSION = 0x3098;
-
-        public EGLContext createContext(EGL10 egl, EGLDisplay display, EGLConfig config) {
-            int[] attrib_list = {EGL_CONTEXT_CLIENT_VERSION, mEGLContextClientVersion,
-                    EGL10.EGL_NONE };
-
-            return egl.eglCreateContext(display, config, EGL10.EGL_NO_CONTEXT,
-                    mEGLContextClientVersion != 0 ? attrib_list : null);
-        }
-
-        public void destroyContext(EGL10 egl, EGLDisplay display,
-                EGLContext context) {
-            if (!egl.eglDestroyContext(display, context)) {
-                Log.e("DefaultContextFactory", "display:" + display + " context: " + context);
-                if (LOG_THREADS) {
-                    Log.i("DefaultContextFactory", "tid=" + Thread.currentThread().getId());
-                }
-                EglHelper.throwEglException("eglDestroyContex", egl.eglGetError());
-            }
-        }
-    }
-
-    /**
-     * An interface for customizing the eglCreateWindowSurface and eglDestroySurface calls.
-     * <p>
-     * This interface must be implemented by clients wishing to call
-     * {@link GLSurfaceView#setEGLWindowSurfaceFactory(EGLWindowSurfaceFactory)}
-     */
-    public interface EGLWindowSurfaceFactory {
-        /**
-         *  @return null if the surface cannot be constructed.
-         */
-        EGLSurface createWindowSurface(EGL10 egl, EGLDisplay display, EGLConfig config,
-                Object nativeWindow);
-        void destroySurface(EGL10 egl, EGLDisplay display, EGLSurface surface);
-    }
-
-    private static class DefaultWindowSurfaceFactory implements EGLWindowSurfaceFactory {
-
-        public EGLSurface createWindowSurface(EGL10 egl, EGLDisplay display,
-                EGLConfig config, Object nativeWindow) {
-            EGLSurface result = null;
-            try {
-                result = egl.eglCreateWindowSurface(display, config, nativeWindow, null);
-            } catch (IllegalArgumentException e) {
-                // This exception indicates that the surface flinger surface
-                // is not valid. This can happen if the surface flinger surface has
-                // been torn down, but the application has not yet been
-                // notified via SurfaceHolder.Callback.surfaceDestroyed.
-                // In theory the application should be notified first,
-                // but in practice sometimes it is not. See b/4588890
-                Log.e(TAG, "eglCreateWindowSurface", e);
-            }
-            return result;
-        }
-
-        public void destroySurface(EGL10 egl, EGLDisplay display,
-                EGLSurface surface) {
-            egl.eglDestroySurface(display, surface);
-        }
-    }
-
-    /**
-     * An interface for choosing an EGLConfig configuration from a list of
-     * potential configurations.
-     * <p>
-     * This interface must be implemented by clients wishing to call
-     * {@link GLSurfaceView#setEGLConfigChooser(EGLConfigChooser)}
-     */
-    public interface EGLConfigChooser {
-        /**
-         * Choose a configuration from the list. Implementors typically
-         * implement this method by calling
-         * {@link EGL10#eglChooseConfig} and iterating through the results. Please consult the
-         * EGL specification available from The Khronos Group to learn how to call eglChooseConfig.
-         * @param egl the EGL10 for the current display.
-         * @param display the current display.
-         * @return the chosen configuration.
-         */
-        EGLConfig chooseConfig(EGL10 egl, EGLDisplay display);
-    }
-
-    private abstract class BaseConfigChooser
-            implements EGLConfigChooser {
-        public BaseConfigChooser(int[] configSpec) {
-            mConfigSpec = filterConfigSpec(configSpec);
-        }
-
-        public EGLConfig chooseConfig(EGL10 egl, EGLDisplay display) {
-            int[] num_config = new int[1];
-            if (!egl.eglChooseConfig(display, mConfigSpec, null, 0,
-                    num_config)) {
-                throw new IllegalArgumentException("eglChooseConfig failed");
-            }
-
-            int numConfigs = num_config[0];
-
-            if (numConfigs <= 0) {
-                throw new IllegalArgumentException(
-                        "No configs match configSpec");
-            }
-
-            EGLConfig[] configs = new EGLConfig[numConfigs];
-            if (!egl.eglChooseConfig(display, mConfigSpec, configs, numConfigs,
-                    num_config)) {
-                throw new IllegalArgumentException("eglChooseConfig#2 failed");
-            }
-            EGLConfig config = chooseConfig(egl, display, configs);
-            if (config == null) {
-                throw new IllegalArgumentException("No config chosen");
-            }
-            return config;
-        }
-
-        abstract EGLConfig chooseConfig(EGL10 egl, EGLDisplay display,
-                EGLConfig[] configs);
-
-        protected int[] mConfigSpec;
-
-        private int[] filterConfigSpec(int[] configSpec) {
-            if (mEGLContextClientVersion != 2 && mEGLContextClientVersion != 3) {
-                return configSpec;
-            }
-            /* We know none of the subclasses define EGL_RENDERABLE_TYPE.
-             * And we know the configSpec is well formed.
-             */
-            int len = configSpec.length;
-            int[] newConfigSpec = new int[len + 2];
-            System.arraycopy(configSpec, 0, newConfigSpec, 0, len-1);
-            newConfigSpec[len-1] = EGL10.EGL_RENDERABLE_TYPE;
-            if (mEGLContextClientVersion == 2) {
-                newConfigSpec[len] = EGL14.EGL_OPENGL_ES2_BIT;  /* EGL_OPENGL_ES2_BIT */
-            } else {
-                newConfigSpec[len] = EGLExt.EGL_OPENGL_ES3_BIT_KHR; /* EGL_OPENGL_ES3_BIT_KHR */
-            }
-            newConfigSpec[len+1] = EGL10.EGL_NONE;
-            return newConfigSpec;
-        }
-    }
-
-    /**
-     * Choose a configuration with exactly the specified r,g,b,a sizes,
-     * and at least the specified depth and stencil sizes.
-     */
-    private class ComponentSizeChooser extends BaseConfigChooser {
-        public ComponentSizeChooser(int redSize, int greenSize, int blueSize,
-                int alphaSize, int depthSize, int stencilSize) {
-            super(new int[] {
-                    EGL10.EGL_RED_SIZE, redSize,
-                    EGL10.EGL_GREEN_SIZE, greenSize,
-                    EGL10.EGL_BLUE_SIZE, blueSize,
-                    EGL10.EGL_ALPHA_SIZE, alphaSize,
-                    EGL10.EGL_DEPTH_SIZE, depthSize,
-                    EGL10.EGL_STENCIL_SIZE, stencilSize,
-                    EGL10.EGL_NONE});
-            mValue = new int[1];
-            mRedSize = redSize;
-            mGreenSize = greenSize;
-            mBlueSize = blueSize;
-            mAlphaSize = alphaSize;
-            mDepthSize = depthSize;
-            mStencilSize = stencilSize;
-       }
-
-        @Override
-        public EGLConfig chooseConfig(EGL10 egl, EGLDisplay display,
-                EGLConfig[] configs) {
-            for (EGLConfig config : configs) {
-                int d = findConfigAttrib(egl, display, config,
-                        EGL10.EGL_DEPTH_SIZE, 0);
-                int s = findConfigAttrib(egl, display, config,
-                        EGL10.EGL_STENCIL_SIZE, 0);
-                if ((d >= mDepthSize) && (s >= mStencilSize)) {
-                    int r = findConfigAttrib(egl, display, config,
-                            EGL10.EGL_RED_SIZE, 0);
-                    int g = findConfigAttrib(egl, display, config,
-                             EGL10.EGL_GREEN_SIZE, 0);
-                    int b = findConfigAttrib(egl, display, config,
-                              EGL10.EGL_BLUE_SIZE, 0);
-                    int a = findConfigAttrib(egl, display, config,
-                            EGL10.EGL_ALPHA_SIZE, 0);
-                    if ((r == mRedSize) && (g == mGreenSize)
-                            && (b == mBlueSize) && (a == mAlphaSize)) {
-                        return config;
-                    }
-                }
-            }
-            return null;
-        }
-
-        private int findConfigAttrib(EGL10 egl, EGLDisplay display,
-                EGLConfig config, int attribute, int defaultValue) {
-
-            if (egl.eglGetConfigAttrib(display, config, attribute, mValue)) {
-                return mValue[0];
-            }
-            return defaultValue;
-        }
-
-        private int[] mValue;
-        // Subclasses can adjust these values:
-        protected int mRedSize;
-        protected int mGreenSize;
-        protected int mBlueSize;
-        protected int mAlphaSize;
-        protected int mDepthSize;
-        protected int mStencilSize;
-        }
-
-    /**
-     * This class will choose a RGB_888 surface with
-     * or without a depth buffer.
-     *
-     */
-    private class SimpleEGLConfigChooser extends ComponentSizeChooser {
-        public SimpleEGLConfigChooser(boolean withDepthBuffer) {
-            super(8, 8, 8, 0, withDepthBuffer ? 16 : 0, 0);
-        }
-    }
-
-    /**
-     * An EGL helper class.
-     */
-
-    private static class EglHelper {
-        public EglHelper(WeakReference<GLSurfaceView> glSurfaceViewWeakRef) {
-            mGLSurfaceViewWeakRef = glSurfaceViewWeakRef;
-        }
-
-        /**
-         * Initialize EGL for a given configuration spec.
-         * @param configSpec
-         */
-        public void start() {
-            if (LOG_EGL) {
-                Log.w("EglHelper", "start() tid=" + Thread.currentThread().getId());
-            }
-            /*
-             * Get an EGL instance
-             */
-            mEgl = (EGL10) EGLContext.getEGL();
-
-            /*
-             * Get to the default display.
-             */
-            mEglDisplay = mEgl.eglGetDisplay(EGL10.EGL_DEFAULT_DISPLAY);
-
-            if (mEglDisplay == EGL10.EGL_NO_DISPLAY) {
-                throw new RuntimeException("eglGetDisplay failed");
-            }
-
-            /*
-             * We can now initialize EGL for that display
-             */
-            int[] version = new int[2];
-            if(!mEgl.eglInitialize(mEglDisplay, version)) {
-                throw new RuntimeException("eglInitialize failed");
-            }
-            GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-            if (view == null) {
-                mEglConfig = null;
-                mEglContext = null;
-            } else {
-                mEglConfig = view.mEGLConfigChooser.chooseConfig(mEgl, mEglDisplay);
-
-                /*
-                * Create an EGL context. We want to do this as rarely as we can, because an
-                * EGL context is a somewhat heavy object.
-                */
-                mEglContext = view.mEGLContextFactory.createContext(mEgl, mEglDisplay, mEglConfig);
-            }
-            if (mEglContext == null || mEglContext == EGL10.EGL_NO_CONTEXT) {
-                mEglContext = null;
-                throwEglException("createContext");
-            }
-            if (LOG_EGL) {
-                Log.w("EglHelper", "createContext " + mEglContext + " tid=" + Thread.currentThread().getId());
-            }
-
-            mEglSurface = null;
-        }
-
-        /**
-         * Create an egl surface for the current SurfaceHolder surface. If a surface
-         * already exists, destroy it before creating the new surface.
-         *
-         * @return true if the surface was created successfully.
-         */
-        public boolean createSurface() {
-            if (LOG_EGL) {
-                Log.w("EglHelper", "createSurface()  tid=" + Thread.currentThread().getId());
-            }
-            /*
-             * Check preconditions.
-             */
-            if (mEgl == null) {
-                throw new RuntimeException("egl not initialized");
-            }
-            if (mEglDisplay == null) {
-                throw new RuntimeException("eglDisplay not initialized");
-            }
-            if (mEglConfig == null) {
-                throw new RuntimeException("mEglConfig not initialized");
-            }
-
-            /*
-             *  The window size has changed, so we need to create a new
-             *  surface.
-             */
-            destroySurfaceImp();
-
-            /*
-             * Create an EGL surface we can render into.
-             */
-            GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-            if (view != null) {
-                mEglSurface = view.mEGLWindowSurfaceFactory.createWindowSurface(mEgl,
-                        mEglDisplay, mEglConfig, view.getHolder());
-            } else {
-                mEglSurface = null;
-            }
-
-            if (mEglSurface == null || mEglSurface == EGL10.EGL_NO_SURFACE) {
-                int error = mEgl.eglGetError();
-                if (error == EGL10.EGL_BAD_NATIVE_WINDOW) {
-                    Log.e("EglHelper", "createWindowSurface returned EGL_BAD_NATIVE_WINDOW.");
-                }
-                return false;
-            }
-
-            /*
-             * Before we can issue GL commands, we need to make sure
-             * the context is current and bound to a surface.
-             */
-            if (!mEgl.eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface, mEglContext)) {
-                /*
-                 * Could not make the context current, probably because the underlying
-                 * SurfaceView surface has been destroyed.
-                 */
-                logEglErrorAsWarning("EGLHelper", "eglMakeCurrent", mEgl.eglGetError());
-                return false;
-            }
-
-            return true;
-        }
-
-        /**
-         * Create a GL object for the current EGL context.
-         * @return
-         */
-        GL createGL() {
-
-            GL gl = mEglContext.getGL();
-            GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-            if (view != null) {
-                if (view.mGLWrapper != null) {
-                    gl = view.mGLWrapper.wrap(gl);
-                }
-
-                if ((view.mDebugFlags & (DEBUG_CHECK_GL_ERROR | DEBUG_LOG_GL_CALLS)) != 0) {
-                    int configFlags = 0;
-                    Writer log = null;
-                    if ((view.mDebugFlags & DEBUG_CHECK_GL_ERROR) != 0) {
-                        configFlags |= GLDebugHelper.CONFIG_CHECK_GL_ERROR;
-                    }
-                    if ((view.mDebugFlags & DEBUG_LOG_GL_CALLS) != 0) {
-                        log = new LogWriter();
-                    }
-                    gl = GLDebugHelper.wrap(gl, configFlags, log);
-                }
-            }
-            return gl;
-        }
-
-        /**
-         * Display the current render surface.
-         * @return the EGL error code from eglSwapBuffers.
-         */
-        public int swap() {
-            if (! mEgl.eglSwapBuffers(mEglDisplay, mEglSurface)) {
-                return mEgl.eglGetError();
-            }
-            return EGL10.EGL_SUCCESS;
-        }
-
-        public void destroySurface() {
-            if (LOG_EGL) {
-                Log.w("EglHelper", "destroySurface()  tid=" + Thread.currentThread().getId());
-            }
-            destroySurfaceImp();
-        }
-
-        private void destroySurfaceImp() {
-            if (mEglSurface != null && mEglSurface != EGL10.EGL_NO_SURFACE) {
-                mEgl.eglMakeCurrent(mEglDisplay, EGL10.EGL_NO_SURFACE,
-                        EGL10.EGL_NO_SURFACE,
-                        EGL10.EGL_NO_CONTEXT);
-                GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-                if (view != null) {
-                    view.mEGLWindowSurfaceFactory.destroySurface(mEgl, mEglDisplay, mEglSurface);
-                }
-                mEglSurface = null;
-            }
-        }
-
-        public void finish() {
-            if (LOG_EGL) {
-                Log.w("EglHelper", "finish() tid=" + Thread.currentThread().getId());
-            }
-            if (mEglContext != null) {
-                GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-                if (view != null) {
-                    view.mEGLContextFactory.destroyContext(mEgl, mEglDisplay, mEglContext);
-                }
-                mEglContext = null;
-            }
-            if (mEglDisplay != null) {
-                mEgl.eglTerminate(mEglDisplay);
-                mEglDisplay = null;
-            }
-        }
-
-        private void throwEglException(String function) {
-            throwEglException(function, mEgl.eglGetError());
-        }
-
-        public static void throwEglException(String function, int error) {
-            String message = formatEglError(function, error);
-            if (LOG_THREADS) {
-                Log.e("EglHelper", "throwEglException tid=" + Thread.currentThread().getId() + " "
-                        + message);
-            }
-            throw new RuntimeException(message);
-        }
-
-        public static void logEglErrorAsWarning(String tag, String function, int error) {
-            Log.w(tag, formatEglError(function, error));
-        }
-
-        public static String formatEglError(String function, int error) {
-            return function + " failed: " + EGLLogWrapper.getErrorString(error);
-        }
-
-        private WeakReference<GLSurfaceView> mGLSurfaceViewWeakRef;
-        EGL10 mEgl;
-        EGLDisplay mEglDisplay;
-        EGLSurface mEglSurface;
-        EGLConfig mEglConfig;
-        EGLContext mEglContext;
-
-    }
-
-    /**
-     * A generic GL Thread. Takes care of initializing EGL and GL. Delegates
-     * to a Renderer instance to do the actual drawing. Can be configured to
-     * render continuously or on request.
-     *
-     * All potentially blocking synchronization is done through the
-     * sGLThreadManager object. This avoids multiple-lock ordering issues.
-     *
-     */
-    static class GLThread extends Thread {
-        GLThread(WeakReference<GLSurfaceView> glSurfaceViewWeakRef) {
-            super();
-            mWidth = 0;
-            mHeight = 0;
-            mRequestRender = true;
-            mRenderMode = RENDERMODE_CONTINUOUSLY;
-            mWantRenderNotification = false;
-            mGLSurfaceViewWeakRef = glSurfaceViewWeakRef;
-        }
-
-        @Override
-        public void run() {
-            setName("GLThread " + getId());
-            if (LOG_THREADS) {
-                Log.i("GLThread", "starting tid=" + getId());
-            }
-
-            try {
-                guardedRun();
-            } catch (InterruptedException e) {
-                // fall thru and exit normally
-            } finally {
-                sGLThreadManager.threadExiting(this);
-            }
-        }
-
-        /*
-         * This private method should only be called inside a
-         * synchronized(sGLThreadManager) block.
-         */
-        private void stopEglSurfaceLocked() {
-            if (mHaveEglSurface) {
-                mHaveEglSurface = false;
-                mEglHelper.destroySurface();
-            }
-        }
-
-        /*
-         * This private method should only be called inside a
-         * synchronized(sGLThreadManager) block.
-         */
-        private void stopEglContextLocked() {
-            if (mHaveEglContext) {
-                mEglHelper.finish();
-                mHaveEglContext = false;
-                sGLThreadManager.releaseEglContextLocked(this);
-            }
-        }
-        private void guardedRun() throws InterruptedException {
-            mEglHelper = new EglHelper(mGLSurfaceViewWeakRef);
-            mHaveEglContext = false;
-            mHaveEglSurface = false;
-            mWantRenderNotification = false;
-
-            try {
-                GL10 gl = null;
-                boolean createEglContext = false;
-                boolean createEglSurface = false;
-                boolean createGlInterface = false;
-                boolean lostEglContext = false;
-                boolean sizeChanged = false;
-                boolean wantRenderNotification = false;
-                boolean doRenderNotification = false;
-                boolean askedToReleaseEglContext = false;
-                int w = 0;
-                int h = 0;
-                Runnable event = null;
-
-                while (true) {
-                    synchronized (sGLThreadManager) {
-                        while (true) {
-                            if (mShouldExit) {
-                                return;
-                            }
-
-                            if (! mEventQueue.isEmpty()) {
-                                event = mEventQueue.remove(0);
-                                break;
-                            }
-
-                            // Update the pause state.
-                            boolean pausing = false;
-                            if (mPaused != mRequestPaused) {
-                                pausing = mRequestPaused;
-                                mPaused = mRequestPaused;
-                                sGLThreadManager.notifyAll();
-                                if (LOG_PAUSE_RESUME) {
-                                    Log.i("GLThread", "mPaused is now " + mPaused + " tid=" + getId());
-                                }
-                            }
-
-                            // Do we need to give up the EGL context?
-                            if (mShouldReleaseEglContext) {
-                                if (LOG_SURFACE) {
-                                    Log.i("GLThread", "releasing EGL context because asked to tid=" + getId());
-                                }
-                                stopEglSurfaceLocked();
-                                stopEglContextLocked();
-                                mShouldReleaseEglContext = false;
-                                askedToReleaseEglContext = true;
-                            }
-
-                            // Have we lost the EGL context?
-                            if (lostEglContext) {
-                                stopEglSurfaceLocked();
-                                stopEglContextLocked();
-                                lostEglContext = false;
-                            }
-
-                            // When pausing, release the EGL surface:
-                            if (pausing && mHaveEglSurface) {
-                                if (LOG_SURFACE) {
-                                    Log.i("GLThread", "releasing EGL surface because paused tid=" + getId());
-                                }
-                                stopEglSurfaceLocked();
-                            }
-
-                            // When pausing, optionally release the EGL Context:
-                            if (pausing && mHaveEglContext) {
-                                GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-                                boolean preserveEglContextOnPause = view == null ?
-                                        false : view.mPreserveEGLContextOnPause;
-                                if (!preserveEglContextOnPause) {
-                                    stopEglContextLocked();
-                                    if (LOG_SURFACE) {
-                                        Log.i("GLThread", "releasing EGL context because paused tid=" + getId());
-                                    }
-                                }
-                            }
-
-                            // Have we lost the SurfaceView surface?
-                            if ((! mHasSurface) && (! mWaitingForSurface)) {
-                                if (LOG_SURFACE) {
-                                    Log.i("GLThread", "noticed surfaceView surface lost tid=" + getId());
-                                }
-                                if (mHaveEglSurface) {
-                                    stopEglSurfaceLocked();
-                                }
-                                mWaitingForSurface = true;
-                                mSurfaceIsBad = false;
-                                sGLThreadManager.notifyAll();
-                            }
-
-                            // Have we acquired the surface view surface?
-                            if (mHasSurface && mWaitingForSurface) {
-                                if (LOG_SURFACE) {
-                                    Log.i("GLThread", "noticed surfaceView surface acquired tid=" + getId());
-                                }
-                                mWaitingForSurface = false;
-                                sGLThreadManager.notifyAll();
-                            }
-
-                            if (doRenderNotification) {
-                                if (LOG_SURFACE) {
-                                    Log.i("GLThread", "sending render notification tid=" + getId());
-                                }
-                                mWantRenderNotification = false;
-                                doRenderNotification = false;
-                                mRenderComplete = true;
-                                sGLThreadManager.notifyAll();
-                            }
-
-                            // Ready to draw?
-                            if (readyToDraw()) {
-
-                                // If we don't have an EGL context, try to acquire one.
-                                if (! mHaveEglContext) {
-                                    if (askedToReleaseEglContext) {
-                                        askedToReleaseEglContext = false;
-                                    } else {
-                                        try {
-                                            mEglHelper.start();
-                                        } catch (RuntimeException t) {
-                                            sGLThreadManager.releaseEglContextLocked(this);
-                                            throw t;
-                                        }
-                                        mHaveEglContext = true;
-                                        createEglContext = true;
-
-                                        sGLThreadManager.notifyAll();
-                                    }
-                                }
-
-                                if (mHaveEglContext && !mHaveEglSurface) {
-                                    mHaveEglSurface = true;
-                                    createEglSurface = true;
-                                    createGlInterface = true;
-                                    sizeChanged = true;
-                                }
-
-                                if (mHaveEglSurface) {
-                                    if (mSizeChanged) {
-                                        sizeChanged = true;
-                                        w = mWidth;
-                                        h = mHeight;
-                                        mWantRenderNotification = true;
-                                        if (LOG_SURFACE) {
-                                            Log.i("GLThread",
-                                                    "noticing that we want render notification tid="
-                                                    + getId());
-                                        }
-
-                                        // Destroy and recreate the EGL surface.
-                                        createEglSurface = true;
-
-                                        mSizeChanged = false;
-                                    }
-                                    mRequestRender = false;
-                                    sGLThreadManager.notifyAll();
-                                    if (mWantRenderNotification) {
-                                        wantRenderNotification = true;
-                                    }
-                                    break;
-                                }
-                            }
-
-                            // By design, this is the only place in a GLThread thread where we wait().
-                            if (LOG_THREADS) {
-                                Log.i("GLThread", "waiting tid=" + getId()
-                                    + " mHaveEglContext: " + mHaveEglContext
-                                    + " mHaveEglSurface: " + mHaveEglSurface
-                                    + " mFinishedCreatingEglSurface: " + mFinishedCreatingEglSurface
-                                    + " mPaused: " + mPaused
-                                    + " mHasSurface: " + mHasSurface
-                                    + " mSurfaceIsBad: " + mSurfaceIsBad
-                                    + " mWaitingForSurface: " + mWaitingForSurface
-                                    + " mWidth: " + mWidth
-                                    + " mHeight: " + mHeight
-                                    + " mRequestRender: " + mRequestRender
-                                    + " mRenderMode: " + mRenderMode);
-                            }
-                            sGLThreadManager.wait();
-                        }
-                    } // end of synchronized(sGLThreadManager)
-
-                    if (event != null) {
-                        event.run();
-                        event = null;
-                        continue;
-                    }
-
-                    if (createEglSurface) {
-                        if (LOG_SURFACE) {
-                            Log.w("GLThread", "egl createSurface");
-                        }
-                        if (mEglHelper.createSurface()) {
-                            synchronized(sGLThreadManager) {
-                                mFinishedCreatingEglSurface = true;
-                                sGLThreadManager.notifyAll();
-                            }
-                        } else {
-                            synchronized(sGLThreadManager) {
-                                mFinishedCreatingEglSurface = true;
-                                mSurfaceIsBad = true;
-                                sGLThreadManager.notifyAll();
-                            }
-                            continue;
-                        }
-                        createEglSurface = false;
-                    }
-
-                    if (createGlInterface) {
-                        gl = (GL10) mEglHelper.createGL();
-
-                        createGlInterface = false;
-                    }
-
-                    if (createEglContext) {
-                        if (LOG_RENDERER) {
-                            Log.w("GLThread", "onSurfaceCreated");
-                        }
-                        GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-                        if (view != null) {
-                            try {
-                                Trace.traceBegin(Trace.TRACE_TAG_VIEW, "onSurfaceCreated");
-                                view.mRenderer.onSurfaceCreated(gl, mEglHelper.mEglConfig);
-                            } finally {
-                                Trace.traceEnd(Trace.TRACE_TAG_VIEW);
-                            }
-                        }
-                        createEglContext = false;
-                    }
-
-                    if (sizeChanged) {
-                        if (LOG_RENDERER) {
-                            Log.w("GLThread", "onSurfaceChanged(" + w + ", " + h + ")");
-                        }
-                        GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-                        if (view != null) {
-                            try {
-                                Trace.traceBegin(Trace.TRACE_TAG_VIEW, "onSurfaceChanged");
-                                view.mRenderer.onSurfaceChanged(gl, w, h);
-                            } finally {
-                                Trace.traceEnd(Trace.TRACE_TAG_VIEW);
-                            }
-                        }
-                        sizeChanged = false;
-                    }
-
-                    if (LOG_RENDERER_DRAW_FRAME) {
-                        Log.w("GLThread", "onDrawFrame tid=" + getId());
-                    }
-                    {
-                        GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-                        if (view != null) {
-                            try {
-                                Trace.traceBegin(Trace.TRACE_TAG_VIEW, "onDrawFrame");
-                                view.mRenderer.onDrawFrame(gl);
-                            } finally {
-                                Trace.traceEnd(Trace.TRACE_TAG_VIEW);
-                            }
-                        }
-                    }
-                    int swapError = mEglHelper.swap();
-                    switch (swapError) {
-                        case EGL10.EGL_SUCCESS:
-                            break;
-                        case EGL11.EGL_CONTEXT_LOST:
-                            if (LOG_SURFACE) {
-                                Log.i("GLThread", "egl context lost tid=" + getId());
-                            }
-                            lostEglContext = true;
-                            break;
-                        default:
-                            // Other errors typically mean that the current surface is bad,
-                            // probably because the SurfaceView surface has been destroyed,
-                            // but we haven't been notified yet.
-                            // Log the error to help developers understand why rendering stopped.
-                            EglHelper.logEglErrorAsWarning("GLThread", "eglSwapBuffers", swapError);
-
-                            synchronized(sGLThreadManager) {
-                                mSurfaceIsBad = true;
-                                sGLThreadManager.notifyAll();
-                            }
-                            break;
-                    }
-
-                    if (wantRenderNotification) {
-                        doRenderNotification = true;
-                        wantRenderNotification = false;
-                    }
-                }
-
-            } finally {
-                /*
-                 * clean-up everything...
-                 */
-                synchronized (sGLThreadManager) {
-                    stopEglSurfaceLocked();
-                    stopEglContextLocked();
-                }
-            }
-        }
-
-        public boolean ableToDraw() {
-            return mHaveEglContext && mHaveEglSurface && readyToDraw();
-        }
-
-        private boolean readyToDraw() {
-            return (!mPaused) && mHasSurface && (!mSurfaceIsBad)
-                && (mWidth > 0) && (mHeight > 0)
-                && (mRequestRender || (mRenderMode == RENDERMODE_CONTINUOUSLY));
-        }
-
-        public void setRenderMode(int renderMode) {
-            if ( !((RENDERMODE_WHEN_DIRTY <= renderMode) && (renderMode <= RENDERMODE_CONTINUOUSLY)) ) {
-                throw new IllegalArgumentException("renderMode");
-            }
-            synchronized(sGLThreadManager) {
-                mRenderMode = renderMode;
-                sGLThreadManager.notifyAll();
-            }
-        }
-
-        public int getRenderMode() {
-            synchronized(sGLThreadManager) {
-                return mRenderMode;
-            }
-        }
-
-        public void requestRender() {
-            synchronized(sGLThreadManager) {
-                mRequestRender = true;
-                sGLThreadManager.notifyAll();
-            }
-        }
-
-        public void requestRenderAndWait() {
-            synchronized(sGLThreadManager) {
-                // If we are already on the GL thread, this means a client callback
-                // has caused reentrancy, for example via updating the SurfaceView parameters.
-                // We will return to the client rendering code, so here we don't need to
-                // do anything.
-                if (Thread.currentThread() == this) {
-                    return;
-                }
-
-                mWantRenderNotification = true;
-                mRequestRender = true;
-                mRenderComplete = false;
-
-                sGLThreadManager.notifyAll();
-
-                while (!mExited && !mPaused && !mRenderComplete && ableToDraw()) {
-                    try {
-                        sGLThreadManager.wait();
-                    } catch (InterruptedException ex) {
-                        Thread.currentThread().interrupt();
-                    }
-                }
-
-            }
-        }
-
-        public void surfaceCreated() {
-            synchronized(sGLThreadManager) {
-                if (LOG_THREADS) {
-                    Log.i("GLThread", "surfaceCreated tid=" + getId());
-                }
-                mHasSurface = true;
-                mFinishedCreatingEglSurface = false;
-                sGLThreadManager.notifyAll();
-                while (mWaitingForSurface
-                       && !mFinishedCreatingEglSurface
-                       && !mExited) {
-                    try {
-                        sGLThreadManager.wait();
-                    } catch (InterruptedException e) {
-                        Thread.currentThread().interrupt();
-                    }
-                }
-            }
-        }
-
-        public void surfaceDestroyed() {
-            synchronized(sGLThreadManager) {
-                if (LOG_THREADS) {
-                    Log.i("GLThread", "surfaceDestroyed tid=" + getId());
-                }
-                mHasSurface = false;
-                sGLThreadManager.notifyAll();
-                while((!mWaitingForSurface) && (!mExited)) {
-                    try {
-                        sGLThreadManager.wait();
-                    } catch (InterruptedException e) {
-                        Thread.currentThread().interrupt();
-                    }
-                }
-            }
-        }
-
-        public void onPause() {
-            synchronized (sGLThreadManager) {
-                if (LOG_PAUSE_RESUME) {
-                    Log.i("GLThread", "onPause tid=" + getId());
-                }
-                mRequestPaused = true;
-                sGLThreadManager.notifyAll();
-                while ((! mExited) && (! mPaused)) {
-                    if (LOG_PAUSE_RESUME) {
-                        Log.i("Main thread", "onPause waiting for mPaused.");
-                    }
-                    try {
-                        sGLThreadManager.wait();
-                    } catch (InterruptedException ex) {
-                        Thread.currentThread().interrupt();
-                    }
-                }
-            }
-        }
-
-        public void onResume() {
-            synchronized (sGLThreadManager) {
-                if (LOG_PAUSE_RESUME) {
-                    Log.i("GLThread", "onResume tid=" + getId());
-                }
-                mRequestPaused = false;
-                mRequestRender = true;
-                mRenderComplete = false;
-                sGLThreadManager.notifyAll();
-                while ((! mExited) && mPaused && (!mRenderComplete)) {
-                    if (LOG_PAUSE_RESUME) {
-                        Log.i("Main thread", "onResume waiting for !mPaused.");
-                    }
-                    try {
-                        sGLThreadManager.wait();
-                    } catch (InterruptedException ex) {
-                        Thread.currentThread().interrupt();
-                    }
-                }
-            }
-        }
-
-        public void onWindowResize(int w, int h) {
-            synchronized (sGLThreadManager) {
-                mWidth = w;
-                mHeight = h;
-                mSizeChanged = true;
-                mRequestRender = true;
-                mRenderComplete = false;
-
-                // If we are already on the GL thread, this means a client callback
-                // has caused reentrancy, for example via updating the SurfaceView parameters.
-                // We need to process the size change eventually though and update our EGLSurface.
-                // So we set the parameters and return so they can be processed on our
-                // next iteration.
-                if (Thread.currentThread() == this) {
-                    return;
-                }
-
-                sGLThreadManager.notifyAll();
-
-                // Wait for thread to react to resize and render a frame
-                while (! mExited && !mPaused && !mRenderComplete
-                        && ableToDraw()) {
-                    if (LOG_SURFACE) {
-                        Log.i("Main thread", "onWindowResize waiting for render complete from tid=" + getId());
-                    }
-                    try {
-                        sGLThreadManager.wait();
-                    } catch (InterruptedException ex) {
-                        Thread.currentThread().interrupt();
-                    }
-                }
-            }
-        }
-
-        public void requestExitAndWait() {
-            // don't call this from GLThread thread or it is a guaranteed
-            // deadlock!
-            synchronized(sGLThreadManager) {
-                mShouldExit = true;
-                sGLThreadManager.notifyAll();
-                while (! mExited) {
-                    try {
-                        sGLThreadManager.wait();
-                    } catch (InterruptedException ex) {
-                        Thread.currentThread().interrupt();
-                    }
-                }
-            }
-        }
-
-        public void requestReleaseEglContextLocked() {
-            mShouldReleaseEglContext = true;
-            sGLThreadManager.notifyAll();
-        }
-
-        /**
-         * Queue an "event" to be run on the GL rendering thread.
-         * @param r the runnable to be run on the GL rendering thread.
-         */
-        public void queueEvent(Runnable r) {
-            if (r == null) {
-                throw new IllegalArgumentException("r must not be null");
-            }
-            synchronized(sGLThreadManager) {
-                mEventQueue.add(r);
-                sGLThreadManager.notifyAll();
-            }
-        }
-
-        // Once the thread is started, all accesses to the following member
-        // variables are protected by the sGLThreadManager monitor
-        private boolean mShouldExit;
-        private boolean mExited;
-        private boolean mRequestPaused;
-        private boolean mPaused;
-        private boolean mHasSurface;
-        private boolean mSurfaceIsBad;
-        private boolean mWaitingForSurface;
-        private boolean mHaveEglContext;
-        private boolean mHaveEglSurface;
-        private boolean mFinishedCreatingEglSurface;
-        private boolean mShouldReleaseEglContext;
-        private int mWidth;
-        private int mHeight;
-        private int mRenderMode;
-        private boolean mRequestRender;
-        private boolean mWantRenderNotification;
-        private boolean mRenderComplete;
-        private ArrayList<Runnable> mEventQueue = new ArrayList<Runnable>();
-        private boolean mSizeChanged = true;
-
-        // End of member variables protected by the sGLThreadManager monitor.
-
-        private EglHelper mEglHelper;
-
-        /**
-         * Set once at thread construction time, nulled out when the parent view is garbage
-         * called. This weak reference allows the GLSurfaceView to be garbage collected while
-         * the GLThread is still alive.
-         */
-        private WeakReference<GLSurfaceView> mGLSurfaceViewWeakRef;
-
-    }
-
-    static class LogWriter extends Writer {
-
-        @Override public void close() {
-            flushBuilder();
-        }
-
-        @Override public void flush() {
-            flushBuilder();
-        }
-
-        @Override public void write(char[] buf, int offset, int count) {
-            for(int i = 0; i < count; i++) {
-                char c = buf[offset + i];
-                if ( c == '\n') {
-                    flushBuilder();
-                }
-                else {
-                    mBuilder.append(c);
-                }
-            }
-        }
-
-        private void flushBuilder() {
-            if (mBuilder.length() > 0) {
-                Log.v("GLSurfaceView", mBuilder.toString());
-                mBuilder.delete(0, mBuilder.length());
-            }
-        }
-
-        private StringBuilder mBuilder = new StringBuilder();
-    }
-
-
-    private void checkRenderThreadState() {
-        if (mGLThread != null) {
-            throw new IllegalStateException(
-                    "setRenderer has already been called for this instance.");
-        }
-    }
-
-    private static class GLThreadManager {
-        private static String TAG = "GLThreadManager";
-
-        public synchronized void threadExiting(GLThread thread) {
-            if (LOG_THREADS) {
-                Log.i("GLThread", "exiting tid=" +  thread.getId());
-            }
-            thread.mExited = true;
-            notifyAll();
-        }
-
-        /*
-         * Releases the EGL context. Requires that we are already in the
-         * sGLThreadManager monitor when this is called.
-         */
-        public void releaseEglContextLocked(GLThread thread) {
-            notifyAll();
-        }
-    }
-
-    private static final GLThreadManager sGLThreadManager = new GLThreadManager();
-
-    private final WeakReference<GLSurfaceView> mThisWeakRef =
-            new WeakReference<GLSurfaceView>(this);
-    private GLThread mGLThread;
-    private Renderer mRenderer;
-    private boolean mDetached;
-    private EGLConfigChooser mEGLConfigChooser;
-    private EGLContextFactory mEGLContextFactory;
-    private EGLWindowSurfaceFactory mEGLWindowSurfaceFactory;
-    private GLWrapper mGLWrapper;
-    private int mDebugFlags;
-    private int mEGLContextClientVersion;
-    private boolean mPreserveEGLContextOnPause;
-}
diff -Naur frameworksRaw/base/opengl/java/android/opengl/GLSurfaceView.java.orig.orig frameworksModified/base/opengl/java/android/opengl/GLSurfaceView.java.orig.orig
--- frameworksRaw/base/opengl/java/android/opengl/GLSurfaceView.java.orig.orig	2017-07-06 15:34:16.006009602 +0530
+++ frameworksModified/base/opengl/java/android/opengl/GLSurfaceView.java.orig.orig	1970-01-01 05:30:00.000000000 +0530
@@ -1,1912 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.opengl;
-
-import android.content.Context;
-import android.os.Trace;
-import android.util.AttributeSet;
-import android.util.Log;
-import android.view.SurfaceHolder;
-import android.view.SurfaceView;
-
-import java.io.Writer;
-import java.lang.ref.WeakReference;
-import java.util.ArrayList;
-
-import javax.microedition.khronos.egl.EGL10;
-import javax.microedition.khronos.egl.EGL11;
-import javax.microedition.khronos.egl.EGLConfig;
-import javax.microedition.khronos.egl.EGLContext;
-import javax.microedition.khronos.egl.EGLDisplay;
-import javax.microedition.khronos.egl.EGLSurface;
-import javax.microedition.khronos.opengles.GL;
-import javax.microedition.khronos.opengles.GL10;
-
-/**
- * An implementation of SurfaceView that uses the dedicated surface for
- * displaying OpenGL rendering.
- * <p>
- * A GLSurfaceView provides the following features:
- * <p>
- * <ul>
- * <li>Manages a surface, which is a special piece of memory that can be
- * composited into the Android view system.
- * <li>Manages an EGL display, which enables OpenGL to render into a surface.
- * <li>Accepts a user-provided Renderer object that does the actual rendering.
- * <li>Renders on a dedicated thread to decouple rendering performance from the
- * UI thread.
- * <li>Supports both on-demand and continuous rendering.
- * <li>Optionally wraps, traces, and/or error-checks the renderer's OpenGL calls.
- * </ul>
- *
- * <div class="special reference">
- * <h3>Developer Guides</h3>
- * <p>For more information about how to use OpenGL, read the
- * <a href="{@docRoot}guide/topics/graphics/opengl.html">OpenGL</a> developer guide.</p>
- * </div>
- *
- * <h3>Using GLSurfaceView</h3>
- * <p>
- * Typically you use GLSurfaceView by subclassing it and overriding one or more of the
- * View system input event methods. If your application does not need to override event
- * methods then GLSurfaceView can be used as-is. For the most part
- * GLSurfaceView behavior is customized by calling "set" methods rather than by subclassing.
- * For example, unlike a regular View, drawing is delegated to a separate Renderer object which
- * is registered with the GLSurfaceView
- * using the {@link #setRenderer(Renderer)} call.
- * <p>
- * <h3>Initializing GLSurfaceView</h3>
- * All you have to do to initialize a GLSurfaceView is call {@link #setRenderer(Renderer)}.
- * However, if desired, you can modify the default behavior of GLSurfaceView by calling one or
- * more of these methods before calling setRenderer:
- * <ul>
- * <li>{@link #setDebugFlags(int)}
- * <li>{@link #setEGLConfigChooser(boolean)}
- * <li>{@link #setEGLConfigChooser(EGLConfigChooser)}
- * <li>{@link #setEGLConfigChooser(int, int, int, int, int, int)}
- * <li>{@link #setGLWrapper(GLWrapper)}
- * </ul>
- * <p>
- * <h4>Specifying the android.view.Surface</h4>
- * By default GLSurfaceView will create a PixelFormat.RGB_888 format surface. If a translucent
- * surface is required, call getHolder().setFormat(PixelFormat.TRANSLUCENT).
- * The exact format of a TRANSLUCENT surface is device dependent, but it will be
- * a 32-bit-per-pixel surface with 8 bits per component.
- * <p>
- * <h4>Choosing an EGL Configuration</h4>
- * A given Android device may support multiple EGLConfig rendering configurations.
- * The available configurations may differ in how may channels of data are present, as
- * well as how many bits are allocated to each channel. Therefore, the first thing
- * GLSurfaceView has to do when starting to render is choose what EGLConfig to use.
- * <p>
- * By default GLSurfaceView chooses a EGLConfig that has an RGB_888 pixel format,
- * with at least a 16-bit depth buffer and no stencil.
- * <p>
- * If you would prefer a different EGLConfig
- * you can override the default behavior by calling one of the
- * setEGLConfigChooser methods.
- * <p>
- * <h4>Debug Behavior</h4>
- * You can optionally modify the behavior of GLSurfaceView by calling
- * one or more of the debugging methods {@link #setDebugFlags(int)},
- * and {@link #setGLWrapper}. These methods may be called before and/or after setRenderer, but
- * typically they are called before setRenderer so that they take effect immediately.
- * <p>
- * <h4>Setting a Renderer</h4>
- * Finally, you must call {@link #setRenderer} to register a {@link Renderer}.
- * The renderer is
- * responsible for doing the actual OpenGL rendering.
- * <p>
- * <h3>Rendering Mode</h3>
- * Once the renderer is set, you can control whether the renderer draws
- * continuously or on-demand by calling
- * {@link #setRenderMode}. The default is continuous rendering.
- * <p>
- * <h3>Activity Life-cycle</h3>
- * A GLSurfaceView must be notified when to pause and resume rendering. GLSurfaceView clients
- * are required to call {@link #onPause()} when the activity stops and
- * {@link #onResume()} when the activity starts. These calls allow GLSurfaceView to
- * pause and resume the rendering thread, and also allow GLSurfaceView to release and recreate
- * the OpenGL display.
- * <p>
- * <h3>Handling events</h3>
- * <p>
- * To handle an event you will typically subclass GLSurfaceView and override the
- * appropriate method, just as you would with any other View. However, when handling
- * the event, you may need to communicate with the Renderer object
- * that's running in the rendering thread. You can do this using any
- * standard Java cross-thread communication mechanism. In addition,
- * one relatively easy way to communicate with your renderer is
- * to call
- * {@link #queueEvent(Runnable)}. For example:
- * <pre class="prettyprint">
- * class MyGLSurfaceView extends GLSurfaceView {
- *
- *     private MyRenderer mMyRenderer;
- *
- *     public void start() {
- *         mMyRenderer = ...;
- *         setRenderer(mMyRenderer);
- *     }
- *
- *     public boolean onKeyDown(int keyCode, KeyEvent event) {
- *         if (keyCode == KeyEvent.KEYCODE_DPAD_CENTER) {
- *             queueEvent(new Runnable() {
- *                 // This method will be called on the rendering
- *                 // thread:
- *                 public void run() {
- *                     mMyRenderer.handleDpadCenter();
- *                 }});
- *             return true;
- *         }
- *         return super.onKeyDown(keyCode, event);
- *     }
- * }
- * </pre>
- *
- */
-public class GLSurfaceView extends SurfaceView implements SurfaceHolder.Callback2 {
-    private final static String TAG = "GLSurfaceView";
-    private final static boolean LOG_ATTACH_DETACH = false;
-    private final static boolean LOG_THREADS = false;
-    private final static boolean LOG_PAUSE_RESUME = false;
-    private final static boolean LOG_SURFACE = false;
-    private final static boolean LOG_RENDERER = false;
-    private final static boolean LOG_RENDERER_DRAW_FRAME = false;
-    private final static boolean LOG_EGL = false;
-    /**
-     * The renderer only renders
-     * when the surface is created, or when {@link #requestRender} is called.
-     *
-     * @see #getRenderMode()
-     * @see #setRenderMode(int)
-     * @see #requestRender()
-     */
-    public final static int RENDERMODE_WHEN_DIRTY = 0;
-    /**
-     * The renderer is called
-     * continuously to re-render the scene.
-     *
-     * @see #getRenderMode()
-     * @see #setRenderMode(int)
-     */
-    public final static int RENDERMODE_CONTINUOUSLY = 1;
-
-    /**
-     * Check glError() after every GL call and throw an exception if glError indicates
-     * that an error has occurred. This can be used to help track down which OpenGL ES call
-     * is causing an error.
-     *
-     * @see #getDebugFlags
-     * @see #setDebugFlags
-     */
-    public final static int DEBUG_CHECK_GL_ERROR = 1;
-
-    /**
-     * Log GL calls to the system log at "verbose" level with tag "GLSurfaceView".
-     *
-     * @see #getDebugFlags
-     * @see #setDebugFlags
-     */
-    public final static int DEBUG_LOG_GL_CALLS = 2;
-
-    /**
-     * Standard View constructor. In order to render something, you
-     * must call {@link #setRenderer} to register a renderer.
-     */
-    public GLSurfaceView(Context context) {
-        super(context);
-        init();
-    }
-
-    /**
-     * Standard View constructor. In order to render something, you
-     * must call {@link #setRenderer} to register a renderer.
-     */
-    public GLSurfaceView(Context context, AttributeSet attrs) {
-        super(context, attrs);
-        init();
-    }
-
-    @Override
-    protected void finalize() throws Throwable {
-        try {
-            if (mGLThread != null) {
-                // GLThread may still be running if this view was never
-                // attached to a window.
-                mGLThread.requestExitAndWait();
-            }
-        } finally {
-            super.finalize();
-        }
-    }
-
-    private void init() {
-        // Install a SurfaceHolder.Callback so we get notified when the
-        // underlying surface is created and destroyed
-        SurfaceHolder holder = getHolder();
-        holder.addCallback(this);
-        // setFormat is done by SurfaceView in SDK 2.3 and newer. Uncomment
-        // this statement if back-porting to 2.2 or older:
-        // holder.setFormat(PixelFormat.RGB_565);
-        //
-        // setType is not needed for SDK 2.0 or newer. Uncomment this
-        // statement if back-porting this code to older SDKs.
-        // holder.setType(SurfaceHolder.SURFACE_TYPE_GPU);
-    }
-
-    /**
-     * Set the glWrapper. If the glWrapper is not null, its
-     * {@link GLWrapper#wrap(GL)} method is called
-     * whenever a surface is created. A GLWrapper can be used to wrap
-     * the GL object that's passed to the renderer. Wrapping a GL
-     * object enables examining and modifying the behavior of the
-     * GL calls made by the renderer.
-     * <p>
-     * Wrapping is typically used for debugging purposes.
-     * <p>
-     * The default value is null.
-     * @param glWrapper the new GLWrapper
-     */
-    public void setGLWrapper(GLWrapper glWrapper) {
-        mGLWrapper = glWrapper;
-    }
-
-    /**
-     * Set the debug flags to a new value. The value is
-     * constructed by OR-together zero or more
-     * of the DEBUG_CHECK_* constants. The debug flags take effect
-     * whenever a surface is created. The default value is zero.
-     * @param debugFlags the new debug flags
-     * @see #DEBUG_CHECK_GL_ERROR
-     * @see #DEBUG_LOG_GL_CALLS
-     */
-    public void setDebugFlags(int debugFlags) {
-        mDebugFlags = debugFlags;
-    }
-
-    /**
-     * Get the current value of the debug flags.
-     * @return the current value of the debug flags.
-     */
-    public int getDebugFlags() {
-        return mDebugFlags;
-    }
-
-    /**
-     * Control whether the EGL context is preserved when the GLSurfaceView is paused and
-     * resumed.
-     * <p>
-     * If set to true, then the EGL context may be preserved when the GLSurfaceView is paused.
-     * <p>
-     * Prior to API level 11, whether the EGL context is actually preserved or not
-     * depends upon whether the Android device can support an arbitrary number of
-     * EGL contexts or not. Devices that can only support a limited number of EGL
-     * contexts must release the EGL context in order to allow multiple applications
-     * to share the GPU.
-     * <p>
-     * If set to false, the EGL context will be released when the GLSurfaceView is paused,
-     * and recreated when the GLSurfaceView is resumed.
-     * <p>
-     *
-     * The default is false.
-     *
-     * @param preserveOnPause preserve the EGL context when paused
-     */
-    public void setPreserveEGLContextOnPause(boolean preserveOnPause) {
-        mPreserveEGLContextOnPause = preserveOnPause;
-    }
-
-    /**
-     * @return true if the EGL context will be preserved when paused
-     */
-    public boolean getPreserveEGLContextOnPause() {
-        return mPreserveEGLContextOnPause;
-    }
-
-    /**
-     * Set the renderer associated with this view. Also starts the thread that
-     * will call the renderer, which in turn causes the rendering to start.
-     * <p>This method should be called once and only once in the life-cycle of
-     * a GLSurfaceView.
-     * <p>The following GLSurfaceView methods can only be called <em>before</em>
-     * setRenderer is called:
-     * <ul>
-     * <li>{@link #setEGLConfigChooser(boolean)}
-     * <li>{@link #setEGLConfigChooser(EGLConfigChooser)}
-     * <li>{@link #setEGLConfigChooser(int, int, int, int, int, int)}
-     * </ul>
-     * <p>
-     * The following GLSurfaceView methods can only be called <em>after</em>
-     * setRenderer is called:
-     * <ul>
-     * <li>{@link #getRenderMode()}
-     * <li>{@link #onPause()}
-     * <li>{@link #onResume()}
-     * <li>{@link #queueEvent(Runnable)}
-     * <li>{@link #requestRender()}
-     * <li>{@link #setRenderMode(int)}
-     * </ul>
-     *
-     * @param renderer the renderer to use to perform OpenGL drawing.
-     */
-    public void setRenderer(Renderer renderer) {
-        checkRenderThreadState();
-        if (mEGLConfigChooser == null) {
-            mEGLConfigChooser = new SimpleEGLConfigChooser(true);
-        }
-        if (mEGLContextFactory == null) {
-            mEGLContextFactory = new DefaultContextFactory();
-        }
-        if (mEGLWindowSurfaceFactory == null) {
-            mEGLWindowSurfaceFactory = new DefaultWindowSurfaceFactory();
-        }
-        mRenderer = renderer;
-        mGLThread = new GLThread(mThisWeakRef);
-        mGLThread.start();
-    }
-
-    /**
-     * Install a custom EGLContextFactory.
-     * <p>If this method is
-     * called, it must be called before {@link #setRenderer(Renderer)}
-     * is called.
-     * <p>
-     * If this method is not called, then by default
-     * a context will be created with no shared context and
-     * with a null attribute list.
-     */
-    public void setEGLContextFactory(EGLContextFactory factory) {
-        checkRenderThreadState();
-        mEGLContextFactory = factory;
-    }
-
-    /**
-     * Install a custom EGLWindowSurfaceFactory.
-     * <p>If this method is
-     * called, it must be called before {@link #setRenderer(Renderer)}
-     * is called.
-     * <p>
-     * If this method is not called, then by default
-     * a window surface will be created with a null attribute list.
-     */
-    public void setEGLWindowSurfaceFactory(EGLWindowSurfaceFactory factory) {
-        checkRenderThreadState();
-        mEGLWindowSurfaceFactory = factory;
-    }
-
-    /**
-     * Install a custom EGLConfigChooser.
-     * <p>If this method is
-     * called, it must be called before {@link #setRenderer(Renderer)}
-     * is called.
-     * <p>
-     * If no setEGLConfigChooser method is called, then by default the
-     * view will choose an EGLConfig that is compatible with the current
-     * android.view.Surface, with a depth buffer depth of
-     * at least 16 bits.
-     * @param configChooser
-     */
-    public void setEGLConfigChooser(EGLConfigChooser configChooser) {
-        checkRenderThreadState();
-        mEGLConfigChooser = configChooser;
-    }
-
-    /**
-     * Install a config chooser which will choose a config
-     * as close to 16-bit RGB as possible, with or without an optional depth
-     * buffer as close to 16-bits as possible.
-     * <p>If this method is
-     * called, it must be called before {@link #setRenderer(Renderer)}
-     * is called.
-     * <p>
-     * If no setEGLConfigChooser method is called, then by default the
-     * view will choose an RGB_888 surface with a depth buffer depth of
-     * at least 16 bits.
-     *
-     * @param needDepth
-     */
-    public void setEGLConfigChooser(boolean needDepth) {
-        setEGLConfigChooser(new SimpleEGLConfigChooser(needDepth));
-    }
-
-    /**
-     * Install a config chooser which will choose a config
-     * with at least the specified depthSize and stencilSize,
-     * and exactly the specified redSize, greenSize, blueSize and alphaSize.
-     * <p>If this method is
-     * called, it must be called before {@link #setRenderer(Renderer)}
-     * is called.
-     * <p>
-     * If no setEGLConfigChooser method is called, then by default the
-     * view will choose an RGB_888 surface with a depth buffer depth of
-     * at least 16 bits.
-     *
-     */
-    public void setEGLConfigChooser(int redSize, int greenSize, int blueSize,
-            int alphaSize, int depthSize, int stencilSize) {
-        setEGLConfigChooser(new ComponentSizeChooser(redSize, greenSize,
-                blueSize, alphaSize, depthSize, stencilSize));
-    }
-
-    /**
-     * Inform the default EGLContextFactory and default EGLConfigChooser
-     * which EGLContext client version to pick.
-     * <p>Use this method to create an OpenGL ES 2.0-compatible context.
-     * Example:
-     * <pre class="prettyprint">
-     *     public MyView(Context context) {
-     *         super(context);
-     *         setEGLContextClientVersion(2); // Pick an OpenGL ES 2.0 context.
-     *         setRenderer(new MyRenderer());
-     *     }
-     * </pre>
-     * <p>Note: Activities which require OpenGL ES 2.0 should indicate this by
-     * setting @lt;uses-feature android:glEsVersion="0x00020000" /> in the activity's
-     * AndroidManifest.xml file.
-     * <p>If this method is called, it must be called before {@link #setRenderer(Renderer)}
-     * is called.
-     * <p>This method only affects the behavior of the default EGLContexFactory and the
-     * default EGLConfigChooser. If
-     * {@link #setEGLContextFactory(EGLContextFactory)} has been called, then the supplied
-     * EGLContextFactory is responsible for creating an OpenGL ES 2.0-compatible context.
-     * If
-     * {@link #setEGLConfigChooser(EGLConfigChooser)} has been called, then the supplied
-     * EGLConfigChooser is responsible for choosing an OpenGL ES 2.0-compatible config.
-     * @param version The EGLContext client version to choose. Use 2 for OpenGL ES 2.0
-     */
-    public void setEGLContextClientVersion(int version) {
-        checkRenderThreadState();
-        mEGLContextClientVersion = version;
-    }
-
-    /**
-     * Set the rendering mode. When renderMode is
-     * RENDERMODE_CONTINUOUSLY, the renderer is called
-     * repeatedly to re-render the scene. When renderMode
-     * is RENDERMODE_WHEN_DIRTY, the renderer only rendered when the surface
-     * is created, or when {@link #requestRender} is called. Defaults to RENDERMODE_CONTINUOUSLY.
-     * <p>
-     * Using RENDERMODE_WHEN_DIRTY can improve battery life and overall system performance
-     * by allowing the GPU and CPU to idle when the view does not need to be updated.
-     * <p>
-     * This method can only be called after {@link #setRenderer(Renderer)}
-     *
-     * @param renderMode one of the RENDERMODE_X constants
-     * @see #RENDERMODE_CONTINUOUSLY
-     * @see #RENDERMODE_WHEN_DIRTY
-     */
-    public void setRenderMode(int renderMode) {
-        mGLThread.setRenderMode(renderMode);
-    }
-
-    /**
-     * Get the current rendering mode. May be called
-     * from any thread. Must not be called before a renderer has been set.
-     * @return the current rendering mode.
-     * @see #RENDERMODE_CONTINUOUSLY
-     * @see #RENDERMODE_WHEN_DIRTY
-     */
-    public int getRenderMode() {
-        return mGLThread.getRenderMode();
-    }
-
-    /**
-     * Request that the renderer render a frame.
-     * This method is typically used when the render mode has been set to
-     * {@link #RENDERMODE_WHEN_DIRTY}, so that frames are only rendered on demand.
-     * May be called
-     * from any thread. Must not be called before a renderer has been set.
-     */
-    public void requestRender() {
-        mGLThread.requestRender();
-    }
-
-    /**
-     * This method is part of the SurfaceHolder.Callback interface, and is
-     * not normally called or subclassed by clients of GLSurfaceView.
-     */
-    public void surfaceCreated(SurfaceHolder holder) {
-        mGLThread.surfaceCreated();
-    }
-
-    /**
-     * This method is part of the SurfaceHolder.Callback interface, and is
-     * not normally called or subclassed by clients of GLSurfaceView.
-     */
-    public void surfaceDestroyed(SurfaceHolder holder) {
-        // Surface will be destroyed when we return
-        mGLThread.surfaceDestroyed();
-    }
-
-    /**
-     * This method is part of the SurfaceHolder.Callback interface, and is
-     * not normally called or subclassed by clients of GLSurfaceView.
-     */
-    public void surfaceChanged(SurfaceHolder holder, int format, int w, int h) {
-        mGLThread.onWindowResize(w, h);
-    }
-
-    /**
-     * This method is part of the SurfaceHolder.Callback interface, and is
-     * not normally called or subclassed by clients of GLSurfaceView.
-     */
-    @Override
-    public void surfaceRedrawNeeded(SurfaceHolder holder) {
-        if (mGLThread != null) {
-            mGLThread.requestRenderAndWait();
-        }
-    }
-
-
-    /**
-     * Pause the rendering thread, optionally tearing down the EGL context
-     * depending upon the value of {@link #setPreserveEGLContextOnPause(boolean)}.
-     *
-     * This method should be called when it is no longer desirable for the
-     * GLSurfaceView to continue rendering, such as in response to
-     * {@link android.app.Activity#onStop Activity.onStop}.
-     *
-     * Must not be called before a renderer has been set.
-     */
-    public void onPause() {
-        mGLThread.onPause();
-    }
-
-    /**
-     * Resumes the rendering thread, re-creating the OpenGL context if necessary. It
-     * is the counterpart to {@link #onPause()}.
-     *
-     * This method should typically be called in
-     * {@link android.app.Activity#onStart Activity.onStart}.
-     *
-     * Must not be called before a renderer has been set.
-     */
-    public void onResume() {
-        mGLThread.onResume();
-    }
-
-    /**
-     * Queue a runnable to be run on the GL rendering thread. This can be used
-     * to communicate with the Renderer on the rendering thread.
-     * Must not be called before a renderer has been set.
-     * @param r the runnable to be run on the GL rendering thread.
-     */
-    public void queueEvent(Runnable r) {
-        mGLThread.queueEvent(r);
-    }
-
-    /**
-     * This method is used as part of the View class and is not normally
-     * called or subclassed by clients of GLSurfaceView.
-     */
-    @Override
-    protected void onAttachedToWindow() {
-        super.onAttachedToWindow();
-        if (LOG_ATTACH_DETACH) {
-            Log.d(TAG, "onAttachedToWindow reattach =" + mDetached);
-        }
-        if (mDetached && (mRenderer != null)) {
-            int renderMode = RENDERMODE_CONTINUOUSLY;
-            if (mGLThread != null) {
-                renderMode = mGLThread.getRenderMode();
-            }
-            mGLThread = new GLThread(mThisWeakRef);
-            if (renderMode != RENDERMODE_CONTINUOUSLY) {
-                mGLThread.setRenderMode(renderMode);
-            }
-            mGLThread.start();
-        }
-        mDetached = false;
-    }
-
-    @Override
-    protected void onDetachedFromWindow() {
-        if (LOG_ATTACH_DETACH) {
-            Log.d(TAG, "onDetachedFromWindow");
-        }
-        if (mGLThread != null) {
-            mGLThread.requestExitAndWait();
-        }
-        mDetached = true;
-        super.onDetachedFromWindow();
-    }
-
-    // ----------------------------------------------------------------------
-
-    /**
-     * An interface used to wrap a GL interface.
-     * <p>Typically
-     * used for implementing debugging and tracing on top of the default
-     * GL interface. You would typically use this by creating your own class
-     * that implemented all the GL methods by delegating to another GL instance.
-     * Then you could add your own behavior before or after calling the
-     * delegate. All the GLWrapper would do was instantiate and return the
-     * wrapper GL instance:
-     * <pre class="prettyprint">
-     * class MyGLWrapper implements GLWrapper {
-     *     GL wrap(GL gl) {
-     *         return new MyGLImplementation(gl);
-     *     }
-     *     static class MyGLImplementation implements GL,GL10,GL11,... {
-     *         ...
-     *     }
-     * }
-     * </pre>
-     * @see #setGLWrapper(GLWrapper)
-     */
-    public interface GLWrapper {
-        /**
-         * Wraps a gl interface in another gl interface.
-         * @param gl a GL interface that is to be wrapped.
-         * @return either the input argument or another GL object that wraps the input argument.
-         */
-        GL wrap(GL gl);
-    }
-
-    /**
-     * A generic renderer interface.
-     * <p>
-     * The renderer is responsible for making OpenGL calls to render a frame.
-     * <p>
-     * GLSurfaceView clients typically create their own classes that implement
-     * this interface, and then call {@link GLSurfaceView#setRenderer} to
-     * register the renderer with the GLSurfaceView.
-     * <p>
-     *
-     * <div class="special reference">
-     * <h3>Developer Guides</h3>
-     * <p>For more information about how to use OpenGL, read the
-     * <a href="{@docRoot}guide/topics/graphics/opengl.html">OpenGL</a> developer guide.</p>
-     * </div>
-     *
-     * <h3>Threading</h3>
-     * The renderer will be called on a separate thread, so that rendering
-     * performance is decoupled from the UI thread. Clients typically need to
-     * communicate with the renderer from the UI thread, because that's where
-     * input events are received. Clients can communicate using any of the
-     * standard Java techniques for cross-thread communication, or they can
-     * use the {@link GLSurfaceView#queueEvent(Runnable)} convenience method.
-     * <p>
-     * <h3>EGL Context Lost</h3>
-     * There are situations where the EGL rendering context will be lost. This
-     * typically happens when device wakes up after going to sleep. When
-     * the EGL context is lost, all OpenGL resources (such as textures) that are
-     * associated with that context will be automatically deleted. In order to
-     * keep rendering correctly, a renderer must recreate any lost resources
-     * that it still needs. The {@link #onSurfaceCreated(GL10, EGLConfig)} method
-     * is a convenient place to do this.
-     *
-     *
-     * @see #setRenderer(Renderer)
-     */
-    public interface Renderer {
-        /**
-         * Called when the surface is created or recreated.
-         * <p>
-         * Called when the rendering thread
-         * starts and whenever the EGL context is lost. The EGL context will typically
-         * be lost when the Android device awakes after going to sleep.
-         * <p>
-         * Since this method is called at the beginning of rendering, as well as
-         * every time the EGL context is lost, this method is a convenient place to put
-         * code to create resources that need to be created when the rendering
-         * starts, and that need to be recreated when the EGL context is lost.
-         * Textures are an example of a resource that you might want to create
-         * here.
-         * <p>
-         * Note that when the EGL context is lost, all OpenGL resources associated
-         * with that context will be automatically deleted. You do not need to call
-         * the corresponding "glDelete" methods such as glDeleteTextures to
-         * manually delete these lost resources.
-         * <p>
-         * @param gl the GL interface. Use <code>instanceof</code> to
-         * test if the interface supports GL11 or higher interfaces.
-         * @param config the EGLConfig of the created surface. Can be used
-         * to create matching pbuffers.
-         */
-        void onSurfaceCreated(GL10 gl, EGLConfig config);
-
-        /**
-         * Called when the surface changed size.
-         * <p>
-         * Called after the surface is created and whenever
-         * the OpenGL ES surface size changes.
-         * <p>
-         * Typically you will set your viewport here. If your camera
-         * is fixed then you could also set your projection matrix here:
-         * <pre class="prettyprint">
-         * void onSurfaceChanged(GL10 gl, int width, int height) {
-         *     gl.glViewport(0, 0, width, height);
-         *     // for a fixed camera, set the projection too
-         *     float ratio = (float) width / height;
-         *     gl.glMatrixMode(GL10.GL_PROJECTION);
-         *     gl.glLoadIdentity();
-         *     gl.glFrustumf(-ratio, ratio, -1, 1, 1, 10);
-         * }
-         * </pre>
-         * @param gl the GL interface. Use <code>instanceof</code> to
-         * test if the interface supports GL11 or higher interfaces.
-         * @param width
-         * @param height
-         */
-        void onSurfaceChanged(GL10 gl, int width, int height);
-
-        /**
-         * Called to draw the current frame.
-         * <p>
-         * This method is responsible for drawing the current frame.
-         * <p>
-         * The implementation of this method typically looks like this:
-         * <pre class="prettyprint">
-         * void onDrawFrame(GL10 gl) {
-         *     gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
-         *     //... other gl calls to render the scene ...
-         * }
-         * </pre>
-         * @param gl the GL interface. Use <code>instanceof</code> to
-         * test if the interface supports GL11 or higher interfaces.
-         */
-        void onDrawFrame(GL10 gl);
-    }
-
-    /**
-     * An interface for customizing the eglCreateContext and eglDestroyContext calls.
-     * <p>
-     * This interface must be implemented by clients wishing to call
-     * {@link GLSurfaceView#setEGLContextFactory(EGLContextFactory)}
-     */
-    public interface EGLContextFactory {
-        EGLContext createContext(EGL10 egl, EGLDisplay display, EGLConfig eglConfig);
-        void destroyContext(EGL10 egl, EGLDisplay display, EGLContext context);
-    }
-
-    private class DefaultContextFactory implements EGLContextFactory {
-        private int EGL_CONTEXT_CLIENT_VERSION = 0x3098;
-
-        public EGLContext createContext(EGL10 egl, EGLDisplay display, EGLConfig config) {
-            int[] attrib_list = {EGL_CONTEXT_CLIENT_VERSION, mEGLContextClientVersion,
-                    EGL10.EGL_NONE };
-
-            return egl.eglCreateContext(display, config, EGL10.EGL_NO_CONTEXT,
-                    mEGLContextClientVersion != 0 ? attrib_list : null);
-        }
-
-        public void destroyContext(EGL10 egl, EGLDisplay display,
-                EGLContext context) {
-            if (!egl.eglDestroyContext(display, context)) {
-                Log.e("DefaultContextFactory", "display:" + display + " context: " + context);
-                if (LOG_THREADS) {
-                    Log.i("DefaultContextFactory", "tid=" + Thread.currentThread().getId());
-                }
-                EglHelper.throwEglException("eglDestroyContex", egl.eglGetError());
-            }
-        }
-    }
-
-    /**
-     * An interface for customizing the eglCreateWindowSurface and eglDestroySurface calls.
-     * <p>
-     * This interface must be implemented by clients wishing to call
-     * {@link GLSurfaceView#setEGLWindowSurfaceFactory(EGLWindowSurfaceFactory)}
-     */
-    public interface EGLWindowSurfaceFactory {
-        /**
-         *  @return null if the surface cannot be constructed.
-         */
-        EGLSurface createWindowSurface(EGL10 egl, EGLDisplay display, EGLConfig config,
-                Object nativeWindow);
-        void destroySurface(EGL10 egl, EGLDisplay display, EGLSurface surface);
-    }
-
-    private static class DefaultWindowSurfaceFactory implements EGLWindowSurfaceFactory {
-
-        public EGLSurface createWindowSurface(EGL10 egl, EGLDisplay display,
-                EGLConfig config, Object nativeWindow) {
-            EGLSurface result = null;
-            try {
-                result = egl.eglCreateWindowSurface(display, config, nativeWindow, null);
-            } catch (IllegalArgumentException e) {
-                // This exception indicates that the surface flinger surface
-                // is not valid. This can happen if the surface flinger surface has
-                // been torn down, but the application has not yet been
-                // notified via SurfaceHolder.Callback.surfaceDestroyed.
-                // In theory the application should be notified first,
-                // but in practice sometimes it is not. See b/4588890
-                Log.e(TAG, "eglCreateWindowSurface", e);
-            }
-            return result;
-        }
-
-        public void destroySurface(EGL10 egl, EGLDisplay display,
-                EGLSurface surface) {
-            egl.eglDestroySurface(display, surface);
-        }
-    }
-
-    /**
-     * An interface for choosing an EGLConfig configuration from a list of
-     * potential configurations.
-     * <p>
-     * This interface must be implemented by clients wishing to call
-     * {@link GLSurfaceView#setEGLConfigChooser(EGLConfigChooser)}
-     */
-    public interface EGLConfigChooser {
-        /**
-         * Choose a configuration from the list. Implementors typically
-         * implement this method by calling
-         * {@link EGL10#eglChooseConfig} and iterating through the results. Please consult the
-         * EGL specification available from The Khronos Group to learn how to call eglChooseConfig.
-         * @param egl the EGL10 for the current display.
-         * @param display the current display.
-         * @return the chosen configuration.
-         */
-        EGLConfig chooseConfig(EGL10 egl, EGLDisplay display);
-    }
-
-    private abstract class BaseConfigChooser
-            implements EGLConfigChooser {
-        public BaseConfigChooser(int[] configSpec) {
-            mConfigSpec = filterConfigSpec(configSpec);
-        }
-
-        public EGLConfig chooseConfig(EGL10 egl, EGLDisplay display) {
-            int[] num_config = new int[1];
-            if (!egl.eglChooseConfig(display, mConfigSpec, null, 0,
-                    num_config)) {
-                throw new IllegalArgumentException("eglChooseConfig failed");
-            }
-
-            int numConfigs = num_config[0];
-
-            if (numConfigs <= 0) {
-                throw new IllegalArgumentException(
-                        "No configs match configSpec");
-            }
-
-            EGLConfig[] configs = new EGLConfig[numConfigs];
-            if (!egl.eglChooseConfig(display, mConfigSpec, configs, numConfigs,
-                    num_config)) {
-                throw new IllegalArgumentException("eglChooseConfig#2 failed");
-            }
-            EGLConfig config = chooseConfig(egl, display, configs);
-            if (config == null) {
-                throw new IllegalArgumentException("No config chosen");
-            }
-            return config;
-        }
-
-        abstract EGLConfig chooseConfig(EGL10 egl, EGLDisplay display,
-                EGLConfig[] configs);
-
-        protected int[] mConfigSpec;
-
-        private int[] filterConfigSpec(int[] configSpec) {
-            if (mEGLContextClientVersion != 2 && mEGLContextClientVersion != 3) {
-                return configSpec;
-            }
-            /* We know none of the subclasses define EGL_RENDERABLE_TYPE.
-             * And we know the configSpec is well formed.
-             */
-            int len = configSpec.length;
-            int[] newConfigSpec = new int[len + 2];
-            System.arraycopy(configSpec, 0, newConfigSpec, 0, len-1);
-            newConfigSpec[len-1] = EGL10.EGL_RENDERABLE_TYPE;
-            if (mEGLContextClientVersion == 2) {
-                newConfigSpec[len] = EGL14.EGL_OPENGL_ES2_BIT;  /* EGL_OPENGL_ES2_BIT */
-            } else {
-                newConfigSpec[len] = EGLExt.EGL_OPENGL_ES3_BIT_KHR; /* EGL_OPENGL_ES3_BIT_KHR */
-            }
-            newConfigSpec[len+1] = EGL10.EGL_NONE;
-            return newConfigSpec;
-        }
-    }
-
-    /**
-     * Choose a configuration with exactly the specified r,g,b,a sizes,
-     * and at least the specified depth and stencil sizes.
-     */
-    private class ComponentSizeChooser extends BaseConfigChooser {
-        public ComponentSizeChooser(int redSize, int greenSize, int blueSize,
-                int alphaSize, int depthSize, int stencilSize) {
-            super(new int[] {
-                    EGL10.EGL_RED_SIZE, redSize,
-                    EGL10.EGL_GREEN_SIZE, greenSize,
-                    EGL10.EGL_BLUE_SIZE, blueSize,
-                    EGL10.EGL_ALPHA_SIZE, alphaSize,
-                    EGL10.EGL_DEPTH_SIZE, depthSize,
-                    EGL10.EGL_STENCIL_SIZE, stencilSize,
-                    EGL10.EGL_NONE});
-            mValue = new int[1];
-            mRedSize = redSize;
-            mGreenSize = greenSize;
-            mBlueSize = blueSize;
-            mAlphaSize = alphaSize;
-            mDepthSize = depthSize;
-            mStencilSize = stencilSize;
-       }
-
-        @Override
-        public EGLConfig chooseConfig(EGL10 egl, EGLDisplay display,
-                EGLConfig[] configs) {
-            for (EGLConfig config : configs) {
-                int d = findConfigAttrib(egl, display, config,
-                        EGL10.EGL_DEPTH_SIZE, 0);
-                int s = findConfigAttrib(egl, display, config,
-                        EGL10.EGL_STENCIL_SIZE, 0);
-                if ((d >= mDepthSize) && (s >= mStencilSize)) {
-                    int r = findConfigAttrib(egl, display, config,
-                            EGL10.EGL_RED_SIZE, 0);
-                    int g = findConfigAttrib(egl, display, config,
-                             EGL10.EGL_GREEN_SIZE, 0);
-                    int b = findConfigAttrib(egl, display, config,
-                              EGL10.EGL_BLUE_SIZE, 0);
-                    int a = findConfigAttrib(egl, display, config,
-                            EGL10.EGL_ALPHA_SIZE, 0);
-                    if ((r == mRedSize) && (g == mGreenSize)
-                            && (b == mBlueSize) && (a == mAlphaSize)) {
-                        return config;
-                    }
-                }
-            }
-            return null;
-        }
-
-        private int findConfigAttrib(EGL10 egl, EGLDisplay display,
-                EGLConfig config, int attribute, int defaultValue) {
-
-            if (egl.eglGetConfigAttrib(display, config, attribute, mValue)) {
-                return mValue[0];
-            }
-            return defaultValue;
-        }
-
-        private int[] mValue;
-        // Subclasses can adjust these values:
-        protected int mRedSize;
-        protected int mGreenSize;
-        protected int mBlueSize;
-        protected int mAlphaSize;
-        protected int mDepthSize;
-        protected int mStencilSize;
-        }
-
-    /**
-     * This class will choose a RGB_888 surface with
-     * or without a depth buffer.
-     *
-     */
-    private class SimpleEGLConfigChooser extends ComponentSizeChooser {
-        public SimpleEGLConfigChooser(boolean withDepthBuffer) {
-            super(8, 8, 8, 0, withDepthBuffer ? 16 : 0, 0);
-        }
-    }
-
-    /**
-     * An EGL helper class.
-     */
-
-    private static class EglHelper {
-        public EglHelper(WeakReference<GLSurfaceView> glSurfaceViewWeakRef) {
-            mGLSurfaceViewWeakRef = glSurfaceViewWeakRef;
-        }
-
-        /**
-         * Initialize EGL for a given configuration spec.
-         * @param configSpec
-         */
-        public void start() {
-            if (LOG_EGL) {
-                Log.w("EglHelper", "start() tid=" + Thread.currentThread().getId());
-            }
-            /*
-             * Get an EGL instance
-             */
-            mEgl = (EGL10) EGLContext.getEGL();
-
-            /*
-             * Get to the default display.
-             */
-            mEglDisplay = mEgl.eglGetDisplay(EGL10.EGL_DEFAULT_DISPLAY);
-
-            if (mEglDisplay == EGL10.EGL_NO_DISPLAY) {
-                throw new RuntimeException("eglGetDisplay failed");
-            }
-
-            /*
-             * We can now initialize EGL for that display
-             */
-            int[] version = new int[2];
-            if(!mEgl.eglInitialize(mEglDisplay, version)) {
-                throw new RuntimeException("eglInitialize failed");
-            }
-            GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-            if (view == null) {
-                mEglConfig = null;
-                mEglContext = null;
-            } else {
-                mEglConfig = view.mEGLConfigChooser.chooseConfig(mEgl, mEglDisplay);
-
-                /*
-                * Create an EGL context. We want to do this as rarely as we can, because an
-                * EGL context is a somewhat heavy object.
-                */
-                mEglContext = view.mEGLContextFactory.createContext(mEgl, mEglDisplay, mEglConfig);
-            }
-            if (mEglContext == null || mEglContext == EGL10.EGL_NO_CONTEXT) {
-                mEglContext = null;
-                throwEglException("createContext");
-            }
-            if (LOG_EGL) {
-                Log.w("EglHelper", "createContext " + mEglContext + " tid=" + Thread.currentThread().getId());
-            }
-
-            mEglSurface = null;
-        }
-
-        /**
-         * Create an egl surface for the current SurfaceHolder surface. If a surface
-         * already exists, destroy it before creating the new surface.
-         *
-         * @return true if the surface was created successfully.
-         */
-        public boolean createSurface() {
-            if (LOG_EGL) {
-                Log.w("EglHelper", "createSurface()  tid=" + Thread.currentThread().getId());
-            }
-            /*
-             * Check preconditions.
-             */
-            if (mEgl == null) {
-                throw new RuntimeException("egl not initialized");
-            }
-            if (mEglDisplay == null) {
-                throw new RuntimeException("eglDisplay not initialized");
-            }
-            if (mEglConfig == null) {
-                throw new RuntimeException("mEglConfig not initialized");
-            }
-
-            /*
-             *  The window size has changed, so we need to create a new
-             *  surface.
-             */
-            destroySurfaceImp();
-
-            /*
-             * Create an EGL surface we can render into.
-             */
-            GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-            if (view != null) {
-                mEglSurface = view.mEGLWindowSurfaceFactory.createWindowSurface(mEgl,
-                        mEglDisplay, mEglConfig, view.getHolder());
-            } else {
-                mEglSurface = null;
-            }
-
-            if (mEglSurface == null || mEglSurface == EGL10.EGL_NO_SURFACE) {
-                int error = mEgl.eglGetError();
-                if (error == EGL10.EGL_BAD_NATIVE_WINDOW) {
-                    Log.e("EglHelper", "createWindowSurface returned EGL_BAD_NATIVE_WINDOW.");
-                }
-                return false;
-            }
-
-            /*
-             * Before we can issue GL commands, we need to make sure
-             * the context is current and bound to a surface.
-             */
-            if (!mEgl.eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface, mEglContext)) {
-                /*
-                 * Could not make the context current, probably because the underlying
-                 * SurfaceView surface has been destroyed.
-                 */
-                logEglErrorAsWarning("EGLHelper", "eglMakeCurrent", mEgl.eglGetError());
-                return false;
-            }
-
-            return true;
-        }
-
-        /**
-         * Create a GL object for the current EGL context.
-         * @return
-         */
-        GL createGL() {
-
-            GL gl = mEglContext.getGL();
-            GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-            if (view != null) {
-                if (view.mGLWrapper != null) {
-                    gl = view.mGLWrapper.wrap(gl);
-                }
-
-                if ((view.mDebugFlags & (DEBUG_CHECK_GL_ERROR | DEBUG_LOG_GL_CALLS)) != 0) {
-                    int configFlags = 0;
-                    Writer log = null;
-                    if ((view.mDebugFlags & DEBUG_CHECK_GL_ERROR) != 0) {
-                        configFlags |= GLDebugHelper.CONFIG_CHECK_GL_ERROR;
-                    }
-                    if ((view.mDebugFlags & DEBUG_LOG_GL_CALLS) != 0) {
-                        log = new LogWriter();
-                    }
-                    gl = GLDebugHelper.wrap(gl, configFlags, log);
-                }
-            }
-            return gl;
-        }
-
-        /**
-         * Display the current render surface.
-         * @return the EGL error code from eglSwapBuffers.
-         */
-        public int swap() {
-            if (! mEgl.eglSwapBuffers(mEglDisplay, mEglSurface)) {
-                return mEgl.eglGetError();
-            }
-            return EGL10.EGL_SUCCESS;
-        }
-
-        public void destroySurface() {
-            if (LOG_EGL) {
-                Log.w("EglHelper", "destroySurface()  tid=" + Thread.currentThread().getId());
-            }
-            destroySurfaceImp();
-        }
-
-        private void destroySurfaceImp() {
-            if (mEglSurface != null && mEglSurface != EGL10.EGL_NO_SURFACE) {
-                mEgl.eglMakeCurrent(mEglDisplay, EGL10.EGL_NO_SURFACE,
-                        EGL10.EGL_NO_SURFACE,
-                        EGL10.EGL_NO_CONTEXT);
-                GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-                if (view != null) {
-                    view.mEGLWindowSurfaceFactory.destroySurface(mEgl, mEglDisplay, mEglSurface);
-                }
-                mEglSurface = null;
-            }
-        }
-
-        public void finish() {
-            if (LOG_EGL) {
-                Log.w("EglHelper", "finish() tid=" + Thread.currentThread().getId());
-            }
-            if (mEglContext != null) {
-                GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-                if (view != null) {
-                    view.mEGLContextFactory.destroyContext(mEgl, mEglDisplay, mEglContext);
-                }
-                mEglContext = null;
-            }
-            if (mEglDisplay != null) {
-                mEgl.eglTerminate(mEglDisplay);
-                mEglDisplay = null;
-            }
-        }
-
-        private void throwEglException(String function) {
-            throwEglException(function, mEgl.eglGetError());
-        }
-
-        public static void throwEglException(String function, int error) {
-            String message = formatEglError(function, error);
-            if (LOG_THREADS) {
-                Log.e("EglHelper", "throwEglException tid=" + Thread.currentThread().getId() + " "
-                        + message);
-            }
-            throw new RuntimeException(message);
-        }
-
-        public static void logEglErrorAsWarning(String tag, String function, int error) {
-            Log.w(tag, formatEglError(function, error));
-        }
-
-        public static String formatEglError(String function, int error) {
-            return function + " failed: " + EGLLogWrapper.getErrorString(error);
-        }
-
-        private WeakReference<GLSurfaceView> mGLSurfaceViewWeakRef;
-        EGL10 mEgl;
-        EGLDisplay mEglDisplay;
-        EGLSurface mEglSurface;
-        EGLConfig mEglConfig;
-        EGLContext mEglContext;
-
-    }
-
-    /**
-     * A generic GL Thread. Takes care of initializing EGL and GL. Delegates
-     * to a Renderer instance to do the actual drawing. Can be configured to
-     * render continuously or on request.
-     *
-     * All potentially blocking synchronization is done through the
-     * sGLThreadManager object. This avoids multiple-lock ordering issues.
-     *
-     */
-    static class GLThread extends Thread {
-        GLThread(WeakReference<GLSurfaceView> glSurfaceViewWeakRef) {
-            super();
-            mWidth = 0;
-            mHeight = 0;
-            mRequestRender = true;
-            mRenderMode = RENDERMODE_CONTINUOUSLY;
-            mWantRenderNotification = false;
-            mGLSurfaceViewWeakRef = glSurfaceViewWeakRef;
-        }
-
-        @Override
-        public void run() {
-            setName("GLThread " + getId());
-            if (LOG_THREADS) {
-                Log.i("GLThread", "starting tid=" + getId());
-            }
-
-            try {
-                guardedRun();
-            } catch (InterruptedException e) {
-                // fall thru and exit normally
-            } finally {
-                sGLThreadManager.threadExiting(this);
-            }
-        }
-
-        /*
-         * This private method should only be called inside a
-         * synchronized(sGLThreadManager) block.
-         */
-        private void stopEglSurfaceLocked() {
-            if (mHaveEglSurface) {
-                mHaveEglSurface = false;
-                mEglHelper.destroySurface();
-            }
-        }
-
-        /*
-         * This private method should only be called inside a
-         * synchronized(sGLThreadManager) block.
-         */
-        private void stopEglContextLocked() {
-            if (mHaveEglContext) {
-                mEglHelper.finish();
-                mHaveEglContext = false;
-                sGLThreadManager.releaseEglContextLocked(this);
-            }
-        }
-        private void guardedRun() throws InterruptedException {
-            mEglHelper = new EglHelper(mGLSurfaceViewWeakRef);
-            mHaveEglContext = false;
-            mHaveEglSurface = false;
-            mWantRenderNotification = false;
-
-            try {
-                GL10 gl = null;
-                boolean createEglContext = false;
-                boolean createEglSurface = false;
-                boolean createGlInterface = false;
-                boolean lostEglContext = false;
-                boolean sizeChanged = false;
-                boolean wantRenderNotification = false;
-                boolean doRenderNotification = false;
-                boolean askedToReleaseEglContext = false;
-                int w = 0;
-                int h = 0;
-                Runnable event = null;
-
-                while (true) {
-                    synchronized (sGLThreadManager) {
-                        while (true) {
-                            if (mShouldExit) {
-                                return;
-                            }
-
-                            if (! mEventQueue.isEmpty()) {
-                                event = mEventQueue.remove(0);
-                                break;
-                            }
-
-                            // Update the pause state.
-                            boolean pausing = false;
-                            if (mPaused != mRequestPaused) {
-                                pausing = mRequestPaused;
-                                mPaused = mRequestPaused;
-                                sGLThreadManager.notifyAll();
-                                if (LOG_PAUSE_RESUME) {
-                                    Log.i("GLThread", "mPaused is now " + mPaused + " tid=" + getId());
-                                }
-                            }
-
-                            // Do we need to give up the EGL context?
-                            if (mShouldReleaseEglContext) {
-                                if (LOG_SURFACE) {
-                                    Log.i("GLThread", "releasing EGL context because asked to tid=" + getId());
-                                }
-                                stopEglSurfaceLocked();
-                                stopEglContextLocked();
-                                mShouldReleaseEglContext = false;
-                                askedToReleaseEglContext = true;
-                            }
-
-                            // Have we lost the EGL context?
-                            if (lostEglContext) {
-                                stopEglSurfaceLocked();
-                                stopEglContextLocked();
-                                lostEglContext = false;
-                            }
-
-                            // When pausing, release the EGL surface:
-                            if (pausing && mHaveEglSurface) {
-                                if (LOG_SURFACE) {
-                                    Log.i("GLThread", "releasing EGL surface because paused tid=" + getId());
-                                }
-                                stopEglSurfaceLocked();
-                            }
-
-                            // When pausing, optionally release the EGL Context:
-                            if (pausing && mHaveEglContext) {
-                                GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-                                boolean preserveEglContextOnPause = view == null ?
-                                        false : view.mPreserveEGLContextOnPause;
-                                if (!preserveEglContextOnPause) {
-                                    stopEglContextLocked();
-                                    if (LOG_SURFACE) {
-                                        Log.i("GLThread", "releasing EGL context because paused tid=" + getId());
-                                    }
-                                }
-                            }
-
-                            // Have we lost the SurfaceView surface?
-                            if ((! mHasSurface) && (! mWaitingForSurface)) {
-                                if (LOG_SURFACE) {
-                                    Log.i("GLThread", "noticed surfaceView surface lost tid=" + getId());
-                                }
-                                if (mHaveEglSurface) {
-                                    stopEglSurfaceLocked();
-                                }
-                                mWaitingForSurface = true;
-                                mSurfaceIsBad = false;
-                                sGLThreadManager.notifyAll();
-                            }
-
-                            // Have we acquired the surface view surface?
-                            if (mHasSurface && mWaitingForSurface) {
-                                if (LOG_SURFACE) {
-                                    Log.i("GLThread", "noticed surfaceView surface acquired tid=" + getId());
-                                }
-                                mWaitingForSurface = false;
-                                sGLThreadManager.notifyAll();
-                            }
-
-                            if (doRenderNotification) {
-                                if (LOG_SURFACE) {
-                                    Log.i("GLThread", "sending render notification tid=" + getId());
-                                }
-                                mWantRenderNotification = false;
-                                doRenderNotification = false;
-                                mRenderComplete = true;
-                                sGLThreadManager.notifyAll();
-                            }
-
-                            // Ready to draw?
-                            if (readyToDraw()) {
-
-                                // If we don't have an EGL context, try to acquire one.
-                                if (! mHaveEglContext) {
-                                    if (askedToReleaseEglContext) {
-                                        askedToReleaseEglContext = false;
-                                    } else {
-                                        try {
-                                            mEglHelper.start();
-                                        } catch (RuntimeException t) {
-                                            sGLThreadManager.releaseEglContextLocked(this);
-                                            throw t;
-                                        }
-                                        mHaveEglContext = true;
-                                        createEglContext = true;
-
-                                        sGLThreadManager.notifyAll();
-                                    }
-                                }
-
-                                if (mHaveEglContext && !mHaveEglSurface) {
-                                    mHaveEglSurface = true;
-                                    createEglSurface = true;
-                                    createGlInterface = true;
-                                    sizeChanged = true;
-                                }
-
-                                if (mHaveEglSurface) {
-                                    if (mSizeChanged) {
-                                        sizeChanged = true;
-                                        w = mWidth;
-                                        h = mHeight;
-                                        mWantRenderNotification = true;
-                                        if (LOG_SURFACE) {
-                                            Log.i("GLThread",
-                                                    "noticing that we want render notification tid="
-                                                    + getId());
-                                        }
-
-                                        // Destroy and recreate the EGL surface.
-                                        createEglSurface = true;
-
-                                        mSizeChanged = false;
-                                    }
-                                    mRequestRender = false;
-                                    sGLThreadManager.notifyAll();
-                                    if (mWantRenderNotification) {
-                                        wantRenderNotification = true;
-                                    }
-                                    break;
-                                }
-                            }
-
-                            // By design, this is the only place in a GLThread thread where we wait().
-                            if (LOG_THREADS) {
-                                Log.i("GLThread", "waiting tid=" + getId()
-                                    + " mHaveEglContext: " + mHaveEglContext
-                                    + " mHaveEglSurface: " + mHaveEglSurface
-                                    + " mFinishedCreatingEglSurface: " + mFinishedCreatingEglSurface
-                                    + " mPaused: " + mPaused
-                                    + " mHasSurface: " + mHasSurface
-                                    + " mSurfaceIsBad: " + mSurfaceIsBad
-                                    + " mWaitingForSurface: " + mWaitingForSurface
-                                    + " mWidth: " + mWidth
-                                    + " mHeight: " + mHeight
-                                    + " mRequestRender: " + mRequestRender
-                                    + " mRenderMode: " + mRenderMode);
-                            }
-                            sGLThreadManager.wait();
-                        }
-                    } // end of synchronized(sGLThreadManager)
-
-                    if (event != null) {
-                        event.run();
-                        event = null;
-                        continue;
-                    }
-
-                    if (createEglSurface) {
-                        if (LOG_SURFACE) {
-                            Log.w("GLThread", "egl createSurface");
-                        }
-                        if (mEglHelper.createSurface()) {
-                            synchronized(sGLThreadManager) {
-                                mFinishedCreatingEglSurface = true;
-                                sGLThreadManager.notifyAll();
-                            }
-                        } else {
-                            synchronized(sGLThreadManager) {
-                                mFinishedCreatingEglSurface = true;
-                                mSurfaceIsBad = true;
-                                sGLThreadManager.notifyAll();
-                            }
-                            continue;
-                        }
-                        createEglSurface = false;
-                    }
-
-                    if (createGlInterface) {
-                        gl = (GL10) mEglHelper.createGL();
-
-                        createGlInterface = false;
-                    }
-
-                    if (createEglContext) {
-                        if (LOG_RENDERER) {
-                            Log.w("GLThread", "onSurfaceCreated");
-                        }
-                        GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-                        if (view != null) {
-                            try {
-                                Trace.traceBegin(Trace.TRACE_TAG_VIEW, "onSurfaceCreated");
-                                view.mRenderer.onSurfaceCreated(gl, mEglHelper.mEglConfig);
-                            } finally {
-                                Trace.traceEnd(Trace.TRACE_TAG_VIEW);
-                            }
-                        }
-                        createEglContext = false;
-                    }
-
-                    if (sizeChanged) {
-                        if (LOG_RENDERER) {
-                            Log.w("GLThread", "onSurfaceChanged(" + w + ", " + h + ")");
-                        }
-                        GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-                        if (view != null) {
-                            try {
-                                Trace.traceBegin(Trace.TRACE_TAG_VIEW, "onSurfaceChanged");
-                                view.mRenderer.onSurfaceChanged(gl, w, h);
-                            } finally {
-                                Trace.traceEnd(Trace.TRACE_TAG_VIEW);
-                            }
-                        }
-                        sizeChanged = false;
-                    }
-
-                    if (LOG_RENDERER_DRAW_FRAME) {
-                        Log.w("GLThread", "onDrawFrame tid=" + getId());
-                    }
-                    {
-                        GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-                        if (view != null) {
-                            try {
-                                Trace.traceBegin(Trace.TRACE_TAG_VIEW, "onDrawFrame");
-                                view.mRenderer.onDrawFrame(gl);
-                            } finally {
-                                Trace.traceEnd(Trace.TRACE_TAG_VIEW);
-                            }
-                        }
-                    }
-                    int swapError = mEglHelper.swap();
-                    switch (swapError) {
-                        case EGL10.EGL_SUCCESS:
-                            break;
-                        case EGL11.EGL_CONTEXT_LOST:
-                            if (LOG_SURFACE) {
-                                Log.i("GLThread", "egl context lost tid=" + getId());
-                            }
-                            lostEglContext = true;
-                            break;
-                        default:
-                            // Other errors typically mean that the current surface is bad,
-                            // probably because the SurfaceView surface has been destroyed,
-                            // but we haven't been notified yet.
-                            // Log the error to help developers understand why rendering stopped.
-                            EglHelper.logEglErrorAsWarning("GLThread", "eglSwapBuffers", swapError);
-
-                            synchronized(sGLThreadManager) {
-                                mSurfaceIsBad = true;
-                                sGLThreadManager.notifyAll();
-                            }
-                            break;
-                    }
-
-                    if (wantRenderNotification) {
-                        doRenderNotification = true;
-                        wantRenderNotification = false;
-                    }
-                }
-
-            } finally {
-                /*
-                 * clean-up everything...
-                 */
-                synchronized (sGLThreadManager) {
-                    stopEglSurfaceLocked();
-                    stopEglContextLocked();
-                }
-            }
-        }
-
-        public boolean ableToDraw() {
-            return mHaveEglContext && mHaveEglSurface && readyToDraw();
-        }
-
-        private boolean readyToDraw() {
-            return (!mPaused) && mHasSurface && (!mSurfaceIsBad)
-                && (mWidth > 0) && (mHeight > 0)
-                && (mRequestRender || (mRenderMode == RENDERMODE_CONTINUOUSLY));
-        }
-
-        public void setRenderMode(int renderMode) {
-            if ( !((RENDERMODE_WHEN_DIRTY <= renderMode) && (renderMode <= RENDERMODE_CONTINUOUSLY)) ) {
-                throw new IllegalArgumentException("renderMode");
-            }
-            synchronized(sGLThreadManager) {
-                mRenderMode = renderMode;
-                sGLThreadManager.notifyAll();
-            }
-        }
-
-        public int getRenderMode() {
-            synchronized(sGLThreadManager) {
-                return mRenderMode;
-            }
-        }
-
-        public void requestRender() {
-            synchronized(sGLThreadManager) {
-                mRequestRender = true;
-                sGLThreadManager.notifyAll();
-            }
-        }
-
-        public void requestRenderAndWait() {
-            synchronized(sGLThreadManager) {
-                // If we are already on the GL thread, this means a client callback
-                // has caused reentrancy, for example via updating the SurfaceView parameters.
-                // We will return to the client rendering code, so here we don't need to
-                // do anything.
-                if (Thread.currentThread() == this) {
-                    return;
-                }
-
-                mWantRenderNotification = true;
-                mRequestRender = true;
-                mRenderComplete = false;
-
-                sGLThreadManager.notifyAll();
-
-                while (!mExited && !mPaused && !mRenderComplete && ableToDraw()) {
-                    try {
-                        sGLThreadManager.wait();
-                    } catch (InterruptedException ex) {
-                        Thread.currentThread().interrupt();
-                    }
-                }
-
-            }
-        }
-
-        public void surfaceCreated() {
-            synchronized(sGLThreadManager) {
-                if (LOG_THREADS) {
-                    Log.i("GLThread", "surfaceCreated tid=" + getId());
-                }
-                mHasSurface = true;
-                mFinishedCreatingEglSurface = false;
-                sGLThreadManager.notifyAll();
-                while (mWaitingForSurface
-                       && !mFinishedCreatingEglSurface
-                       && !mExited) {
-                    try {
-                        sGLThreadManager.wait();
-                    } catch (InterruptedException e) {
-                        Thread.currentThread().interrupt();
-                    }
-                }
-            }
-        }
-
-        public void surfaceDestroyed() {
-            synchronized(sGLThreadManager) {
-                if (LOG_THREADS) {
-                    Log.i("GLThread", "surfaceDestroyed tid=" + getId());
-                }
-                mHasSurface = false;
-                sGLThreadManager.notifyAll();
-                while((!mWaitingForSurface) && (!mExited)) {
-                    try {
-                        sGLThreadManager.wait();
-                    } catch (InterruptedException e) {
-                        Thread.currentThread().interrupt();
-                    }
-                }
-            }
-        }
-
-        public void onPause() {
-            synchronized (sGLThreadManager) {
-                if (LOG_PAUSE_RESUME) {
-                    Log.i("GLThread", "onPause tid=" + getId());
-                }
-                mRequestPaused = true;
-                sGLThreadManager.notifyAll();
-                while ((! mExited) && (! mPaused)) {
-                    if (LOG_PAUSE_RESUME) {
-                        Log.i("Main thread", "onPause waiting for mPaused.");
-                    }
-                    try {
-                        sGLThreadManager.wait();
-                    } catch (InterruptedException ex) {
-                        Thread.currentThread().interrupt();
-                    }
-                }
-            }
-        }
-
-        public void onResume() {
-            synchronized (sGLThreadManager) {
-                if (LOG_PAUSE_RESUME) {
-                    Log.i("GLThread", "onResume tid=" + getId());
-                }
-                mRequestPaused = false;
-                mRequestRender = true;
-                mRenderComplete = false;
-                sGLThreadManager.notifyAll();
-                while ((! mExited) && mPaused && (!mRenderComplete)) {
-                    if (LOG_PAUSE_RESUME) {
-                        Log.i("Main thread", "onResume waiting for !mPaused.");
-                    }
-                    try {
-                        sGLThreadManager.wait();
-                    } catch (InterruptedException ex) {
-                        Thread.currentThread().interrupt();
-                    }
-                }
-            }
-        }
-
-        public void onWindowResize(int w, int h) {
-            synchronized (sGLThreadManager) {
-                mWidth = w;
-                mHeight = h;
-                mSizeChanged = true;
-                mRequestRender = true;
-                mRenderComplete = false;
-
-                // If we are already on the GL thread, this means a client callback
-                // has caused reentrancy, for example via updating the SurfaceView parameters.
-                // We need to process the size change eventually though and update our EGLSurface.
-                // So we set the parameters and return so they can be processed on our
-                // next iteration.
-                if (Thread.currentThread() == this) {
-                    return;
-                }
-
-                sGLThreadManager.notifyAll();
-
-                // Wait for thread to react to resize and render a frame
-                while (! mExited && !mPaused && !mRenderComplete
-                        && ableToDraw()) {
-                    if (LOG_SURFACE) {
-                        Log.i("Main thread", "onWindowResize waiting for render complete from tid=" + getId());
-                    }
-                    try {
-                        sGLThreadManager.wait();
-                    } catch (InterruptedException ex) {
-                        Thread.currentThread().interrupt();
-                    }
-                }
-            }
-        }
-
-        public void requestExitAndWait() {
-            // don't call this from GLThread thread or it is a guaranteed
-            // deadlock!
-            synchronized(sGLThreadManager) {
-                mShouldExit = true;
-                sGLThreadManager.notifyAll();
-                while (! mExited) {
-                    try {
-                        sGLThreadManager.wait();
-                    } catch (InterruptedException ex) {
-                        Thread.currentThread().interrupt();
-                    }
-                }
-            }
-        }
-
-        public void requestReleaseEglContextLocked() {
-            mShouldReleaseEglContext = true;
-            sGLThreadManager.notifyAll();
-        }
-
-        /**
-         * Queue an "event" to be run on the GL rendering thread.
-         * @param r the runnable to be run on the GL rendering thread.
-         */
-        public void queueEvent(Runnable r) {
-            if (r == null) {
-                throw new IllegalArgumentException("r must not be null");
-            }
-            synchronized(sGLThreadManager) {
-                mEventQueue.add(r);
-                sGLThreadManager.notifyAll();
-            }
-        }
-
-        // Once the thread is started, all accesses to the following member
-        // variables are protected by the sGLThreadManager monitor
-        private boolean mShouldExit;
-        private boolean mExited;
-        private boolean mRequestPaused;
-        private boolean mPaused;
-        private boolean mHasSurface;
-        private boolean mSurfaceIsBad;
-        private boolean mWaitingForSurface;
-        private boolean mHaveEglContext;
-        private boolean mHaveEglSurface;
-        private boolean mFinishedCreatingEglSurface;
-        private boolean mShouldReleaseEglContext;
-        private int mWidth;
-        private int mHeight;
-        private int mRenderMode;
-        private boolean mRequestRender;
-        private boolean mWantRenderNotification;
-        private boolean mRenderComplete;
-        private ArrayList<Runnable> mEventQueue = new ArrayList<Runnable>();
-        private boolean mSizeChanged = true;
-
-        // End of member variables protected by the sGLThreadManager monitor.
-
-        private EglHelper mEglHelper;
-
-        /**
-         * Set once at thread construction time, nulled out when the parent view is garbage
-         * called. This weak reference allows the GLSurfaceView to be garbage collected while
-         * the GLThread is still alive.
-         */
-        private WeakReference<GLSurfaceView> mGLSurfaceViewWeakRef;
-
-    }
-
-    static class LogWriter extends Writer {
-
-        @Override public void close() {
-            flushBuilder();
-        }
-
-        @Override public void flush() {
-            flushBuilder();
-        }
-
-        @Override public void write(char[] buf, int offset, int count) {
-            for(int i = 0; i < count; i++) {
-                char c = buf[offset + i];
-                if ( c == '\n') {
-                    flushBuilder();
-                }
-                else {
-                    mBuilder.append(c);
-                }
-            }
-        }
-
-        private void flushBuilder() {
-            if (mBuilder.length() > 0) {
-                Log.v("GLSurfaceView", mBuilder.toString());
-                mBuilder.delete(0, mBuilder.length());
-            }
-        }
-
-        private StringBuilder mBuilder = new StringBuilder();
-    }
-
-
-    private void checkRenderThreadState() {
-        if (mGLThread != null) {
-            throw new IllegalStateException(
-                    "setRenderer has already been called for this instance.");
-        }
-    }
-
-    private static class GLThreadManager {
-        private static String TAG = "GLThreadManager";
-
-        public synchronized void threadExiting(GLThread thread) {
-            if (LOG_THREADS) {
-                Log.i("GLThread", "exiting tid=" +  thread.getId());
-            }
-            thread.mExited = true;
-            notifyAll();
-        }
-
-        /*
-         * Releases the EGL context. Requires that we are already in the
-         * sGLThreadManager monitor when this is called.
-         */
-        public void releaseEglContextLocked(GLThread thread) {
-            notifyAll();
-        }
-    }
-
-    private static final GLThreadManager sGLThreadManager = new GLThreadManager();
-
-    private final WeakReference<GLSurfaceView> mThisWeakRef =
-            new WeakReference<GLSurfaceView>(this);
-    private GLThread mGLThread;
-    private Renderer mRenderer;
-    private boolean mDetached;
-    private EGLConfigChooser mEGLConfigChooser;
-    private EGLContextFactory mEGLContextFactory;
-    private EGLWindowSurfaceFactory mEGLWindowSurfaceFactory;
-    private GLWrapper mGLWrapper;
-    private int mDebugFlags;
-    private int mEGLContextClientVersion;
-    private boolean mPreserveEGLContextOnPause;
-}
diff -Naur frameworksRaw/base/opengl/java/android/opengl/GLSurfaceView.java.orig.orig.orig frameworksModified/base/opengl/java/android/opengl/GLSurfaceView.java.orig.orig.orig
--- frameworksRaw/base/opengl/java/android/opengl/GLSurfaceView.java.orig.orig.orig	2017-07-06 15:34:16.022010952 +0530
+++ frameworksModified/base/opengl/java/android/opengl/GLSurfaceView.java.orig.orig.orig	1970-01-01 05:30:00.000000000 +0530
@@ -1,1912 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.opengl;
-
-import android.content.Context;
-import android.os.Trace;
-import android.util.AttributeSet;
-import android.util.Log;
-import android.view.SurfaceHolder;
-import android.view.SurfaceView;
-
-import java.io.Writer;
-import java.lang.ref.WeakReference;
-import java.util.ArrayList;
-
-import javax.microedition.khronos.egl.EGL10;
-import javax.microedition.khronos.egl.EGL11;
-import javax.microedition.khronos.egl.EGLConfig;
-import javax.microedition.khronos.egl.EGLContext;
-import javax.microedition.khronos.egl.EGLDisplay;
-import javax.microedition.khronos.egl.EGLSurface;
-import javax.microedition.khronos.opengles.GL;
-import javax.microedition.khronos.opengles.GL10;
-
-/**
- * An implementation of SurfaceView that uses the dedicated surface for
- * displaying OpenGL rendering.
- * <p>
- * A GLSurfaceView provides the following features:
- * <p>
- * <ul>
- * <li>Manages a surface, which is a special piece of memory that can be
- * composited into the Android view system.
- * <li>Manages an EGL display, which enables OpenGL to render into a surface.
- * <li>Accepts a user-provided Renderer object that does the actual rendering.
- * <li>Renders on a dedicated thread to decouple rendering performance from the
- * UI thread.
- * <li>Supports both on-demand and continuous rendering.
- * <li>Optionally wraps, traces, and/or error-checks the renderer's OpenGL calls.
- * </ul>
- *
- * <div class="special reference">
- * <h3>Developer Guides</h3>
- * <p>For more information about how to use OpenGL, read the
- * <a href="{@docRoot}guide/topics/graphics/opengl.html">OpenGL</a> developer guide.</p>
- * </div>
- *
- * <h3>Using GLSurfaceView</h3>
- * <p>
- * Typically you use GLSurfaceView by subclassing it and overriding one or more of the
- * View system input event methods. If your application does not need to override event
- * methods then GLSurfaceView can be used as-is. For the most part
- * GLSurfaceView behavior is customized by calling "set" methods rather than by subclassing.
- * For example, unlike a regular View, drawing is delegated to a separate Renderer object which
- * is registered with the GLSurfaceView
- * using the {@link #setRenderer(Renderer)} call.
- * <p>
- * <h3>Initializing GLSurfaceView</h3>
- * All you have to do to initialize a GLSurfaceView is call {@link #setRenderer(Renderer)}.
- * However, if desired, you can modify the default behavior of GLSurfaceView by calling one or
- * more of these methods before calling setRenderer:
- * <ul>
- * <li>{@link #setDebugFlags(int)}
- * <li>{@link #setEGLConfigChooser(boolean)}
- * <li>{@link #setEGLConfigChooser(EGLConfigChooser)}
- * <li>{@link #setEGLConfigChooser(int, int, int, int, int, int)}
- * <li>{@link #setGLWrapper(GLWrapper)}
- * </ul>
- * <p>
- * <h4>Specifying the android.view.Surface</h4>
- * By default GLSurfaceView will create a PixelFormat.RGB_888 format surface. If a translucent
- * surface is required, call getHolder().setFormat(PixelFormat.TRANSLUCENT).
- * The exact format of a TRANSLUCENT surface is device dependent, but it will be
- * a 32-bit-per-pixel surface with 8 bits per component.
- * <p>
- * <h4>Choosing an EGL Configuration</h4>
- * A given Android device may support multiple EGLConfig rendering configurations.
- * The available configurations may differ in how may channels of data are present, as
- * well as how many bits are allocated to each channel. Therefore, the first thing
- * GLSurfaceView has to do when starting to render is choose what EGLConfig to use.
- * <p>
- * By default GLSurfaceView chooses a EGLConfig that has an RGB_888 pixel format,
- * with at least a 16-bit depth buffer and no stencil.
- * <p>
- * If you would prefer a different EGLConfig
- * you can override the default behavior by calling one of the
- * setEGLConfigChooser methods.
- * <p>
- * <h4>Debug Behavior</h4>
- * You can optionally modify the behavior of GLSurfaceView by calling
- * one or more of the debugging methods {@link #setDebugFlags(int)},
- * and {@link #setGLWrapper}. These methods may be called before and/or after setRenderer, but
- * typically they are called before setRenderer so that they take effect immediately.
- * <p>
- * <h4>Setting a Renderer</h4>
- * Finally, you must call {@link #setRenderer} to register a {@link Renderer}.
- * The renderer is
- * responsible for doing the actual OpenGL rendering.
- * <p>
- * <h3>Rendering Mode</h3>
- * Once the renderer is set, you can control whether the renderer draws
- * continuously or on-demand by calling
- * {@link #setRenderMode}. The default is continuous rendering.
- * <p>
- * <h3>Activity Life-cycle</h3>
- * A GLSurfaceView must be notified when to pause and resume rendering. GLSurfaceView clients
- * are required to call {@link #onPause()} when the activity stops and
- * {@link #onResume()} when the activity starts. These calls allow GLSurfaceView to
- * pause and resume the rendering thread, and also allow GLSurfaceView to release and recreate
- * the OpenGL display.
- * <p>
- * <h3>Handling events</h3>
- * <p>
- * To handle an event you will typically subclass GLSurfaceView and override the
- * appropriate method, just as you would with any other View. However, when handling
- * the event, you may need to communicate with the Renderer object
- * that's running in the rendering thread. You can do this using any
- * standard Java cross-thread communication mechanism. In addition,
- * one relatively easy way to communicate with your renderer is
- * to call
- * {@link #queueEvent(Runnable)}. For example:
- * <pre class="prettyprint">
- * class MyGLSurfaceView extends GLSurfaceView {
- *
- *     private MyRenderer mMyRenderer;
- *
- *     public void start() {
- *         mMyRenderer = ...;
- *         setRenderer(mMyRenderer);
- *     }
- *
- *     public boolean onKeyDown(int keyCode, KeyEvent event) {
- *         if (keyCode == KeyEvent.KEYCODE_DPAD_CENTER) {
- *             queueEvent(new Runnable() {
- *                 // This method will be called on the rendering
- *                 // thread:
- *                 public void run() {
- *                     mMyRenderer.handleDpadCenter();
- *                 }});
- *             return true;
- *         }
- *         return super.onKeyDown(keyCode, event);
- *     }
- * }
- * </pre>
- *
- */
-public class GLSurfaceView extends SurfaceView implements SurfaceHolder.Callback2 {
-    private final static String TAG = "GLSurfaceView";
-    private final static boolean LOG_ATTACH_DETACH = false;
-    private final static boolean LOG_THREADS = false;
-    private final static boolean LOG_PAUSE_RESUME = false;
-    private final static boolean LOG_SURFACE = false;
-    private final static boolean LOG_RENDERER = false;
-    private final static boolean LOG_RENDERER_DRAW_FRAME = false;
-    private final static boolean LOG_EGL = false;
-    /**
-     * The renderer only renders
-     * when the surface is created, or when {@link #requestRender} is called.
-     *
-     * @see #getRenderMode()
-     * @see #setRenderMode(int)
-     * @see #requestRender()
-     */
-    public final static int RENDERMODE_WHEN_DIRTY = 0;
-    /**
-     * The renderer is called
-     * continuously to re-render the scene.
-     *
-     * @see #getRenderMode()
-     * @see #setRenderMode(int)
-     */
-    public final static int RENDERMODE_CONTINUOUSLY = 1;
-
-    /**
-     * Check glError() after every GL call and throw an exception if glError indicates
-     * that an error has occurred. This can be used to help track down which OpenGL ES call
-     * is causing an error.
-     *
-     * @see #getDebugFlags
-     * @see #setDebugFlags
-     */
-    public final static int DEBUG_CHECK_GL_ERROR = 1;
-
-    /**
-     * Log GL calls to the system log at "verbose" level with tag "GLSurfaceView".
-     *
-     * @see #getDebugFlags
-     * @see #setDebugFlags
-     */
-    public final static int DEBUG_LOG_GL_CALLS = 2;
-
-    /**
-     * Standard View constructor. In order to render something, you
-     * must call {@link #setRenderer} to register a renderer.
-     */
-    public GLSurfaceView(Context context) {
-        super(context);
-        init();
-    }
-
-    /**
-     * Standard View constructor. In order to render something, you
-     * must call {@link #setRenderer} to register a renderer.
-     */
-    public GLSurfaceView(Context context, AttributeSet attrs) {
-        super(context, attrs);
-        init();
-    }
-
-    @Override
-    protected void finalize() throws Throwable {
-        try {
-            if (mGLThread != null) {
-                // GLThread may still be running if this view was never
-                // attached to a window.
-                mGLThread.requestExitAndWait();
-            }
-        } finally {
-            super.finalize();
-        }
-    }
-
-    private void init() {
-        // Install a SurfaceHolder.Callback so we get notified when the
-        // underlying surface is created and destroyed
-        SurfaceHolder holder = getHolder();
-        holder.addCallback(this);
-        // setFormat is done by SurfaceView in SDK 2.3 and newer. Uncomment
-        // this statement if back-porting to 2.2 or older:
-        // holder.setFormat(PixelFormat.RGB_565);
-        //
-        // setType is not needed for SDK 2.0 or newer. Uncomment this
-        // statement if back-porting this code to older SDKs.
-        // holder.setType(SurfaceHolder.SURFACE_TYPE_GPU);
-    }
-
-    /**
-     * Set the glWrapper. If the glWrapper is not null, its
-     * {@link GLWrapper#wrap(GL)} method is called
-     * whenever a surface is created. A GLWrapper can be used to wrap
-     * the GL object that's passed to the renderer. Wrapping a GL
-     * object enables examining and modifying the behavior of the
-     * GL calls made by the renderer.
-     * <p>
-     * Wrapping is typically used for debugging purposes.
-     * <p>
-     * The default value is null.
-     * @param glWrapper the new GLWrapper
-     */
-    public void setGLWrapper(GLWrapper glWrapper) {
-        mGLWrapper = glWrapper;
-    }
-
-    /**
-     * Set the debug flags to a new value. The value is
-     * constructed by OR-together zero or more
-     * of the DEBUG_CHECK_* constants. The debug flags take effect
-     * whenever a surface is created. The default value is zero.
-     * @param debugFlags the new debug flags
-     * @see #DEBUG_CHECK_GL_ERROR
-     * @see #DEBUG_LOG_GL_CALLS
-     */
-    public void setDebugFlags(int debugFlags) {
-        mDebugFlags = debugFlags;
-    }
-
-    /**
-     * Get the current value of the debug flags.
-     * @return the current value of the debug flags.
-     */
-    public int getDebugFlags() {
-        return mDebugFlags;
-    }
-
-    /**
-     * Control whether the EGL context is preserved when the GLSurfaceView is paused and
-     * resumed.
-     * <p>
-     * If set to true, then the EGL context may be preserved when the GLSurfaceView is paused.
-     * <p>
-     * Prior to API level 11, whether the EGL context is actually preserved or not
-     * depends upon whether the Android device can support an arbitrary number of
-     * EGL contexts or not. Devices that can only support a limited number of EGL
-     * contexts must release the EGL context in order to allow multiple applications
-     * to share the GPU.
-     * <p>
-     * If set to false, the EGL context will be released when the GLSurfaceView is paused,
-     * and recreated when the GLSurfaceView is resumed.
-     * <p>
-     *
-     * The default is false.
-     *
-     * @param preserveOnPause preserve the EGL context when paused
-     */
-    public void setPreserveEGLContextOnPause(boolean preserveOnPause) {
-        mPreserveEGLContextOnPause = preserveOnPause;
-    }
-
-    /**
-     * @return true if the EGL context will be preserved when paused
-     */
-    public boolean getPreserveEGLContextOnPause() {
-        return mPreserveEGLContextOnPause;
-    }
-
-    /**
-     * Set the renderer associated with this view. Also starts the thread that
-     * will call the renderer, which in turn causes the rendering to start.
-     * <p>This method should be called once and only once in the life-cycle of
-     * a GLSurfaceView.
-     * <p>The following GLSurfaceView methods can only be called <em>before</em>
-     * setRenderer is called:
-     * <ul>
-     * <li>{@link #setEGLConfigChooser(boolean)}
-     * <li>{@link #setEGLConfigChooser(EGLConfigChooser)}
-     * <li>{@link #setEGLConfigChooser(int, int, int, int, int, int)}
-     * </ul>
-     * <p>
-     * The following GLSurfaceView methods can only be called <em>after</em>
-     * setRenderer is called:
-     * <ul>
-     * <li>{@link #getRenderMode()}
-     * <li>{@link #onPause()}
-     * <li>{@link #onResume()}
-     * <li>{@link #queueEvent(Runnable)}
-     * <li>{@link #requestRender()}
-     * <li>{@link #setRenderMode(int)}
-     * </ul>
-     *
-     * @param renderer the renderer to use to perform OpenGL drawing.
-     */
-    public void setRenderer(Renderer renderer) {
-        checkRenderThreadState();
-        if (mEGLConfigChooser == null) {
-            mEGLConfigChooser = new SimpleEGLConfigChooser(true);
-        }
-        if (mEGLContextFactory == null) {
-            mEGLContextFactory = new DefaultContextFactory();
-        }
-        if (mEGLWindowSurfaceFactory == null) {
-            mEGLWindowSurfaceFactory = new DefaultWindowSurfaceFactory();
-        }
-        mRenderer = renderer;
-        mGLThread = new GLThread(mThisWeakRef);
-        mGLThread.start();
-    }
-
-    /**
-     * Install a custom EGLContextFactory.
-     * <p>If this method is
-     * called, it must be called before {@link #setRenderer(Renderer)}
-     * is called.
-     * <p>
-     * If this method is not called, then by default
-     * a context will be created with no shared context and
-     * with a null attribute list.
-     */
-    public void setEGLContextFactory(EGLContextFactory factory) {
-        checkRenderThreadState();
-        mEGLContextFactory = factory;
-    }
-
-    /**
-     * Install a custom EGLWindowSurfaceFactory.
-     * <p>If this method is
-     * called, it must be called before {@link #setRenderer(Renderer)}
-     * is called.
-     * <p>
-     * If this method is not called, then by default
-     * a window surface will be created with a null attribute list.
-     */
-    public void setEGLWindowSurfaceFactory(EGLWindowSurfaceFactory factory) {
-        checkRenderThreadState();
-        mEGLWindowSurfaceFactory = factory;
-    }
-
-    /**
-     * Install a custom EGLConfigChooser.
-     * <p>If this method is
-     * called, it must be called before {@link #setRenderer(Renderer)}
-     * is called.
-     * <p>
-     * If no setEGLConfigChooser method is called, then by default the
-     * view will choose an EGLConfig that is compatible with the current
-     * android.view.Surface, with a depth buffer depth of
-     * at least 16 bits.
-     * @param configChooser
-     */
-    public void setEGLConfigChooser(EGLConfigChooser configChooser) {
-        checkRenderThreadState();
-        mEGLConfigChooser = configChooser;
-    }
-
-    /**
-     * Install a config chooser which will choose a config
-     * as close to 16-bit RGB as possible, with or without an optional depth
-     * buffer as close to 16-bits as possible.
-     * <p>If this method is
-     * called, it must be called before {@link #setRenderer(Renderer)}
-     * is called.
-     * <p>
-     * If no setEGLConfigChooser method is called, then by default the
-     * view will choose an RGB_888 surface with a depth buffer depth of
-     * at least 16 bits.
-     *
-     * @param needDepth
-     */
-    public void setEGLConfigChooser(boolean needDepth) {
-        setEGLConfigChooser(new SimpleEGLConfigChooser(needDepth));
-    }
-
-    /**
-     * Install a config chooser which will choose a config
-     * with at least the specified depthSize and stencilSize,
-     * and exactly the specified redSize, greenSize, blueSize and alphaSize.
-     * <p>If this method is
-     * called, it must be called before {@link #setRenderer(Renderer)}
-     * is called.
-     * <p>
-     * If no setEGLConfigChooser method is called, then by default the
-     * view will choose an RGB_888 surface with a depth buffer depth of
-     * at least 16 bits.
-     *
-     */
-    public void setEGLConfigChooser(int redSize, int greenSize, int blueSize,
-            int alphaSize, int depthSize, int stencilSize) {
-        setEGLConfigChooser(new ComponentSizeChooser(redSize, greenSize,
-                blueSize, alphaSize, depthSize, stencilSize));
-    }
-
-    /**
-     * Inform the default EGLContextFactory and default EGLConfigChooser
-     * which EGLContext client version to pick.
-     * <p>Use this method to create an OpenGL ES 2.0-compatible context.
-     * Example:
-     * <pre class="prettyprint">
-     *     public MyView(Context context) {
-     *         super(context);
-     *         setEGLContextClientVersion(2); // Pick an OpenGL ES 2.0 context.
-     *         setRenderer(new MyRenderer());
-     *     }
-     * </pre>
-     * <p>Note: Activities which require OpenGL ES 2.0 should indicate this by
-     * setting @lt;uses-feature android:glEsVersion="0x00020000" /> in the activity's
-     * AndroidManifest.xml file.
-     * <p>If this method is called, it must be called before {@link #setRenderer(Renderer)}
-     * is called.
-     * <p>This method only affects the behavior of the default EGLContexFactory and the
-     * default EGLConfigChooser. If
-     * {@link #setEGLContextFactory(EGLContextFactory)} has been called, then the supplied
-     * EGLContextFactory is responsible for creating an OpenGL ES 2.0-compatible context.
-     * If
-     * {@link #setEGLConfigChooser(EGLConfigChooser)} has been called, then the supplied
-     * EGLConfigChooser is responsible for choosing an OpenGL ES 2.0-compatible config.
-     * @param version The EGLContext client version to choose. Use 2 for OpenGL ES 2.0
-     */
-    public void setEGLContextClientVersion(int version) {
-        checkRenderThreadState();
-        mEGLContextClientVersion = version;
-    }
-
-    /**
-     * Set the rendering mode. When renderMode is
-     * RENDERMODE_CONTINUOUSLY, the renderer is called
-     * repeatedly to re-render the scene. When renderMode
-     * is RENDERMODE_WHEN_DIRTY, the renderer only rendered when the surface
-     * is created, or when {@link #requestRender} is called. Defaults to RENDERMODE_CONTINUOUSLY.
-     * <p>
-     * Using RENDERMODE_WHEN_DIRTY can improve battery life and overall system performance
-     * by allowing the GPU and CPU to idle when the view does not need to be updated.
-     * <p>
-     * This method can only be called after {@link #setRenderer(Renderer)}
-     *
-     * @param renderMode one of the RENDERMODE_X constants
-     * @see #RENDERMODE_CONTINUOUSLY
-     * @see #RENDERMODE_WHEN_DIRTY
-     */
-    public void setRenderMode(int renderMode) {
-        mGLThread.setRenderMode(renderMode);
-    }
-
-    /**
-     * Get the current rendering mode. May be called
-     * from any thread. Must not be called before a renderer has been set.
-     * @return the current rendering mode.
-     * @see #RENDERMODE_CONTINUOUSLY
-     * @see #RENDERMODE_WHEN_DIRTY
-     */
-    public int getRenderMode() {
-        return mGLThread.getRenderMode();
-    }
-
-    /**
-     * Request that the renderer render a frame.
-     * This method is typically used when the render mode has been set to
-     * {@link #RENDERMODE_WHEN_DIRTY}, so that frames are only rendered on demand.
-     * May be called
-     * from any thread. Must not be called before a renderer has been set.
-     */
-    public void requestRender() {
-        mGLThread.requestRender();
-    }
-
-    /**
-     * This method is part of the SurfaceHolder.Callback interface, and is
-     * not normally called or subclassed by clients of GLSurfaceView.
-     */
-    public void surfaceCreated(SurfaceHolder holder) {
-        mGLThread.surfaceCreated();
-    }
-
-    /**
-     * This method is part of the SurfaceHolder.Callback interface, and is
-     * not normally called or subclassed by clients of GLSurfaceView.
-     */
-    public void surfaceDestroyed(SurfaceHolder holder) {
-        // Surface will be destroyed when we return
-        mGLThread.surfaceDestroyed();
-    }
-
-    /**
-     * This method is part of the SurfaceHolder.Callback interface, and is
-     * not normally called or subclassed by clients of GLSurfaceView.
-     */
-    public void surfaceChanged(SurfaceHolder holder, int format, int w, int h) {
-        mGLThread.onWindowResize(w, h);
-    }
-
-    /**
-     * This method is part of the SurfaceHolder.Callback interface, and is
-     * not normally called or subclassed by clients of GLSurfaceView.
-     */
-    @Override
-    public void surfaceRedrawNeeded(SurfaceHolder holder) {
-        if (mGLThread != null) {
-            mGLThread.requestRenderAndWait();
-        }
-    }
-
-
-    /**
-     * Pause the rendering thread, optionally tearing down the EGL context
-     * depending upon the value of {@link #setPreserveEGLContextOnPause(boolean)}.
-     *
-     * This method should be called when it is no longer desirable for the
-     * GLSurfaceView to continue rendering, such as in response to
-     * {@link android.app.Activity#onStop Activity.onStop}.
-     *
-     * Must not be called before a renderer has been set.
-     */
-    public void onPause() {
-        mGLThread.onPause();
-    }
-
-    /**
-     * Resumes the rendering thread, re-creating the OpenGL context if necessary. It
-     * is the counterpart to {@link #onPause()}.
-     *
-     * This method should typically be called in
-     * {@link android.app.Activity#onStart Activity.onStart}.
-     *
-     * Must not be called before a renderer has been set.
-     */
-    public void onResume() {
-        mGLThread.onResume();
-    }
-
-    /**
-     * Queue a runnable to be run on the GL rendering thread. This can be used
-     * to communicate with the Renderer on the rendering thread.
-     * Must not be called before a renderer has been set.
-     * @param r the runnable to be run on the GL rendering thread.
-     */
-    public void queueEvent(Runnable r) {
-        mGLThread.queueEvent(r);
-    }
-
-    /**
-     * This method is used as part of the View class and is not normally
-     * called or subclassed by clients of GLSurfaceView.
-     */
-    @Override
-    protected void onAttachedToWindow() {
-        super.onAttachedToWindow();
-        if (LOG_ATTACH_DETACH) {
-            Log.d(TAG, "onAttachedToWindow reattach =" + mDetached);
-        }
-        if (mDetached && (mRenderer != null)) {
-            int renderMode = RENDERMODE_CONTINUOUSLY;
-            if (mGLThread != null) {
-                renderMode = mGLThread.getRenderMode();
-            }
-            mGLThread = new GLThread(mThisWeakRef);
-            if (renderMode != RENDERMODE_CONTINUOUSLY) {
-                mGLThread.setRenderMode(renderMode);
-            }
-            mGLThread.start();
-        }
-        mDetached = false;
-    }
-
-    @Override
-    protected void onDetachedFromWindow() {
-        if (LOG_ATTACH_DETACH) {
-            Log.d(TAG, "onDetachedFromWindow");
-        }
-        if (mGLThread != null) {
-            mGLThread.requestExitAndWait();
-        }
-        mDetached = true;
-        super.onDetachedFromWindow();
-    }
-
-    // ----------------------------------------------------------------------
-
-    /**
-     * An interface used to wrap a GL interface.
-     * <p>Typically
-     * used for implementing debugging and tracing on top of the default
-     * GL interface. You would typically use this by creating your own class
-     * that implemented all the GL methods by delegating to another GL instance.
-     * Then you could add your own behavior before or after calling the
-     * delegate. All the GLWrapper would do was instantiate and return the
-     * wrapper GL instance:
-     * <pre class="prettyprint">
-     * class MyGLWrapper implements GLWrapper {
-     *     GL wrap(GL gl) {
-     *         return new MyGLImplementation(gl);
-     *     }
-     *     static class MyGLImplementation implements GL,GL10,GL11,... {
-     *         ...
-     *     }
-     * }
-     * </pre>
-     * @see #setGLWrapper(GLWrapper)
-     */
-    public interface GLWrapper {
-        /**
-         * Wraps a gl interface in another gl interface.
-         * @param gl a GL interface that is to be wrapped.
-         * @return either the input argument or another GL object that wraps the input argument.
-         */
-        GL wrap(GL gl);
-    }
-
-    /**
-     * A generic renderer interface.
-     * <p>
-     * The renderer is responsible for making OpenGL calls to render a frame.
-     * <p>
-     * GLSurfaceView clients typically create their own classes that implement
-     * this interface, and then call {@link GLSurfaceView#setRenderer} to
-     * register the renderer with the GLSurfaceView.
-     * <p>
-     *
-     * <div class="special reference">
-     * <h3>Developer Guides</h3>
-     * <p>For more information about how to use OpenGL, read the
-     * <a href="{@docRoot}guide/topics/graphics/opengl.html">OpenGL</a> developer guide.</p>
-     * </div>
-     *
-     * <h3>Threading</h3>
-     * The renderer will be called on a separate thread, so that rendering
-     * performance is decoupled from the UI thread. Clients typically need to
-     * communicate with the renderer from the UI thread, because that's where
-     * input events are received. Clients can communicate using any of the
-     * standard Java techniques for cross-thread communication, or they can
-     * use the {@link GLSurfaceView#queueEvent(Runnable)} convenience method.
-     * <p>
-     * <h3>EGL Context Lost</h3>
-     * There are situations where the EGL rendering context will be lost. This
-     * typically happens when device wakes up after going to sleep. When
-     * the EGL context is lost, all OpenGL resources (such as textures) that are
-     * associated with that context will be automatically deleted. In order to
-     * keep rendering correctly, a renderer must recreate any lost resources
-     * that it still needs. The {@link #onSurfaceCreated(GL10, EGLConfig)} method
-     * is a convenient place to do this.
-     *
-     *
-     * @see #setRenderer(Renderer)
-     */
-    public interface Renderer {
-        /**
-         * Called when the surface is created or recreated.
-         * <p>
-         * Called when the rendering thread
-         * starts and whenever the EGL context is lost. The EGL context will typically
-         * be lost when the Android device awakes after going to sleep.
-         * <p>
-         * Since this method is called at the beginning of rendering, as well as
-         * every time the EGL context is lost, this method is a convenient place to put
-         * code to create resources that need to be created when the rendering
-         * starts, and that need to be recreated when the EGL context is lost.
-         * Textures are an example of a resource that you might want to create
-         * here.
-         * <p>
-         * Note that when the EGL context is lost, all OpenGL resources associated
-         * with that context will be automatically deleted. You do not need to call
-         * the corresponding "glDelete" methods such as glDeleteTextures to
-         * manually delete these lost resources.
-         * <p>
-         * @param gl the GL interface. Use <code>instanceof</code> to
-         * test if the interface supports GL11 or higher interfaces.
-         * @param config the EGLConfig of the created surface. Can be used
-         * to create matching pbuffers.
-         */
-        void onSurfaceCreated(GL10 gl, EGLConfig config);
-
-        /**
-         * Called when the surface changed size.
-         * <p>
-         * Called after the surface is created and whenever
-         * the OpenGL ES surface size changes.
-         * <p>
-         * Typically you will set your viewport here. If your camera
-         * is fixed then you could also set your projection matrix here:
-         * <pre class="prettyprint">
-         * void onSurfaceChanged(GL10 gl, int width, int height) {
-         *     gl.glViewport(0, 0, width, height);
-         *     // for a fixed camera, set the projection too
-         *     float ratio = (float) width / height;
-         *     gl.glMatrixMode(GL10.GL_PROJECTION);
-         *     gl.glLoadIdentity();
-         *     gl.glFrustumf(-ratio, ratio, -1, 1, 1, 10);
-         * }
-         * </pre>
-         * @param gl the GL interface. Use <code>instanceof</code> to
-         * test if the interface supports GL11 or higher interfaces.
-         * @param width
-         * @param height
-         */
-        void onSurfaceChanged(GL10 gl, int width, int height);
-
-        /**
-         * Called to draw the current frame.
-         * <p>
-         * This method is responsible for drawing the current frame.
-         * <p>
-         * The implementation of this method typically looks like this:
-         * <pre class="prettyprint">
-         * void onDrawFrame(GL10 gl) {
-         *     gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
-         *     //... other gl calls to render the scene ...
-         * }
-         * </pre>
-         * @param gl the GL interface. Use <code>instanceof</code> to
-         * test if the interface supports GL11 or higher interfaces.
-         */
-        void onDrawFrame(GL10 gl);
-    }
-
-    /**
-     * An interface for customizing the eglCreateContext and eglDestroyContext calls.
-     * <p>
-     * This interface must be implemented by clients wishing to call
-     * {@link GLSurfaceView#setEGLContextFactory(EGLContextFactory)}
-     */
-    public interface EGLContextFactory {
-        EGLContext createContext(EGL10 egl, EGLDisplay display, EGLConfig eglConfig);
-        void destroyContext(EGL10 egl, EGLDisplay display, EGLContext context);
-    }
-
-    private class DefaultContextFactory implements EGLContextFactory {
-        private int EGL_CONTEXT_CLIENT_VERSION = 0x3098;
-
-        public EGLContext createContext(EGL10 egl, EGLDisplay display, EGLConfig config) {
-            int[] attrib_list = {EGL_CONTEXT_CLIENT_VERSION, mEGLContextClientVersion,
-                    EGL10.EGL_NONE };
-
-            return egl.eglCreateContext(display, config, EGL10.EGL_NO_CONTEXT,
-                    mEGLContextClientVersion != 0 ? attrib_list : null);
-        }
-
-        public void destroyContext(EGL10 egl, EGLDisplay display,
-                EGLContext context) {
-            if (!egl.eglDestroyContext(display, context)) {
-                Log.e("DefaultContextFactory", "display:" + display + " context: " + context);
-                if (LOG_THREADS) {
-                    Log.i("DefaultContextFactory", "tid=" + Thread.currentThread().getId());
-                }
-                EglHelper.throwEglException("eglDestroyContex", egl.eglGetError());
-            }
-        }
-    }
-
-    /**
-     * An interface for customizing the eglCreateWindowSurface and eglDestroySurface calls.
-     * <p>
-     * This interface must be implemented by clients wishing to call
-     * {@link GLSurfaceView#setEGLWindowSurfaceFactory(EGLWindowSurfaceFactory)}
-     */
-    public interface EGLWindowSurfaceFactory {
-        /**
-         *  @return null if the surface cannot be constructed.
-         */
-        EGLSurface createWindowSurface(EGL10 egl, EGLDisplay display, EGLConfig config,
-                Object nativeWindow);
-        void destroySurface(EGL10 egl, EGLDisplay display, EGLSurface surface);
-    }
-
-    private static class DefaultWindowSurfaceFactory implements EGLWindowSurfaceFactory {
-
-        public EGLSurface createWindowSurface(EGL10 egl, EGLDisplay display,
-                EGLConfig config, Object nativeWindow) {
-            EGLSurface result = null;
-            try {
-                result = egl.eglCreateWindowSurface(display, config, nativeWindow, null);
-            } catch (IllegalArgumentException e) {
-                // This exception indicates that the surface flinger surface
-                // is not valid. This can happen if the surface flinger surface has
-                // been torn down, but the application has not yet been
-                // notified via SurfaceHolder.Callback.surfaceDestroyed.
-                // In theory the application should be notified first,
-                // but in practice sometimes it is not. See b/4588890
-                Log.e(TAG, "eglCreateWindowSurface", e);
-            }
-            return result;
-        }
-
-        public void destroySurface(EGL10 egl, EGLDisplay display,
-                EGLSurface surface) {
-            egl.eglDestroySurface(display, surface);
-        }
-    }
-
-    /**
-     * An interface for choosing an EGLConfig configuration from a list of
-     * potential configurations.
-     * <p>
-     * This interface must be implemented by clients wishing to call
-     * {@link GLSurfaceView#setEGLConfigChooser(EGLConfigChooser)}
-     */
-    public interface EGLConfigChooser {
-        /**
-         * Choose a configuration from the list. Implementors typically
-         * implement this method by calling
-         * {@link EGL10#eglChooseConfig} and iterating through the results. Please consult the
-         * EGL specification available from The Khronos Group to learn how to call eglChooseConfig.
-         * @param egl the EGL10 for the current display.
-         * @param display the current display.
-         * @return the chosen configuration.
-         */
-        EGLConfig chooseConfig(EGL10 egl, EGLDisplay display);
-    }
-
-    private abstract class BaseConfigChooser
-            implements EGLConfigChooser {
-        public BaseConfigChooser(int[] configSpec) {
-            mConfigSpec = filterConfigSpec(configSpec);
-        }
-
-        public EGLConfig chooseConfig(EGL10 egl, EGLDisplay display) {
-            int[] num_config = new int[1];
-            if (!egl.eglChooseConfig(display, mConfigSpec, null, 0,
-                    num_config)) {
-                throw new IllegalArgumentException("eglChooseConfig failed");
-            }
-
-            int numConfigs = num_config[0];
-
-            if (numConfigs <= 0) {
-                throw new IllegalArgumentException(
-                        "No configs match configSpec");
-            }
-
-            EGLConfig[] configs = new EGLConfig[numConfigs];
-            if (!egl.eglChooseConfig(display, mConfigSpec, configs, numConfigs,
-                    num_config)) {
-                throw new IllegalArgumentException("eglChooseConfig#2 failed");
-            }
-            EGLConfig config = chooseConfig(egl, display, configs);
-            if (config == null) {
-                throw new IllegalArgumentException("No config chosen");
-            }
-            return config;
-        }
-
-        abstract EGLConfig chooseConfig(EGL10 egl, EGLDisplay display,
-                EGLConfig[] configs);
-
-        protected int[] mConfigSpec;
-
-        private int[] filterConfigSpec(int[] configSpec) {
-            if (mEGLContextClientVersion != 2 && mEGLContextClientVersion != 3) {
-                return configSpec;
-            }
-            /* We know none of the subclasses define EGL_RENDERABLE_TYPE.
-             * And we know the configSpec is well formed.
-             */
-            int len = configSpec.length;
-            int[] newConfigSpec = new int[len + 2];
-            System.arraycopy(configSpec, 0, newConfigSpec, 0, len-1);
-            newConfigSpec[len-1] = EGL10.EGL_RENDERABLE_TYPE;
-            if (mEGLContextClientVersion == 2) {
-                newConfigSpec[len] = EGL14.EGL_OPENGL_ES2_BIT;  /* EGL_OPENGL_ES2_BIT */
-            } else {
-                newConfigSpec[len] = EGLExt.EGL_OPENGL_ES3_BIT_KHR; /* EGL_OPENGL_ES3_BIT_KHR */
-            }
-            newConfigSpec[len+1] = EGL10.EGL_NONE;
-            return newConfigSpec;
-        }
-    }
-
-    /**
-     * Choose a configuration with exactly the specified r,g,b,a sizes,
-     * and at least the specified depth and stencil sizes.
-     */
-    private class ComponentSizeChooser extends BaseConfigChooser {
-        public ComponentSizeChooser(int redSize, int greenSize, int blueSize,
-                int alphaSize, int depthSize, int stencilSize) {
-            super(new int[] {
-                    EGL10.EGL_RED_SIZE, redSize,
-                    EGL10.EGL_GREEN_SIZE, greenSize,
-                    EGL10.EGL_BLUE_SIZE, blueSize,
-                    EGL10.EGL_ALPHA_SIZE, alphaSize,
-                    EGL10.EGL_DEPTH_SIZE, depthSize,
-                    EGL10.EGL_STENCIL_SIZE, stencilSize,
-                    EGL10.EGL_NONE});
-            mValue = new int[1];
-            mRedSize = redSize;
-            mGreenSize = greenSize;
-            mBlueSize = blueSize;
-            mAlphaSize = alphaSize;
-            mDepthSize = depthSize;
-            mStencilSize = stencilSize;
-       }
-
-        @Override
-        public EGLConfig chooseConfig(EGL10 egl, EGLDisplay display,
-                EGLConfig[] configs) {
-            for (EGLConfig config : configs) {
-                int d = findConfigAttrib(egl, display, config,
-                        EGL10.EGL_DEPTH_SIZE, 0);
-                int s = findConfigAttrib(egl, display, config,
-                        EGL10.EGL_STENCIL_SIZE, 0);
-                if ((d >= mDepthSize) && (s >= mStencilSize)) {
-                    int r = findConfigAttrib(egl, display, config,
-                            EGL10.EGL_RED_SIZE, 0);
-                    int g = findConfigAttrib(egl, display, config,
-                             EGL10.EGL_GREEN_SIZE, 0);
-                    int b = findConfigAttrib(egl, display, config,
-                              EGL10.EGL_BLUE_SIZE, 0);
-                    int a = findConfigAttrib(egl, display, config,
-                            EGL10.EGL_ALPHA_SIZE, 0);
-                    if ((r == mRedSize) && (g == mGreenSize)
-                            && (b == mBlueSize) && (a == mAlphaSize)) {
-                        return config;
-                    }
-                }
-            }
-            return null;
-        }
-
-        private int findConfigAttrib(EGL10 egl, EGLDisplay display,
-                EGLConfig config, int attribute, int defaultValue) {
-
-            if (egl.eglGetConfigAttrib(display, config, attribute, mValue)) {
-                return mValue[0];
-            }
-            return defaultValue;
-        }
-
-        private int[] mValue;
-        // Subclasses can adjust these values:
-        protected int mRedSize;
-        protected int mGreenSize;
-        protected int mBlueSize;
-        protected int mAlphaSize;
-        protected int mDepthSize;
-        protected int mStencilSize;
-        }
-
-    /**
-     * This class will choose a RGB_888 surface with
-     * or without a depth buffer.
-     *
-     */
-    private class SimpleEGLConfigChooser extends ComponentSizeChooser {
-        public SimpleEGLConfigChooser(boolean withDepthBuffer) {
-            super(8, 8, 8, 0, withDepthBuffer ? 16 : 0, 0);
-        }
-    }
-
-    /**
-     * An EGL helper class.
-     */
-
-    private static class EglHelper {
-        public EglHelper(WeakReference<GLSurfaceView> glSurfaceViewWeakRef) {
-            mGLSurfaceViewWeakRef = glSurfaceViewWeakRef;
-        }
-
-        /**
-         * Initialize EGL for a given configuration spec.
-         * @param configSpec
-         */
-        public void start() {
-            if (LOG_EGL) {
-                Log.w("EglHelper", "start() tid=" + Thread.currentThread().getId());
-            }
-            /*
-             * Get an EGL instance
-             */
-            mEgl = (EGL10) EGLContext.getEGL();
-
-            /*
-             * Get to the default display.
-             */
-            mEglDisplay = mEgl.eglGetDisplay(EGL10.EGL_DEFAULT_DISPLAY);
-
-            if (mEglDisplay == EGL10.EGL_NO_DISPLAY) {
-                throw new RuntimeException("eglGetDisplay failed");
-            }
-
-            /*
-             * We can now initialize EGL for that display
-             */
-            int[] version = new int[2];
-            if(!mEgl.eglInitialize(mEglDisplay, version)) {
-                throw new RuntimeException("eglInitialize failed");
-            }
-            GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-            if (view == null) {
-                mEglConfig = null;
-                mEglContext = null;
-            } else {
-                mEglConfig = view.mEGLConfigChooser.chooseConfig(mEgl, mEglDisplay);
-
-                /*
-                * Create an EGL context. We want to do this as rarely as we can, because an
-                * EGL context is a somewhat heavy object.
-                */
-                mEglContext = view.mEGLContextFactory.createContext(mEgl, mEglDisplay, mEglConfig);
-            }
-            if (mEglContext == null || mEglContext == EGL10.EGL_NO_CONTEXT) {
-                mEglContext = null;
-                throwEglException("createContext");
-            }
-            if (LOG_EGL) {
-                Log.w("EglHelper", "createContext " + mEglContext + " tid=" + Thread.currentThread().getId());
-            }
-
-            mEglSurface = null;
-        }
-
-        /**
-         * Create an egl surface for the current SurfaceHolder surface. If a surface
-         * already exists, destroy it before creating the new surface.
-         *
-         * @return true if the surface was created successfully.
-         */
-        public boolean createSurface() {
-            if (LOG_EGL) {
-                Log.w("EglHelper", "createSurface()  tid=" + Thread.currentThread().getId());
-            }
-            /*
-             * Check preconditions.
-             */
-            if (mEgl == null) {
-                throw new RuntimeException("egl not initialized");
-            }
-            if (mEglDisplay == null) {
-                throw new RuntimeException("eglDisplay not initialized");
-            }
-            if (mEglConfig == null) {
-                throw new RuntimeException("mEglConfig not initialized");
-            }
-
-            /*
-             *  The window size has changed, so we need to create a new
-             *  surface.
-             */
-            destroySurfaceImp();
-
-            /*
-             * Create an EGL surface we can render into.
-             */
-            GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-            if (view != null) {
-                mEglSurface = view.mEGLWindowSurfaceFactory.createWindowSurface(mEgl,
-                        mEglDisplay, mEglConfig, view.getHolder());
-            } else {
-                mEglSurface = null;
-            }
-
-            if (mEglSurface == null || mEglSurface == EGL10.EGL_NO_SURFACE) {
-                int error = mEgl.eglGetError();
-                if (error == EGL10.EGL_BAD_NATIVE_WINDOW) {
-                    Log.e("EglHelper", "createWindowSurface returned EGL_BAD_NATIVE_WINDOW.");
-                }
-                return false;
-            }
-
-            /*
-             * Before we can issue GL commands, we need to make sure
-             * the context is current and bound to a surface.
-             */
-            if (!mEgl.eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface, mEglContext)) {
-                /*
-                 * Could not make the context current, probably because the underlying
-                 * SurfaceView surface has been destroyed.
-                 */
-                logEglErrorAsWarning("EGLHelper", "eglMakeCurrent", mEgl.eglGetError());
-                return false;
-            }
-
-            return true;
-        }
-
-        /**
-         * Create a GL object for the current EGL context.
-         * @return
-         */
-        GL createGL() {
-
-            GL gl = mEglContext.getGL();
-            GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-            if (view != null) {
-                if (view.mGLWrapper != null) {
-                    gl = view.mGLWrapper.wrap(gl);
-                }
-
-                if ((view.mDebugFlags & (DEBUG_CHECK_GL_ERROR | DEBUG_LOG_GL_CALLS)) != 0) {
-                    int configFlags = 0;
-                    Writer log = null;
-                    if ((view.mDebugFlags & DEBUG_CHECK_GL_ERROR) != 0) {
-                        configFlags |= GLDebugHelper.CONFIG_CHECK_GL_ERROR;
-                    }
-                    if ((view.mDebugFlags & DEBUG_LOG_GL_CALLS) != 0) {
-                        log = new LogWriter();
-                    }
-                    gl = GLDebugHelper.wrap(gl, configFlags, log);
-                }
-            }
-            return gl;
-        }
-
-        /**
-         * Display the current render surface.
-         * @return the EGL error code from eglSwapBuffers.
-         */
-        public int swap() {
-            if (! mEgl.eglSwapBuffers(mEglDisplay, mEglSurface)) {
-                return mEgl.eglGetError();
-            }
-            return EGL10.EGL_SUCCESS;
-        }
-
-        public void destroySurface() {
-            if (LOG_EGL) {
-                Log.w("EglHelper", "destroySurface()  tid=" + Thread.currentThread().getId());
-            }
-            destroySurfaceImp();
-        }
-
-        private void destroySurfaceImp() {
-            if (mEglSurface != null && mEglSurface != EGL10.EGL_NO_SURFACE) {
-                mEgl.eglMakeCurrent(mEglDisplay, EGL10.EGL_NO_SURFACE,
-                        EGL10.EGL_NO_SURFACE,
-                        EGL10.EGL_NO_CONTEXT);
-                GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-                if (view != null) {
-                    view.mEGLWindowSurfaceFactory.destroySurface(mEgl, mEglDisplay, mEglSurface);
-                }
-                mEglSurface = null;
-            }
-        }
-
-        public void finish() {
-            if (LOG_EGL) {
-                Log.w("EglHelper", "finish() tid=" + Thread.currentThread().getId());
-            }
-            if (mEglContext != null) {
-                GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-                if (view != null) {
-                    view.mEGLContextFactory.destroyContext(mEgl, mEglDisplay, mEglContext);
-                }
-                mEglContext = null;
-            }
-            if (mEglDisplay != null) {
-                mEgl.eglTerminate(mEglDisplay);
-                mEglDisplay = null;
-            }
-        }
-
-        private void throwEglException(String function) {
-            throwEglException(function, mEgl.eglGetError());
-        }
-
-        public static void throwEglException(String function, int error) {
-            String message = formatEglError(function, error);
-            if (LOG_THREADS) {
-                Log.e("EglHelper", "throwEglException tid=" + Thread.currentThread().getId() + " "
-                        + message);
-            }
-            throw new RuntimeException(message);
-        }
-
-        public static void logEglErrorAsWarning(String tag, String function, int error) {
-            Log.w(tag, formatEglError(function, error));
-        }
-
-        public static String formatEglError(String function, int error) {
-            return function + " failed: " + EGLLogWrapper.getErrorString(error);
-        }
-
-        private WeakReference<GLSurfaceView> mGLSurfaceViewWeakRef;
-        EGL10 mEgl;
-        EGLDisplay mEglDisplay;
-        EGLSurface mEglSurface;
-        EGLConfig mEglConfig;
-        EGLContext mEglContext;
-
-    }
-
-    /**
-     * A generic GL Thread. Takes care of initializing EGL and GL. Delegates
-     * to a Renderer instance to do the actual drawing. Can be configured to
-     * render continuously or on request.
-     *
-     * All potentially blocking synchronization is done through the
-     * sGLThreadManager object. This avoids multiple-lock ordering issues.
-     *
-     */
-    static class GLThread extends Thread {
-        GLThread(WeakReference<GLSurfaceView> glSurfaceViewWeakRef) {
-            super();
-            mWidth = 0;
-            mHeight = 0;
-            mRequestRender = true;
-            mRenderMode = RENDERMODE_CONTINUOUSLY;
-            mWantRenderNotification = false;
-            mGLSurfaceViewWeakRef = glSurfaceViewWeakRef;
-        }
-
-        @Override
-        public void run() {
-            setName("GLThread " + getId());
-            if (LOG_THREADS) {
-                Log.i("GLThread", "starting tid=" + getId());
-            }
-
-            try {
-                guardedRun();
-            } catch (InterruptedException e) {
-                // fall thru and exit normally
-            } finally {
-                sGLThreadManager.threadExiting(this);
-            }
-        }
-
-        /*
-         * This private method should only be called inside a
-         * synchronized(sGLThreadManager) block.
-         */
-        private void stopEglSurfaceLocked() {
-            if (mHaveEglSurface) {
-                mHaveEglSurface = false;
-                mEglHelper.destroySurface();
-            }
-        }
-
-        /*
-         * This private method should only be called inside a
-         * synchronized(sGLThreadManager) block.
-         */
-        private void stopEglContextLocked() {
-            if (mHaveEglContext) {
-                mEglHelper.finish();
-                mHaveEglContext = false;
-                sGLThreadManager.releaseEglContextLocked(this);
-            }
-        }
-        private void guardedRun() throws InterruptedException {
-            mEglHelper = new EglHelper(mGLSurfaceViewWeakRef);
-            mHaveEglContext = false;
-            mHaveEglSurface = false;
-            mWantRenderNotification = false;
-
-            try {
-                GL10 gl = null;
-                boolean createEglContext = false;
-                boolean createEglSurface = false;
-                boolean createGlInterface = false;
-                boolean lostEglContext = false;
-                boolean sizeChanged = false;
-                boolean wantRenderNotification = false;
-                boolean doRenderNotification = false;
-                boolean askedToReleaseEglContext = false;
-                int w = 0;
-                int h = 0;
-                Runnable event = null;
-
-                while (true) {
-                    synchronized (sGLThreadManager) {
-                        while (true) {
-                            if (mShouldExit) {
-                                return;
-                            }
-
-                            if (! mEventQueue.isEmpty()) {
-                                event = mEventQueue.remove(0);
-                                break;
-                            }
-
-                            // Update the pause state.
-                            boolean pausing = false;
-                            if (mPaused != mRequestPaused) {
-                                pausing = mRequestPaused;
-                                mPaused = mRequestPaused;
-                                sGLThreadManager.notifyAll();
-                                if (LOG_PAUSE_RESUME) {
-                                    Log.i("GLThread", "mPaused is now " + mPaused + " tid=" + getId());
-                                }
-                            }
-
-                            // Do we need to give up the EGL context?
-                            if (mShouldReleaseEglContext) {
-                                if (LOG_SURFACE) {
-                                    Log.i("GLThread", "releasing EGL context because asked to tid=" + getId());
-                                }
-                                stopEglSurfaceLocked();
-                                stopEglContextLocked();
-                                mShouldReleaseEglContext = false;
-                                askedToReleaseEglContext = true;
-                            }
-
-                            // Have we lost the EGL context?
-                            if (lostEglContext) {
-                                stopEglSurfaceLocked();
-                                stopEglContextLocked();
-                                lostEglContext = false;
-                            }
-
-                            // When pausing, release the EGL surface:
-                            if (pausing && mHaveEglSurface) {
-                                if (LOG_SURFACE) {
-                                    Log.i("GLThread", "releasing EGL surface because paused tid=" + getId());
-                                }
-                                stopEglSurfaceLocked();
-                            }
-
-                            // When pausing, optionally release the EGL Context:
-                            if (pausing && mHaveEglContext) {
-                                GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-                                boolean preserveEglContextOnPause = view == null ?
-                                        false : view.mPreserveEGLContextOnPause;
-                                if (!preserveEglContextOnPause) {
-                                    stopEglContextLocked();
-                                    if (LOG_SURFACE) {
-                                        Log.i("GLThread", "releasing EGL context because paused tid=" + getId());
-                                    }
-                                }
-                            }
-
-                            // Have we lost the SurfaceView surface?
-                            if ((! mHasSurface) && (! mWaitingForSurface)) {
-                                if (LOG_SURFACE) {
-                                    Log.i("GLThread", "noticed surfaceView surface lost tid=" + getId());
-                                }
-                                if (mHaveEglSurface) {
-                                    stopEglSurfaceLocked();
-                                }
-                                mWaitingForSurface = true;
-                                mSurfaceIsBad = false;
-                                sGLThreadManager.notifyAll();
-                            }
-
-                            // Have we acquired the surface view surface?
-                            if (mHasSurface && mWaitingForSurface) {
-                                if (LOG_SURFACE) {
-                                    Log.i("GLThread", "noticed surfaceView surface acquired tid=" + getId());
-                                }
-                                mWaitingForSurface = false;
-                                sGLThreadManager.notifyAll();
-                            }
-
-                            if (doRenderNotification) {
-                                if (LOG_SURFACE) {
-                                    Log.i("GLThread", "sending render notification tid=" + getId());
-                                }
-                                mWantRenderNotification = false;
-                                doRenderNotification = false;
-                                mRenderComplete = true;
-                                sGLThreadManager.notifyAll();
-                            }
-
-                            // Ready to draw?
-                            if (readyToDraw()) {
-
-                                // If we don't have an EGL context, try to acquire one.
-                                if (! mHaveEglContext) {
-                                    if (askedToReleaseEglContext) {
-                                        askedToReleaseEglContext = false;
-                                    } else {
-                                        try {
-                                            mEglHelper.start();
-                                        } catch (RuntimeException t) {
-                                            sGLThreadManager.releaseEglContextLocked(this);
-                                            throw t;
-                                        }
-                                        mHaveEglContext = true;
-                                        createEglContext = true;
-
-                                        sGLThreadManager.notifyAll();
-                                    }
-                                }
-
-                                if (mHaveEglContext && !mHaveEglSurface) {
-                                    mHaveEglSurface = true;
-                                    createEglSurface = true;
-                                    createGlInterface = true;
-                                    sizeChanged = true;
-                                }
-
-                                if (mHaveEglSurface) {
-                                    if (mSizeChanged) {
-                                        sizeChanged = true;
-                                        w = mWidth;
-                                        h = mHeight;
-                                        mWantRenderNotification = true;
-                                        if (LOG_SURFACE) {
-                                            Log.i("GLThread",
-                                                    "noticing that we want render notification tid="
-                                                    + getId());
-                                        }
-
-                                        // Destroy and recreate the EGL surface.
-                                        createEglSurface = true;
-
-                                        mSizeChanged = false;
-                                    }
-                                    mRequestRender = false;
-                                    sGLThreadManager.notifyAll();
-                                    if (mWantRenderNotification) {
-                                        wantRenderNotification = true;
-                                    }
-                                    break;
-                                }
-                            }
-
-                            // By design, this is the only place in a GLThread thread where we wait().
-                            if (LOG_THREADS) {
-                                Log.i("GLThread", "waiting tid=" + getId()
-                                    + " mHaveEglContext: " + mHaveEglContext
-                                    + " mHaveEglSurface: " + mHaveEglSurface
-                                    + " mFinishedCreatingEglSurface: " + mFinishedCreatingEglSurface
-                                    + " mPaused: " + mPaused
-                                    + " mHasSurface: " + mHasSurface
-                                    + " mSurfaceIsBad: " + mSurfaceIsBad
-                                    + " mWaitingForSurface: " + mWaitingForSurface
-                                    + " mWidth: " + mWidth
-                                    + " mHeight: " + mHeight
-                                    + " mRequestRender: " + mRequestRender
-                                    + " mRenderMode: " + mRenderMode);
-                            }
-                            sGLThreadManager.wait();
-                        }
-                    } // end of synchronized(sGLThreadManager)
-
-                    if (event != null) {
-                        event.run();
-                        event = null;
-                        continue;
-                    }
-
-                    if (createEglSurface) {
-                        if (LOG_SURFACE) {
-                            Log.w("GLThread", "egl createSurface");
-                        }
-                        if (mEglHelper.createSurface()) {
-                            synchronized(sGLThreadManager) {
-                                mFinishedCreatingEglSurface = true;
-                                sGLThreadManager.notifyAll();
-                            }
-                        } else {
-                            synchronized(sGLThreadManager) {
-                                mFinishedCreatingEglSurface = true;
-                                mSurfaceIsBad = true;
-                                sGLThreadManager.notifyAll();
-                            }
-                            continue;
-                        }
-                        createEglSurface = false;
-                    }
-
-                    if (createGlInterface) {
-                        gl = (GL10) mEglHelper.createGL();
-
-                        createGlInterface = false;
-                    }
-
-                    if (createEglContext) {
-                        if (LOG_RENDERER) {
-                            Log.w("GLThread", "onSurfaceCreated");
-                        }
-                        GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-                        if (view != null) {
-                            try {
-                                Trace.traceBegin(Trace.TRACE_TAG_VIEW, "onSurfaceCreated");
-                                view.mRenderer.onSurfaceCreated(gl, mEglHelper.mEglConfig);
-                            } finally {
-                                Trace.traceEnd(Trace.TRACE_TAG_VIEW);
-                            }
-                        }
-                        createEglContext = false;
-                    }
-
-                    if (sizeChanged) {
-                        if (LOG_RENDERER) {
-                            Log.w("GLThread", "onSurfaceChanged(" + w + ", " + h + ")");
-                        }
-                        GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-                        if (view != null) {
-                            try {
-                                Trace.traceBegin(Trace.TRACE_TAG_VIEW, "onSurfaceChanged");
-                                view.mRenderer.onSurfaceChanged(gl, w, h);
-                            } finally {
-                                Trace.traceEnd(Trace.TRACE_TAG_VIEW);
-                            }
-                        }
-                        sizeChanged = false;
-                    }
-
-                    if (LOG_RENDERER_DRAW_FRAME) {
-                        Log.w("GLThread", "onDrawFrame tid=" + getId());
-                    }
-                    {
-                        GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-                        if (view != null) {
-                            try {
-                                Trace.traceBegin(Trace.TRACE_TAG_VIEW, "onDrawFrame");
-                                view.mRenderer.onDrawFrame(gl);
-                            } finally {
-                                Trace.traceEnd(Trace.TRACE_TAG_VIEW);
-                            }
-                        }
-                    }
-                    int swapError = mEglHelper.swap();
-                    switch (swapError) {
-                        case EGL10.EGL_SUCCESS:
-                            break;
-                        case EGL11.EGL_CONTEXT_LOST:
-                            if (LOG_SURFACE) {
-                                Log.i("GLThread", "egl context lost tid=" + getId());
-                            }
-                            lostEglContext = true;
-                            break;
-                        default:
-                            // Other errors typically mean that the current surface is bad,
-                            // probably because the SurfaceView surface has been destroyed,
-                            // but we haven't been notified yet.
-                            // Log the error to help developers understand why rendering stopped.
-                            EglHelper.logEglErrorAsWarning("GLThread", "eglSwapBuffers", swapError);
-
-                            synchronized(sGLThreadManager) {
-                                mSurfaceIsBad = true;
-                                sGLThreadManager.notifyAll();
-                            }
-                            break;
-                    }
-
-                    if (wantRenderNotification) {
-                        doRenderNotification = true;
-                        wantRenderNotification = false;
-                    }
-                }
-
-            } finally {
-                /*
-                 * clean-up everything...
-                 */
-                synchronized (sGLThreadManager) {
-                    stopEglSurfaceLocked();
-                    stopEglContextLocked();
-                }
-            }
-        }
-
-        public boolean ableToDraw() {
-            return mHaveEglContext && mHaveEglSurface && readyToDraw();
-        }
-
-        private boolean readyToDraw() {
-            return (!mPaused) && mHasSurface && (!mSurfaceIsBad)
-                && (mWidth > 0) && (mHeight > 0)
-                && (mRequestRender || (mRenderMode == RENDERMODE_CONTINUOUSLY));
-        }
-
-        public void setRenderMode(int renderMode) {
-            if ( !((RENDERMODE_WHEN_DIRTY <= renderMode) && (renderMode <= RENDERMODE_CONTINUOUSLY)) ) {
-                throw new IllegalArgumentException("renderMode");
-            }
-            synchronized(sGLThreadManager) {
-                mRenderMode = renderMode;
-                sGLThreadManager.notifyAll();
-            }
-        }
-
-        public int getRenderMode() {
-            synchronized(sGLThreadManager) {
-                return mRenderMode;
-            }
-        }
-
-        public void requestRender() {
-            synchronized(sGLThreadManager) {
-                mRequestRender = true;
-                sGLThreadManager.notifyAll();
-            }
-        }
-
-        public void requestRenderAndWait() {
-            synchronized(sGLThreadManager) {
-                // If we are already on the GL thread, this means a client callback
-                // has caused reentrancy, for example via updating the SurfaceView parameters.
-                // We will return to the client rendering code, so here we don't need to
-                // do anything.
-                if (Thread.currentThread() == this) {
-                    return;
-                }
-
-                mWantRenderNotification = true;
-                mRequestRender = true;
-                mRenderComplete = false;
-
-                sGLThreadManager.notifyAll();
-
-                while (!mExited && !mPaused && !mRenderComplete && ableToDraw()) {
-                    try {
-                        sGLThreadManager.wait();
-                    } catch (InterruptedException ex) {
-                        Thread.currentThread().interrupt();
-                    }
-                }
-
-            }
-        }
-
-        public void surfaceCreated() {
-            synchronized(sGLThreadManager) {
-                if (LOG_THREADS) {
-                    Log.i("GLThread", "surfaceCreated tid=" + getId());
-                }
-                mHasSurface = true;
-                mFinishedCreatingEglSurface = false;
-                sGLThreadManager.notifyAll();
-                while (mWaitingForSurface
-                       && !mFinishedCreatingEglSurface
-                       && !mExited) {
-                    try {
-                        sGLThreadManager.wait();
-                    } catch (InterruptedException e) {
-                        Thread.currentThread().interrupt();
-                    }
-                }
-            }
-        }
-
-        public void surfaceDestroyed() {
-            synchronized(sGLThreadManager) {
-                if (LOG_THREADS) {
-                    Log.i("GLThread", "surfaceDestroyed tid=" + getId());
-                }
-                mHasSurface = false;
-                sGLThreadManager.notifyAll();
-                while((!mWaitingForSurface) && (!mExited)) {
-                    try {
-                        sGLThreadManager.wait();
-                    } catch (InterruptedException e) {
-                        Thread.currentThread().interrupt();
-                    }
-                }
-            }
-        }
-
-        public void onPause() {
-            synchronized (sGLThreadManager) {
-                if (LOG_PAUSE_RESUME) {
-                    Log.i("GLThread", "onPause tid=" + getId());
-                }
-                mRequestPaused = true;
-                sGLThreadManager.notifyAll();
-                while ((! mExited) && (! mPaused)) {
-                    if (LOG_PAUSE_RESUME) {
-                        Log.i("Main thread", "onPause waiting for mPaused.");
-                    }
-                    try {
-                        sGLThreadManager.wait();
-                    } catch (InterruptedException ex) {
-                        Thread.currentThread().interrupt();
-                    }
-                }
-            }
-        }
-
-        public void onResume() {
-            synchronized (sGLThreadManager) {
-                if (LOG_PAUSE_RESUME) {
-                    Log.i("GLThread", "onResume tid=" + getId());
-                }
-                mRequestPaused = false;
-                mRequestRender = true;
-                mRenderComplete = false;
-                sGLThreadManager.notifyAll();
-                while ((! mExited) && mPaused && (!mRenderComplete)) {
-                    if (LOG_PAUSE_RESUME) {
-                        Log.i("Main thread", "onResume waiting for !mPaused.");
-                    }
-                    try {
-                        sGLThreadManager.wait();
-                    } catch (InterruptedException ex) {
-                        Thread.currentThread().interrupt();
-                    }
-                }
-            }
-        }
-
-        public void onWindowResize(int w, int h) {
-            synchronized (sGLThreadManager) {
-                mWidth = w;
-                mHeight = h;
-                mSizeChanged = true;
-                mRequestRender = true;
-                mRenderComplete = false;
-
-                // If we are already on the GL thread, this means a client callback
-                // has caused reentrancy, for example via updating the SurfaceView parameters.
-                // We need to process the size change eventually though and update our EGLSurface.
-                // So we set the parameters and return so they can be processed on our
-                // next iteration.
-                if (Thread.currentThread() == this) {
-                    return;
-                }
-
-                sGLThreadManager.notifyAll();
-
-                // Wait for thread to react to resize and render a frame
-                while (! mExited && !mPaused && !mRenderComplete
-                        && ableToDraw()) {
-                    if (LOG_SURFACE) {
-                        Log.i("Main thread", "onWindowResize waiting for render complete from tid=" + getId());
-                    }
-                    try {
-                        sGLThreadManager.wait();
-                    } catch (InterruptedException ex) {
-                        Thread.currentThread().interrupt();
-                    }
-                }
-            }
-        }
-
-        public void requestExitAndWait() {
-            // don't call this from GLThread thread or it is a guaranteed
-            // deadlock!
-            synchronized(sGLThreadManager) {
-                mShouldExit = true;
-                sGLThreadManager.notifyAll();
-                while (! mExited) {
-                    try {
-                        sGLThreadManager.wait();
-                    } catch (InterruptedException ex) {
-                        Thread.currentThread().interrupt();
-                    }
-                }
-            }
-        }
-
-        public void requestReleaseEglContextLocked() {
-            mShouldReleaseEglContext = true;
-            sGLThreadManager.notifyAll();
-        }
-
-        /**
-         * Queue an "event" to be run on the GL rendering thread.
-         * @param r the runnable to be run on the GL rendering thread.
-         */
-        public void queueEvent(Runnable r) {
-            if (r == null) {
-                throw new IllegalArgumentException("r must not be null");
-            }
-            synchronized(sGLThreadManager) {
-                mEventQueue.add(r);
-                sGLThreadManager.notifyAll();
-            }
-        }
-
-        // Once the thread is started, all accesses to the following member
-        // variables are protected by the sGLThreadManager monitor
-        private boolean mShouldExit;
-        private boolean mExited;
-        private boolean mRequestPaused;
-        private boolean mPaused;
-        private boolean mHasSurface;
-        private boolean mSurfaceIsBad;
-        private boolean mWaitingForSurface;
-        private boolean mHaveEglContext;
-        private boolean mHaveEglSurface;
-        private boolean mFinishedCreatingEglSurface;
-        private boolean mShouldReleaseEglContext;
-        private int mWidth;
-        private int mHeight;
-        private int mRenderMode;
-        private boolean mRequestRender;
-        private boolean mWantRenderNotification;
-        private boolean mRenderComplete;
-        private ArrayList<Runnable> mEventQueue = new ArrayList<Runnable>();
-        private boolean mSizeChanged = true;
-
-        // End of member variables protected by the sGLThreadManager monitor.
-
-        private EglHelper mEglHelper;
-
-        /**
-         * Set once at thread construction time, nulled out when the parent view is garbage
-         * called. This weak reference allows the GLSurfaceView to be garbage collected while
-         * the GLThread is still alive.
-         */
-        private WeakReference<GLSurfaceView> mGLSurfaceViewWeakRef;
-
-    }
-
-    static class LogWriter extends Writer {
-
-        @Override public void close() {
-            flushBuilder();
-        }
-
-        @Override public void flush() {
-            flushBuilder();
-        }
-
-        @Override public void write(char[] buf, int offset, int count) {
-            for(int i = 0; i < count; i++) {
-                char c = buf[offset + i];
-                if ( c == '\n') {
-                    flushBuilder();
-                }
-                else {
-                    mBuilder.append(c);
-                }
-            }
-        }
-
-        private void flushBuilder() {
-            if (mBuilder.length() > 0) {
-                Log.v("GLSurfaceView", mBuilder.toString());
-                mBuilder.delete(0, mBuilder.length());
-            }
-        }
-
-        private StringBuilder mBuilder = new StringBuilder();
-    }
-
-
-    private void checkRenderThreadState() {
-        if (mGLThread != null) {
-            throw new IllegalStateException(
-                    "setRenderer has already been called for this instance.");
-        }
-    }
-
-    private static class GLThreadManager {
-        private static String TAG = "GLThreadManager";
-
-        public synchronized void threadExiting(GLThread thread) {
-            if (LOG_THREADS) {
-                Log.i("GLThread", "exiting tid=" +  thread.getId());
-            }
-            thread.mExited = true;
-            notifyAll();
-        }
-
-        /*
-         * Releases the EGL context. Requires that we are already in the
-         * sGLThreadManager monitor when this is called.
-         */
-        public void releaseEglContextLocked(GLThread thread) {
-            notifyAll();
-        }
-    }
-
-    private static final GLThreadManager sGLThreadManager = new GLThreadManager();
-
-    private final WeakReference<GLSurfaceView> mThisWeakRef =
-            new WeakReference<GLSurfaceView>(this);
-    private GLThread mGLThread;
-    private Renderer mRenderer;
-    private boolean mDetached;
-    private EGLConfigChooser mEGLConfigChooser;
-    private EGLContextFactory mEGLContextFactory;
-    private EGLWindowSurfaceFactory mEGLWindowSurfaceFactory;
-    private GLWrapper mGLWrapper;
-    private int mDebugFlags;
-    private int mEGLContextClientVersion;
-    private boolean mPreserveEGLContextOnPause;
-}
diff -Naur frameworksRaw/base/opengl/java/android/opengl/GLSurfaceView.java.orig.orig.rej frameworksModified/base/opengl/java/android/opengl/GLSurfaceView.java.orig.orig.rej
--- frameworksRaw/base/opengl/java/android/opengl/GLSurfaceView.java.orig.orig.rej	2017-07-06 15:34:15.994008589 +0530
+++ frameworksModified/base/opengl/java/android/opengl/GLSurfaceView.java.orig.orig.rej	1970-01-01 05:30:00.000000000 +0530
@@ -1,1915 +0,0 @@
---- base/opengl/java/android/opengl/GLSurfaceView.java.orig.orig	1970-01-01 05:30:00.000000000 +0530
-+++ base/opengl/java/android/opengl/GLSurfaceView.java.orig.orig	2017-07-06 13:50:03.699303553 +0530
-@@ -0,0 +1,1912 @@
-+/*
-+ * Copyright (C) 2008 The Android Open Source Project
-+ *
-+ * Licensed under the Apache License, Version 2.0 (the "License");
-+ * you may not use this file except in compliance with the License.
-+ * You may obtain a copy of the License at
-+ *
-+ *      http://www.apache.org/licenses/LICENSE-2.0
-+ *
-+ * Unless required by applicable law or agreed to in writing, software
-+ * distributed under the License is distributed on an "AS IS" BASIS,
-+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-+ * See the License for the specific language governing permissions and
-+ * limitations under the License.
-+ */
-+
-+package android.opengl;
-+
-+import android.content.Context;
-+import android.os.Trace;
-+import android.util.AttributeSet;
-+import android.util.Log;
-+import android.view.SurfaceHolder;
-+import android.view.SurfaceView;
-+
-+import java.io.Writer;
-+import java.lang.ref.WeakReference;
-+import java.util.ArrayList;
-+
-+import javax.microedition.khronos.egl.EGL10;
-+import javax.microedition.khronos.egl.EGL11;
-+import javax.microedition.khronos.egl.EGLConfig;
-+import javax.microedition.khronos.egl.EGLContext;
-+import javax.microedition.khronos.egl.EGLDisplay;
-+import javax.microedition.khronos.egl.EGLSurface;
-+import javax.microedition.khronos.opengles.GL;
-+import javax.microedition.khronos.opengles.GL10;
-+
-+/**
-+ * An implementation of SurfaceView that uses the dedicated surface for
-+ * displaying OpenGL rendering.
-+ * <p>
-+ * A GLSurfaceView provides the following features:
-+ * <p>
-+ * <ul>
-+ * <li>Manages a surface, which is a special piece of memory that can be
-+ * composited into the Android view system.
-+ * <li>Manages an EGL display, which enables OpenGL to render into a surface.
-+ * <li>Accepts a user-provided Renderer object that does the actual rendering.
-+ * <li>Renders on a dedicated thread to decouple rendering performance from the
-+ * UI thread.
-+ * <li>Supports both on-demand and continuous rendering.
-+ * <li>Optionally wraps, traces, and/or error-checks the renderer's OpenGL calls.
-+ * </ul>
-+ *
-+ * <div class="special reference">
-+ * <h3>Developer Guides</h3>
-+ * <p>For more information about how to use OpenGL, read the
-+ * <a href="{@docRoot}guide/topics/graphics/opengl.html">OpenGL</a> developer guide.</p>
-+ * </div>
-+ *
-+ * <h3>Using GLSurfaceView</h3>
-+ * <p>
-+ * Typically you use GLSurfaceView by subclassing it and overriding one or more of the
-+ * View system input event methods. If your application does not need to override event
-+ * methods then GLSurfaceView can be used as-is. For the most part
-+ * GLSurfaceView behavior is customized by calling "set" methods rather than by subclassing.
-+ * For example, unlike a regular View, drawing is delegated to a separate Renderer object which
-+ * is registered with the GLSurfaceView
-+ * using the {@link #setRenderer(Renderer)} call.
-+ * <p>
-+ * <h3>Initializing GLSurfaceView</h3>
-+ * All you have to do to initialize a GLSurfaceView is call {@link #setRenderer(Renderer)}.
-+ * However, if desired, you can modify the default behavior of GLSurfaceView by calling one or
-+ * more of these methods before calling setRenderer:
-+ * <ul>
-+ * <li>{@link #setDebugFlags(int)}
-+ * <li>{@link #setEGLConfigChooser(boolean)}
-+ * <li>{@link #setEGLConfigChooser(EGLConfigChooser)}
-+ * <li>{@link #setEGLConfigChooser(int, int, int, int, int, int)}
-+ * <li>{@link #setGLWrapper(GLWrapper)}
-+ * </ul>
-+ * <p>
-+ * <h4>Specifying the android.view.Surface</h4>
-+ * By default GLSurfaceView will create a PixelFormat.RGB_888 format surface. If a translucent
-+ * surface is required, call getHolder().setFormat(PixelFormat.TRANSLUCENT).
-+ * The exact format of a TRANSLUCENT surface is device dependent, but it will be
-+ * a 32-bit-per-pixel surface with 8 bits per component.
-+ * <p>
-+ * <h4>Choosing an EGL Configuration</h4>
-+ * A given Android device may support multiple EGLConfig rendering configurations.
-+ * The available configurations may differ in how may channels of data are present, as
-+ * well as how many bits are allocated to each channel. Therefore, the first thing
-+ * GLSurfaceView has to do when starting to render is choose what EGLConfig to use.
-+ * <p>
-+ * By default GLSurfaceView chooses a EGLConfig that has an RGB_888 pixel format,
-+ * with at least a 16-bit depth buffer and no stencil.
-+ * <p>
-+ * If you would prefer a different EGLConfig
-+ * you can override the default behavior by calling one of the
-+ * setEGLConfigChooser methods.
-+ * <p>
-+ * <h4>Debug Behavior</h4>
-+ * You can optionally modify the behavior of GLSurfaceView by calling
-+ * one or more of the debugging methods {@link #setDebugFlags(int)},
-+ * and {@link #setGLWrapper}. These methods may be called before and/or after setRenderer, but
-+ * typically they are called before setRenderer so that they take effect immediately.
-+ * <p>
-+ * <h4>Setting a Renderer</h4>
-+ * Finally, you must call {@link #setRenderer} to register a {@link Renderer}.
-+ * The renderer is
-+ * responsible for doing the actual OpenGL rendering.
-+ * <p>
-+ * <h3>Rendering Mode</h3>
-+ * Once the renderer is set, you can control whether the renderer draws
-+ * continuously or on-demand by calling
-+ * {@link #setRenderMode}. The default is continuous rendering.
-+ * <p>
-+ * <h3>Activity Life-cycle</h3>
-+ * A GLSurfaceView must be notified when to pause and resume rendering. GLSurfaceView clients
-+ * are required to call {@link #onPause()} when the activity stops and
-+ * {@link #onResume()} when the activity starts. These calls allow GLSurfaceView to
-+ * pause and resume the rendering thread, and also allow GLSurfaceView to release and recreate
-+ * the OpenGL display.
-+ * <p>
-+ * <h3>Handling events</h3>
-+ * <p>
-+ * To handle an event you will typically subclass GLSurfaceView and override the
-+ * appropriate method, just as you would with any other View. However, when handling
-+ * the event, you may need to communicate with the Renderer object
-+ * that's running in the rendering thread. You can do this using any
-+ * standard Java cross-thread communication mechanism. In addition,
-+ * one relatively easy way to communicate with your renderer is
-+ * to call
-+ * {@link #queueEvent(Runnable)}. For example:
-+ * <pre class="prettyprint">
-+ * class MyGLSurfaceView extends GLSurfaceView {
-+ *
-+ *     private MyRenderer mMyRenderer;
-+ *
-+ *     public void start() {
-+ *         mMyRenderer = ...;
-+ *         setRenderer(mMyRenderer);
-+ *     }
-+ *
-+ *     public boolean onKeyDown(int keyCode, KeyEvent event) {
-+ *         if (keyCode == KeyEvent.KEYCODE_DPAD_CENTER) {
-+ *             queueEvent(new Runnable() {
-+ *                 // This method will be called on the rendering
-+ *                 // thread:
-+ *                 public void run() {
-+ *                     mMyRenderer.handleDpadCenter();
-+ *                 }});
-+ *             return true;
-+ *         }
-+ *         return super.onKeyDown(keyCode, event);
-+ *     }
-+ * }
-+ * </pre>
-+ *
-+ */
-+public class GLSurfaceView extends SurfaceView implements SurfaceHolder.Callback2 {
-+    private final static String TAG = "GLSurfaceView";
-+    private final static boolean LOG_ATTACH_DETACH = false;
-+    private final static boolean LOG_THREADS = false;
-+    private final static boolean LOG_PAUSE_RESUME = false;
-+    private final static boolean LOG_SURFACE = false;
-+    private final static boolean LOG_RENDERER = false;
-+    private final static boolean LOG_RENDERER_DRAW_FRAME = false;
-+    private final static boolean LOG_EGL = false;
-+    /**
-+     * The renderer only renders
-+     * when the surface is created, or when {@link #requestRender} is called.
-+     *
-+     * @see #getRenderMode()
-+     * @see #setRenderMode(int)
-+     * @see #requestRender()
-+     */
-+    public final static int RENDERMODE_WHEN_DIRTY = 0;
-+    /**
-+     * The renderer is called
-+     * continuously to re-render the scene.
-+     *
-+     * @see #getRenderMode()
-+     * @see #setRenderMode(int)
-+     */
-+    public final static int RENDERMODE_CONTINUOUSLY = 1;
-+
-+    /**
-+     * Check glError() after every GL call and throw an exception if glError indicates
-+     * that an error has occurred. This can be used to help track down which OpenGL ES call
-+     * is causing an error.
-+     *
-+     * @see #getDebugFlags
-+     * @see #setDebugFlags
-+     */
-+    public final static int DEBUG_CHECK_GL_ERROR = 1;
-+
-+    /**
-+     * Log GL calls to the system log at "verbose" level with tag "GLSurfaceView".
-+     *
-+     * @see #getDebugFlags
-+     * @see #setDebugFlags
-+     */
-+    public final static int DEBUG_LOG_GL_CALLS = 2;
-+
-+    /**
-+     * Standard View constructor. In order to render something, you
-+     * must call {@link #setRenderer} to register a renderer.
-+     */
-+    public GLSurfaceView(Context context) {
-+        super(context);
-+        init();
-+    }
-+
-+    /**
-+     * Standard View constructor. In order to render something, you
-+     * must call {@link #setRenderer} to register a renderer.
-+     */
-+    public GLSurfaceView(Context context, AttributeSet attrs) {
-+        super(context, attrs);
-+        init();
-+    }
-+
-+    @Override
-+    protected void finalize() throws Throwable {
-+        try {
-+            if (mGLThread != null) {
-+                // GLThread may still be running if this view was never
-+                // attached to a window.
-+                mGLThread.requestExitAndWait();
-+            }
-+        } finally {
-+            super.finalize();
-+        }
-+    }
-+
-+    private void init() {
-+        // Install a SurfaceHolder.Callback so we get notified when the
-+        // underlying surface is created and destroyed
-+        SurfaceHolder holder = getHolder();
-+        holder.addCallback(this);
-+        // setFormat is done by SurfaceView in SDK 2.3 and newer. Uncomment
-+        // this statement if back-porting to 2.2 or older:
-+        // holder.setFormat(PixelFormat.RGB_565);
-+        //
-+        // setType is not needed for SDK 2.0 or newer. Uncomment this
-+        // statement if back-porting this code to older SDKs.
-+        // holder.setType(SurfaceHolder.SURFACE_TYPE_GPU);
-+    }
-+
-+    /**
-+     * Set the glWrapper. If the glWrapper is not null, its
-+     * {@link GLWrapper#wrap(GL)} method is called
-+     * whenever a surface is created. A GLWrapper can be used to wrap
-+     * the GL object that's passed to the renderer. Wrapping a GL
-+     * object enables examining and modifying the behavior of the
-+     * GL calls made by the renderer.
-+     * <p>
-+     * Wrapping is typically used for debugging purposes.
-+     * <p>
-+     * The default value is null.
-+     * @param glWrapper the new GLWrapper
-+     */
-+    public void setGLWrapper(GLWrapper glWrapper) {
-+        mGLWrapper = glWrapper;
-+    }
-+
-+    /**
-+     * Set the debug flags to a new value. The value is
-+     * constructed by OR-together zero or more
-+     * of the DEBUG_CHECK_* constants. The debug flags take effect
-+     * whenever a surface is created. The default value is zero.
-+     * @param debugFlags the new debug flags
-+     * @see #DEBUG_CHECK_GL_ERROR
-+     * @see #DEBUG_LOG_GL_CALLS
-+     */
-+    public void setDebugFlags(int debugFlags) {
-+        mDebugFlags = debugFlags;
-+    }
-+
-+    /**
-+     * Get the current value of the debug flags.
-+     * @return the current value of the debug flags.
-+     */
-+    public int getDebugFlags() {
-+        return mDebugFlags;
-+    }
-+
-+    /**
-+     * Control whether the EGL context is preserved when the GLSurfaceView is paused and
-+     * resumed.
-+     * <p>
-+     * If set to true, then the EGL context may be preserved when the GLSurfaceView is paused.
-+     * <p>
-+     * Prior to API level 11, whether the EGL context is actually preserved or not
-+     * depends upon whether the Android device can support an arbitrary number of
-+     * EGL contexts or not. Devices that can only support a limited number of EGL
-+     * contexts must release the EGL context in order to allow multiple applications
-+     * to share the GPU.
-+     * <p>
-+     * If set to false, the EGL context will be released when the GLSurfaceView is paused,
-+     * and recreated when the GLSurfaceView is resumed.
-+     * <p>
-+     *
-+     * The default is false.
-+     *
-+     * @param preserveOnPause preserve the EGL context when paused
-+     */
-+    public void setPreserveEGLContextOnPause(boolean preserveOnPause) {
-+        mPreserveEGLContextOnPause = preserveOnPause;
-+    }
-+
-+    /**
-+     * @return true if the EGL context will be preserved when paused
-+     */
-+    public boolean getPreserveEGLContextOnPause() {
-+        return mPreserveEGLContextOnPause;
-+    }
-+
-+    /**
-+     * Set the renderer associated with this view. Also starts the thread that
-+     * will call the renderer, which in turn causes the rendering to start.
-+     * <p>This method should be called once and only once in the life-cycle of
-+     * a GLSurfaceView.
-+     * <p>The following GLSurfaceView methods can only be called <em>before</em>
-+     * setRenderer is called:
-+     * <ul>
-+     * <li>{@link #setEGLConfigChooser(boolean)}
-+     * <li>{@link #setEGLConfigChooser(EGLConfigChooser)}
-+     * <li>{@link #setEGLConfigChooser(int, int, int, int, int, int)}
-+     * </ul>
-+     * <p>
-+     * The following GLSurfaceView methods can only be called <em>after</em>
-+     * setRenderer is called:
-+     * <ul>
-+     * <li>{@link #getRenderMode()}
-+     * <li>{@link #onPause()}
-+     * <li>{@link #onResume()}
-+     * <li>{@link #queueEvent(Runnable)}
-+     * <li>{@link #requestRender()}
-+     * <li>{@link #setRenderMode(int)}
-+     * </ul>
-+     *
-+     * @param renderer the renderer to use to perform OpenGL drawing.
-+     */
-+    public void setRenderer(Renderer renderer) {
-+        checkRenderThreadState();
-+        if (mEGLConfigChooser == null) {
-+            mEGLConfigChooser = new SimpleEGLConfigChooser(true);
-+        }
-+        if (mEGLContextFactory == null) {
-+            mEGLContextFactory = new DefaultContextFactory();
-+        }
-+        if (mEGLWindowSurfaceFactory == null) {
-+            mEGLWindowSurfaceFactory = new DefaultWindowSurfaceFactory();
-+        }
-+        mRenderer = renderer;
-+        mGLThread = new GLThread(mThisWeakRef);
-+        mGLThread.start();
-+    }
-+
-+    /**
-+     * Install a custom EGLContextFactory.
-+     * <p>If this method is
-+     * called, it must be called before {@link #setRenderer(Renderer)}
-+     * is called.
-+     * <p>
-+     * If this method is not called, then by default
-+     * a context will be created with no shared context and
-+     * with a null attribute list.
-+     */
-+    public void setEGLContextFactory(EGLContextFactory factory) {
-+        checkRenderThreadState();
-+        mEGLContextFactory = factory;
-+    }
-+
-+    /**
-+     * Install a custom EGLWindowSurfaceFactory.
-+     * <p>If this method is
-+     * called, it must be called before {@link #setRenderer(Renderer)}
-+     * is called.
-+     * <p>
-+     * If this method is not called, then by default
-+     * a window surface will be created with a null attribute list.
-+     */
-+    public void setEGLWindowSurfaceFactory(EGLWindowSurfaceFactory factory) {
-+        checkRenderThreadState();
-+        mEGLWindowSurfaceFactory = factory;
-+    }
-+
-+    /**
-+     * Install a custom EGLConfigChooser.
-+     * <p>If this method is
-+     * called, it must be called before {@link #setRenderer(Renderer)}
-+     * is called.
-+     * <p>
-+     * If no setEGLConfigChooser method is called, then by default the
-+     * view will choose an EGLConfig that is compatible with the current
-+     * android.view.Surface, with a depth buffer depth of
-+     * at least 16 bits.
-+     * @param configChooser
-+     */
-+    public void setEGLConfigChooser(EGLConfigChooser configChooser) {
-+        checkRenderThreadState();
-+        mEGLConfigChooser = configChooser;
-+    }
-+
-+    /**
-+     * Install a config chooser which will choose a config
-+     * as close to 16-bit RGB as possible, with or without an optional depth
-+     * buffer as close to 16-bits as possible.
-+     * <p>If this method is
-+     * called, it must be called before {@link #setRenderer(Renderer)}
-+     * is called.
-+     * <p>
-+     * If no setEGLConfigChooser method is called, then by default the
-+     * view will choose an RGB_888 surface with a depth buffer depth of
-+     * at least 16 bits.
-+     *
-+     * @param needDepth
-+     */
-+    public void setEGLConfigChooser(boolean needDepth) {
-+        setEGLConfigChooser(new SimpleEGLConfigChooser(needDepth));
-+    }
-+
-+    /**
-+     * Install a config chooser which will choose a config
-+     * with at least the specified depthSize and stencilSize,
-+     * and exactly the specified redSize, greenSize, blueSize and alphaSize.
-+     * <p>If this method is
-+     * called, it must be called before {@link #setRenderer(Renderer)}
-+     * is called.
-+     * <p>
-+     * If no setEGLConfigChooser method is called, then by default the
-+     * view will choose an RGB_888 surface with a depth buffer depth of
-+     * at least 16 bits.
-+     *
-+     */
-+    public void setEGLConfigChooser(int redSize, int greenSize, int blueSize,
-+            int alphaSize, int depthSize, int stencilSize) {
-+        setEGLConfigChooser(new ComponentSizeChooser(redSize, greenSize,
-+                blueSize, alphaSize, depthSize, stencilSize));
-+    }
-+
-+    /**
-+     * Inform the default EGLContextFactory and default EGLConfigChooser
-+     * which EGLContext client version to pick.
-+     * <p>Use this method to create an OpenGL ES 2.0-compatible context.
-+     * Example:
-+     * <pre class="prettyprint">
-+     *     public MyView(Context context) {
-+     *         super(context);
-+     *         setEGLContextClientVersion(2); // Pick an OpenGL ES 2.0 context.
-+     *         setRenderer(new MyRenderer());
-+     *     }
-+     * </pre>
-+     * <p>Note: Activities which require OpenGL ES 2.0 should indicate this by
-+     * setting @lt;uses-feature android:glEsVersion="0x00020000" /> in the activity's
-+     * AndroidManifest.xml file.
-+     * <p>If this method is called, it must be called before {@link #setRenderer(Renderer)}
-+     * is called.
-+     * <p>This method only affects the behavior of the default EGLContexFactory and the
-+     * default EGLConfigChooser. If
-+     * {@link #setEGLContextFactory(EGLContextFactory)} has been called, then the supplied
-+     * EGLContextFactory is responsible for creating an OpenGL ES 2.0-compatible context.
-+     * If
-+     * {@link #setEGLConfigChooser(EGLConfigChooser)} has been called, then the supplied
-+     * EGLConfigChooser is responsible for choosing an OpenGL ES 2.0-compatible config.
-+     * @param version The EGLContext client version to choose. Use 2 for OpenGL ES 2.0
-+     */
-+    public void setEGLContextClientVersion(int version) {
-+        checkRenderThreadState();
-+        mEGLContextClientVersion = version;
-+    }
-+
-+    /**
-+     * Set the rendering mode. When renderMode is
-+     * RENDERMODE_CONTINUOUSLY, the renderer is called
-+     * repeatedly to re-render the scene. When renderMode
-+     * is RENDERMODE_WHEN_DIRTY, the renderer only rendered when the surface
-+     * is created, or when {@link #requestRender} is called. Defaults to RENDERMODE_CONTINUOUSLY.
-+     * <p>
-+     * Using RENDERMODE_WHEN_DIRTY can improve battery life and overall system performance
-+     * by allowing the GPU and CPU to idle when the view does not need to be updated.
-+     * <p>
-+     * This method can only be called after {@link #setRenderer(Renderer)}
-+     *
-+     * @param renderMode one of the RENDERMODE_X constants
-+     * @see #RENDERMODE_CONTINUOUSLY
-+     * @see #RENDERMODE_WHEN_DIRTY
-+     */
-+    public void setRenderMode(int renderMode) {
-+        mGLThread.setRenderMode(renderMode);
-+    }
-+
-+    /**
-+     * Get the current rendering mode. May be called
-+     * from any thread. Must not be called before a renderer has been set.
-+     * @return the current rendering mode.
-+     * @see #RENDERMODE_CONTINUOUSLY
-+     * @see #RENDERMODE_WHEN_DIRTY
-+     */
-+    public int getRenderMode() {
-+        return mGLThread.getRenderMode();
-+    }
-+
-+    /**
-+     * Request that the renderer render a frame.
-+     * This method is typically used when the render mode has been set to
-+     * {@link #RENDERMODE_WHEN_DIRTY}, so that frames are only rendered on demand.
-+     * May be called
-+     * from any thread. Must not be called before a renderer has been set.
-+     */
-+    public void requestRender() {
-+        mGLThread.requestRender();
-+    }
-+
-+    /**
-+     * This method is part of the SurfaceHolder.Callback interface, and is
-+     * not normally called or subclassed by clients of GLSurfaceView.
-+     */
-+    public void surfaceCreated(SurfaceHolder holder) {
-+        mGLThread.surfaceCreated();
-+    }
-+
-+    /**
-+     * This method is part of the SurfaceHolder.Callback interface, and is
-+     * not normally called or subclassed by clients of GLSurfaceView.
-+     */
-+    public void surfaceDestroyed(SurfaceHolder holder) {
-+        // Surface will be destroyed when we return
-+        mGLThread.surfaceDestroyed();
-+    }
-+
-+    /**
-+     * This method is part of the SurfaceHolder.Callback interface, and is
-+     * not normally called or subclassed by clients of GLSurfaceView.
-+     */
-+    public void surfaceChanged(SurfaceHolder holder, int format, int w, int h) {
-+        mGLThread.onWindowResize(w, h);
-+    }
-+
-+    /**
-+     * This method is part of the SurfaceHolder.Callback interface, and is
-+     * not normally called or subclassed by clients of GLSurfaceView.
-+     */
-+    @Override
-+    public void surfaceRedrawNeeded(SurfaceHolder holder) {
-+        if (mGLThread != null) {
-+            mGLThread.requestRenderAndWait();
-+        }
-+    }
-+
-+
-+    /**
-+     * Pause the rendering thread, optionally tearing down the EGL context
-+     * depending upon the value of {@link #setPreserveEGLContextOnPause(boolean)}.
-+     *
-+     * This method should be called when it is no longer desirable for the
-+     * GLSurfaceView to continue rendering, such as in response to
-+     * {@link android.app.Activity#onStop Activity.onStop}.
-+     *
-+     * Must not be called before a renderer has been set.
-+     */
-+    public void onPause() {
-+        mGLThread.onPause();
-+    }
-+
-+    /**
-+     * Resumes the rendering thread, re-creating the OpenGL context if necessary. It
-+     * is the counterpart to {@link #onPause()}.
-+     *
-+     * This method should typically be called in
-+     * {@link android.app.Activity#onStart Activity.onStart}.
-+     *
-+     * Must not be called before a renderer has been set.
-+     */
-+    public void onResume() {
-+        mGLThread.onResume();
-+    }
-+
-+    /**
-+     * Queue a runnable to be run on the GL rendering thread. This can be used
-+     * to communicate with the Renderer on the rendering thread.
-+     * Must not be called before a renderer has been set.
-+     * @param r the runnable to be run on the GL rendering thread.
-+     */
-+    public void queueEvent(Runnable r) {
-+        mGLThread.queueEvent(r);
-+    }
-+
-+    /**
-+     * This method is used as part of the View class and is not normally
-+     * called or subclassed by clients of GLSurfaceView.
-+     */
-+    @Override
-+    protected void onAttachedToWindow() {
-+        super.onAttachedToWindow();
-+        if (LOG_ATTACH_DETACH) {
-+            Log.d(TAG, "onAttachedToWindow reattach =" + mDetached);
-+        }
-+        if (mDetached && (mRenderer != null)) {
-+            int renderMode = RENDERMODE_CONTINUOUSLY;
-+            if (mGLThread != null) {
-+                renderMode = mGLThread.getRenderMode();
-+            }
-+            mGLThread = new GLThread(mThisWeakRef);
-+            if (renderMode != RENDERMODE_CONTINUOUSLY) {
-+                mGLThread.setRenderMode(renderMode);
-+            }
-+            mGLThread.start();
-+        }
-+        mDetached = false;
-+    }
-+
-+    @Override
-+    protected void onDetachedFromWindow() {
-+        if (LOG_ATTACH_DETACH) {
-+            Log.d(TAG, "onDetachedFromWindow");
-+        }
-+        if (mGLThread != null) {
-+            mGLThread.requestExitAndWait();
-+        }
-+        mDetached = true;
-+        super.onDetachedFromWindow();
-+    }
-+
-+    // ----------------------------------------------------------------------
-+
-+    /**
-+     * An interface used to wrap a GL interface.
-+     * <p>Typically
-+     * used for implementing debugging and tracing on top of the default
-+     * GL interface. You would typically use this by creating your own class
-+     * that implemented all the GL methods by delegating to another GL instance.
-+     * Then you could add your own behavior before or after calling the
-+     * delegate. All the GLWrapper would do was instantiate and return the
-+     * wrapper GL instance:
-+     * <pre class="prettyprint">
-+     * class MyGLWrapper implements GLWrapper {
-+     *     GL wrap(GL gl) {
-+     *         return new MyGLImplementation(gl);
-+     *     }
-+     *     static class MyGLImplementation implements GL,GL10,GL11,... {
-+     *         ...
-+     *     }
-+     * }
-+     * </pre>
-+     * @see #setGLWrapper(GLWrapper)
-+     */
-+    public interface GLWrapper {
-+        /**
-+         * Wraps a gl interface in another gl interface.
-+         * @param gl a GL interface that is to be wrapped.
-+         * @return either the input argument or another GL object that wraps the input argument.
-+         */
-+        GL wrap(GL gl);
-+    }
-+
-+    /**
-+     * A generic renderer interface.
-+     * <p>
-+     * The renderer is responsible for making OpenGL calls to render a frame.
-+     * <p>
-+     * GLSurfaceView clients typically create their own classes that implement
-+     * this interface, and then call {@link GLSurfaceView#setRenderer} to
-+     * register the renderer with the GLSurfaceView.
-+     * <p>
-+     *
-+     * <div class="special reference">
-+     * <h3>Developer Guides</h3>
-+     * <p>For more information about how to use OpenGL, read the
-+     * <a href="{@docRoot}guide/topics/graphics/opengl.html">OpenGL</a> developer guide.</p>
-+     * </div>
-+     *
-+     * <h3>Threading</h3>
-+     * The renderer will be called on a separate thread, so that rendering
-+     * performance is decoupled from the UI thread. Clients typically need to
-+     * communicate with the renderer from the UI thread, because that's where
-+     * input events are received. Clients can communicate using any of the
-+     * standard Java techniques for cross-thread communication, or they can
-+     * use the {@link GLSurfaceView#queueEvent(Runnable)} convenience method.
-+     * <p>
-+     * <h3>EGL Context Lost</h3>
-+     * There are situations where the EGL rendering context will be lost. This
-+     * typically happens when device wakes up after going to sleep. When
-+     * the EGL context is lost, all OpenGL resources (such as textures) that are
-+     * associated with that context will be automatically deleted. In order to
-+     * keep rendering correctly, a renderer must recreate any lost resources
-+     * that it still needs. The {@link #onSurfaceCreated(GL10, EGLConfig)} method
-+     * is a convenient place to do this.
-+     *
-+     *
-+     * @see #setRenderer(Renderer)
-+     */
-+    public interface Renderer {
-+        /**
-+         * Called when the surface is created or recreated.
-+         * <p>
-+         * Called when the rendering thread
-+         * starts and whenever the EGL context is lost. The EGL context will typically
-+         * be lost when the Android device awakes after going to sleep.
-+         * <p>
-+         * Since this method is called at the beginning of rendering, as well as
-+         * every time the EGL context is lost, this method is a convenient place to put
-+         * code to create resources that need to be created when the rendering
-+         * starts, and that need to be recreated when the EGL context is lost.
-+         * Textures are an example of a resource that you might want to create
-+         * here.
-+         * <p>
-+         * Note that when the EGL context is lost, all OpenGL resources associated
-+         * with that context will be automatically deleted. You do not need to call
-+         * the corresponding "glDelete" methods such as glDeleteTextures to
-+         * manually delete these lost resources.
-+         * <p>
-+         * @param gl the GL interface. Use <code>instanceof</code> to
-+         * test if the interface supports GL11 or higher interfaces.
-+         * @param config the EGLConfig of the created surface. Can be used
-+         * to create matching pbuffers.
-+         */
-+        void onSurfaceCreated(GL10 gl, EGLConfig config);
-+
-+        /**
-+         * Called when the surface changed size.
-+         * <p>
-+         * Called after the surface is created and whenever
-+         * the OpenGL ES surface size changes.
-+         * <p>
-+         * Typically you will set your viewport here. If your camera
-+         * is fixed then you could also set your projection matrix here:
-+         * <pre class="prettyprint">
-+         * void onSurfaceChanged(GL10 gl, int width, int height) {
-+         *     gl.glViewport(0, 0, width, height);
-+         *     // for a fixed camera, set the projection too
-+         *     float ratio = (float) width / height;
-+         *     gl.glMatrixMode(GL10.GL_PROJECTION);
-+         *     gl.glLoadIdentity();
-+         *     gl.glFrustumf(-ratio, ratio, -1, 1, 1, 10);
-+         * }
-+         * </pre>
-+         * @param gl the GL interface. Use <code>instanceof</code> to
-+         * test if the interface supports GL11 or higher interfaces.
-+         * @param width
-+         * @param height
-+         */
-+        void onSurfaceChanged(GL10 gl, int width, int height);
-+
-+        /**
-+         * Called to draw the current frame.
-+         * <p>
-+         * This method is responsible for drawing the current frame.
-+         * <p>
-+         * The implementation of this method typically looks like this:
-+         * <pre class="prettyprint">
-+         * void onDrawFrame(GL10 gl) {
-+         *     gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
-+         *     //... other gl calls to render the scene ...
-+         * }
-+         * </pre>
-+         * @param gl the GL interface. Use <code>instanceof</code> to
-+         * test if the interface supports GL11 or higher interfaces.
-+         */
-+        void onDrawFrame(GL10 gl);
-+    }
-+
-+    /**
-+     * An interface for customizing the eglCreateContext and eglDestroyContext calls.
-+     * <p>
-+     * This interface must be implemented by clients wishing to call
-+     * {@link GLSurfaceView#setEGLContextFactory(EGLContextFactory)}
-+     */
-+    public interface EGLContextFactory {
-+        EGLContext createContext(EGL10 egl, EGLDisplay display, EGLConfig eglConfig);
-+        void destroyContext(EGL10 egl, EGLDisplay display, EGLContext context);
-+    }
-+
-+    private class DefaultContextFactory implements EGLContextFactory {
-+        private int EGL_CONTEXT_CLIENT_VERSION = 0x3098;
-+
-+        public EGLContext createContext(EGL10 egl, EGLDisplay display, EGLConfig config) {
-+            int[] attrib_list = {EGL_CONTEXT_CLIENT_VERSION, mEGLContextClientVersion,
-+                    EGL10.EGL_NONE };
-+
-+            return egl.eglCreateContext(display, config, EGL10.EGL_NO_CONTEXT,
-+                    mEGLContextClientVersion != 0 ? attrib_list : null);
-+        }
-+
-+        public void destroyContext(EGL10 egl, EGLDisplay display,
-+                EGLContext context) {
-+            if (!egl.eglDestroyContext(display, context)) {
-+                Log.e("DefaultContextFactory", "display:" + display + " context: " + context);
-+                if (LOG_THREADS) {
-+                    Log.i("DefaultContextFactory", "tid=" + Thread.currentThread().getId());
-+                }
-+                EglHelper.throwEglException("eglDestroyContex", egl.eglGetError());
-+            }
-+        }
-+    }
-+
-+    /**
-+     * An interface for customizing the eglCreateWindowSurface and eglDestroySurface calls.
-+     * <p>
-+     * This interface must be implemented by clients wishing to call
-+     * {@link GLSurfaceView#setEGLWindowSurfaceFactory(EGLWindowSurfaceFactory)}
-+     */
-+    public interface EGLWindowSurfaceFactory {
-+        /**
-+         *  @return null if the surface cannot be constructed.
-+         */
-+        EGLSurface createWindowSurface(EGL10 egl, EGLDisplay display, EGLConfig config,
-+                Object nativeWindow);
-+        void destroySurface(EGL10 egl, EGLDisplay display, EGLSurface surface);
-+    }
-+
-+    private static class DefaultWindowSurfaceFactory implements EGLWindowSurfaceFactory {
-+
-+        public EGLSurface createWindowSurface(EGL10 egl, EGLDisplay display,
-+                EGLConfig config, Object nativeWindow) {
-+            EGLSurface result = null;
-+            try {
-+                result = egl.eglCreateWindowSurface(display, config, nativeWindow, null);
-+            } catch (IllegalArgumentException e) {
-+                // This exception indicates that the surface flinger surface
-+                // is not valid. This can happen if the surface flinger surface has
-+                // been torn down, but the application has not yet been
-+                // notified via SurfaceHolder.Callback.surfaceDestroyed.
-+                // In theory the application should be notified first,
-+                // but in practice sometimes it is not. See b/4588890
-+                Log.e(TAG, "eglCreateWindowSurface", e);
-+            }
-+            return result;
-+        }
-+
-+        public void destroySurface(EGL10 egl, EGLDisplay display,
-+                EGLSurface surface) {
-+            egl.eglDestroySurface(display, surface);
-+        }
-+    }
-+
-+    /**
-+     * An interface for choosing an EGLConfig configuration from a list of
-+     * potential configurations.
-+     * <p>
-+     * This interface must be implemented by clients wishing to call
-+     * {@link GLSurfaceView#setEGLConfigChooser(EGLConfigChooser)}
-+     */
-+    public interface EGLConfigChooser {
-+        /**
-+         * Choose a configuration from the list. Implementors typically
-+         * implement this method by calling
-+         * {@link EGL10#eglChooseConfig} and iterating through the results. Please consult the
-+         * EGL specification available from The Khronos Group to learn how to call eglChooseConfig.
-+         * @param egl the EGL10 for the current display.
-+         * @param display the current display.
-+         * @return the chosen configuration.
-+         */
-+        EGLConfig chooseConfig(EGL10 egl, EGLDisplay display);
-+    }
-+
-+    private abstract class BaseConfigChooser
-+            implements EGLConfigChooser {
-+        public BaseConfigChooser(int[] configSpec) {
-+            mConfigSpec = filterConfigSpec(configSpec);
-+        }
-+
-+        public EGLConfig chooseConfig(EGL10 egl, EGLDisplay display) {
-+            int[] num_config = new int[1];
-+            if (!egl.eglChooseConfig(display, mConfigSpec, null, 0,
-+                    num_config)) {
-+                throw new IllegalArgumentException("eglChooseConfig failed");
-+            }
-+
-+            int numConfigs = num_config[0];
-+
-+            if (numConfigs <= 0) {
-+                throw new IllegalArgumentException(
-+                        "No configs match configSpec");
-+            }
-+
-+            EGLConfig[] configs = new EGLConfig[numConfigs];
-+            if (!egl.eglChooseConfig(display, mConfigSpec, configs, numConfigs,
-+                    num_config)) {
-+                throw new IllegalArgumentException("eglChooseConfig#2 failed");
-+            }
-+            EGLConfig config = chooseConfig(egl, display, configs);
-+            if (config == null) {
-+                throw new IllegalArgumentException("No config chosen");
-+            }
-+            return config;
-+        }
-+
-+        abstract EGLConfig chooseConfig(EGL10 egl, EGLDisplay display,
-+                EGLConfig[] configs);
-+
-+        protected int[] mConfigSpec;
-+
-+        private int[] filterConfigSpec(int[] configSpec) {
-+            if (mEGLContextClientVersion != 2 && mEGLContextClientVersion != 3) {
-+                return configSpec;
-+            }
-+            /* We know none of the subclasses define EGL_RENDERABLE_TYPE.
-+             * And we know the configSpec is well formed.
-+             */
-+            int len = configSpec.length;
-+            int[] newConfigSpec = new int[len + 2];
-+            System.arraycopy(configSpec, 0, newConfigSpec, 0, len-1);
-+            newConfigSpec[len-1] = EGL10.EGL_RENDERABLE_TYPE;
-+            if (mEGLContextClientVersion == 2) {
-+                newConfigSpec[len] = EGL14.EGL_OPENGL_ES2_BIT;  /* EGL_OPENGL_ES2_BIT */
-+            } else {
-+                newConfigSpec[len] = EGLExt.EGL_OPENGL_ES3_BIT_KHR; /* EGL_OPENGL_ES3_BIT_KHR */
-+            }
-+            newConfigSpec[len+1] = EGL10.EGL_NONE;
-+            return newConfigSpec;
-+        }
-+    }
-+
-+    /**
-+     * Choose a configuration with exactly the specified r,g,b,a sizes,
-+     * and at least the specified depth and stencil sizes.
-+     */
-+    private class ComponentSizeChooser extends BaseConfigChooser {
-+        public ComponentSizeChooser(int redSize, int greenSize, int blueSize,
-+                int alphaSize, int depthSize, int stencilSize) {
-+            super(new int[] {
-+                    EGL10.EGL_RED_SIZE, redSize,
-+                    EGL10.EGL_GREEN_SIZE, greenSize,
-+                    EGL10.EGL_BLUE_SIZE, blueSize,
-+                    EGL10.EGL_ALPHA_SIZE, alphaSize,
-+                    EGL10.EGL_DEPTH_SIZE, depthSize,
-+                    EGL10.EGL_STENCIL_SIZE, stencilSize,
-+                    EGL10.EGL_NONE});
-+            mValue = new int[1];
-+            mRedSize = redSize;
-+            mGreenSize = greenSize;
-+            mBlueSize = blueSize;
-+            mAlphaSize = alphaSize;
-+            mDepthSize = depthSize;
-+            mStencilSize = stencilSize;
-+       }
-+
-+        @Override
-+        public EGLConfig chooseConfig(EGL10 egl, EGLDisplay display,
-+                EGLConfig[] configs) {
-+            for (EGLConfig config : configs) {
-+                int d = findConfigAttrib(egl, display, config,
-+                        EGL10.EGL_DEPTH_SIZE, 0);
-+                int s = findConfigAttrib(egl, display, config,
-+                        EGL10.EGL_STENCIL_SIZE, 0);
-+                if ((d >= mDepthSize) && (s >= mStencilSize)) {
-+                    int r = findConfigAttrib(egl, display, config,
-+                            EGL10.EGL_RED_SIZE, 0);
-+                    int g = findConfigAttrib(egl, display, config,
-+                             EGL10.EGL_GREEN_SIZE, 0);
-+                    int b = findConfigAttrib(egl, display, config,
-+                              EGL10.EGL_BLUE_SIZE, 0);
-+                    int a = findConfigAttrib(egl, display, config,
-+                            EGL10.EGL_ALPHA_SIZE, 0);
-+                    if ((r == mRedSize) && (g == mGreenSize)
-+                            && (b == mBlueSize) && (a == mAlphaSize)) {
-+                        return config;
-+                    }
-+                }
-+            }
-+            return null;
-+        }
-+
-+        private int findConfigAttrib(EGL10 egl, EGLDisplay display,
-+                EGLConfig config, int attribute, int defaultValue) {
-+
-+            if (egl.eglGetConfigAttrib(display, config, attribute, mValue)) {
-+                return mValue[0];
-+            }
-+            return defaultValue;
-+        }
-+
-+        private int[] mValue;
-+        // Subclasses can adjust these values:
-+        protected int mRedSize;
-+        protected int mGreenSize;
-+        protected int mBlueSize;
-+        protected int mAlphaSize;
-+        protected int mDepthSize;
-+        protected int mStencilSize;
-+        }
-+
-+    /**
-+     * This class will choose a RGB_888 surface with
-+     * or without a depth buffer.
-+     *
-+     */
-+    private class SimpleEGLConfigChooser extends ComponentSizeChooser {
-+        public SimpleEGLConfigChooser(boolean withDepthBuffer) {
-+            super(8, 8, 8, 0, withDepthBuffer ? 16 : 0, 0);
-+        }
-+    }
-+
-+    /**
-+     * An EGL helper class.
-+     */
-+
-+    private static class EglHelper {
-+        public EglHelper(WeakReference<GLSurfaceView> glSurfaceViewWeakRef) {
-+            mGLSurfaceViewWeakRef = glSurfaceViewWeakRef;
-+        }
-+
-+        /**
-+         * Initialize EGL for a given configuration spec.
-+         * @param configSpec
-+         */
-+        public void start() {
-+            if (LOG_EGL) {
-+                Log.w("EglHelper", "start() tid=" + Thread.currentThread().getId());
-+            }
-+            /*
-+             * Get an EGL instance
-+             */
-+            mEgl = (EGL10) EGLContext.getEGL();
-+
-+            /*
-+             * Get to the default display.
-+             */
-+            mEglDisplay = mEgl.eglGetDisplay(EGL10.EGL_DEFAULT_DISPLAY);
-+
-+            if (mEglDisplay == EGL10.EGL_NO_DISPLAY) {
-+                throw new RuntimeException("eglGetDisplay failed");
-+            }
-+
-+            /*
-+             * We can now initialize EGL for that display
-+             */
-+            int[] version = new int[2];
-+            if(!mEgl.eglInitialize(mEglDisplay, version)) {
-+                throw new RuntimeException("eglInitialize failed");
-+            }
-+            GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-+            if (view == null) {
-+                mEglConfig = null;
-+                mEglContext = null;
-+            } else {
-+                mEglConfig = view.mEGLConfigChooser.chooseConfig(mEgl, mEglDisplay);
-+
-+                /*
-+                * Create an EGL context. We want to do this as rarely as we can, because an
-+                * EGL context is a somewhat heavy object.
-+                */
-+                mEglContext = view.mEGLContextFactory.createContext(mEgl, mEglDisplay, mEglConfig);
-+            }
-+            if (mEglContext == null || mEglContext == EGL10.EGL_NO_CONTEXT) {
-+                mEglContext = null;
-+                throwEglException("createContext");
-+            }
-+            if (LOG_EGL) {
-+                Log.w("EglHelper", "createContext " + mEglContext + " tid=" + Thread.currentThread().getId());
-+            }
-+
-+            mEglSurface = null;
-+        }
-+
-+        /**
-+         * Create an egl surface for the current SurfaceHolder surface. If a surface
-+         * already exists, destroy it before creating the new surface.
-+         *
-+         * @return true if the surface was created successfully.
-+         */
-+        public boolean createSurface() {
-+            if (LOG_EGL) {
-+                Log.w("EglHelper", "createSurface()  tid=" + Thread.currentThread().getId());
-+            }
-+            /*
-+             * Check preconditions.
-+             */
-+            if (mEgl == null) {
-+                throw new RuntimeException("egl not initialized");
-+            }
-+            if (mEglDisplay == null) {
-+                throw new RuntimeException("eglDisplay not initialized");
-+            }
-+            if (mEglConfig == null) {
-+                throw new RuntimeException("mEglConfig not initialized");
-+            }
-+
-+            /*
-+             *  The window size has changed, so we need to create a new
-+             *  surface.
-+             */
-+            destroySurfaceImp();
-+
-+            /*
-+             * Create an EGL surface we can render into.
-+             */
-+            GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-+            if (view != null) {
-+                mEglSurface = view.mEGLWindowSurfaceFactory.createWindowSurface(mEgl,
-+                        mEglDisplay, mEglConfig, view.getHolder());
-+            } else {
-+                mEglSurface = null;
-+            }
-+
-+            if (mEglSurface == null || mEglSurface == EGL10.EGL_NO_SURFACE) {
-+                int error = mEgl.eglGetError();
-+                if (error == EGL10.EGL_BAD_NATIVE_WINDOW) {
-+                    Log.e("EglHelper", "createWindowSurface returned EGL_BAD_NATIVE_WINDOW.");
-+                }
-+                return false;
-+            }
-+
-+            /*
-+             * Before we can issue GL commands, we need to make sure
-+             * the context is current and bound to a surface.
-+             */
-+            if (!mEgl.eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface, mEglContext)) {
-+                /*
-+                 * Could not make the context current, probably because the underlying
-+                 * SurfaceView surface has been destroyed.
-+                 */
-+                logEglErrorAsWarning("EGLHelper", "eglMakeCurrent", mEgl.eglGetError());
-+                return false;
-+            }
-+
-+            return true;
-+        }
-+
-+        /**
-+         * Create a GL object for the current EGL context.
-+         * @return
-+         */
-+        GL createGL() {
-+
-+            GL gl = mEglContext.getGL();
-+            GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-+            if (view != null) {
-+                if (view.mGLWrapper != null) {
-+                    gl = view.mGLWrapper.wrap(gl);
-+                }
-+
-+                if ((view.mDebugFlags & (DEBUG_CHECK_GL_ERROR | DEBUG_LOG_GL_CALLS)) != 0) {
-+                    int configFlags = 0;
-+                    Writer log = null;
-+                    if ((view.mDebugFlags & DEBUG_CHECK_GL_ERROR) != 0) {
-+                        configFlags |= GLDebugHelper.CONFIG_CHECK_GL_ERROR;
-+                    }
-+                    if ((view.mDebugFlags & DEBUG_LOG_GL_CALLS) != 0) {
-+                        log = new LogWriter();
-+                    }
-+                    gl = GLDebugHelper.wrap(gl, configFlags, log);
-+                }
-+            }
-+            return gl;
-+        }
-+
-+        /**
-+         * Display the current render surface.
-+         * @return the EGL error code from eglSwapBuffers.
-+         */
-+        public int swap() {
-+            if (! mEgl.eglSwapBuffers(mEglDisplay, mEglSurface)) {
-+                return mEgl.eglGetError();
-+            }
-+            return EGL10.EGL_SUCCESS;
-+        }
-+
-+        public void destroySurface() {
-+            if (LOG_EGL) {
-+                Log.w("EglHelper", "destroySurface()  tid=" + Thread.currentThread().getId());
-+            }
-+            destroySurfaceImp();
-+        }
-+
-+        private void destroySurfaceImp() {
-+            if (mEglSurface != null && mEglSurface != EGL10.EGL_NO_SURFACE) {
-+                mEgl.eglMakeCurrent(mEglDisplay, EGL10.EGL_NO_SURFACE,
-+                        EGL10.EGL_NO_SURFACE,
-+                        EGL10.EGL_NO_CONTEXT);
-+                GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-+                if (view != null) {
-+                    view.mEGLWindowSurfaceFactory.destroySurface(mEgl, mEglDisplay, mEglSurface);
-+                }
-+                mEglSurface = null;
-+            }
-+        }
-+
-+        public void finish() {
-+            if (LOG_EGL) {
-+                Log.w("EglHelper", "finish() tid=" + Thread.currentThread().getId());
-+            }
-+            if (mEglContext != null) {
-+                GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-+                if (view != null) {
-+                    view.mEGLContextFactory.destroyContext(mEgl, mEglDisplay, mEglContext);
-+                }
-+                mEglContext = null;
-+            }
-+            if (mEglDisplay != null) {
-+                mEgl.eglTerminate(mEglDisplay);
-+                mEglDisplay = null;
-+            }
-+        }
-+
-+        private void throwEglException(String function) {
-+            throwEglException(function, mEgl.eglGetError());
-+        }
-+
-+        public static void throwEglException(String function, int error) {
-+            String message = formatEglError(function, error);
-+            if (LOG_THREADS) {
-+                Log.e("EglHelper", "throwEglException tid=" + Thread.currentThread().getId() + " "
-+                        + message);
-+            }
-+            throw new RuntimeException(message);
-+        }
-+
-+        public static void logEglErrorAsWarning(String tag, String function, int error) {
-+            Log.w(tag, formatEglError(function, error));
-+        }
-+
-+        public static String formatEglError(String function, int error) {
-+            return function + " failed: " + EGLLogWrapper.getErrorString(error);
-+        }
-+
-+        private WeakReference<GLSurfaceView> mGLSurfaceViewWeakRef;
-+        EGL10 mEgl;
-+        EGLDisplay mEglDisplay;
-+        EGLSurface mEglSurface;
-+        EGLConfig mEglConfig;
-+        EGLContext mEglContext;
-+
-+    }
-+
-+    /**
-+     * A generic GL Thread. Takes care of initializing EGL and GL. Delegates
-+     * to a Renderer instance to do the actual drawing. Can be configured to
-+     * render continuously or on request.
-+     *
-+     * All potentially blocking synchronization is done through the
-+     * sGLThreadManager object. This avoids multiple-lock ordering issues.
-+     *
-+     */
-+    static class GLThread extends Thread {
-+        GLThread(WeakReference<GLSurfaceView> glSurfaceViewWeakRef) {
-+            super();
-+            mWidth = 0;
-+            mHeight = 0;
-+            mRequestRender = true;
-+            mRenderMode = RENDERMODE_CONTINUOUSLY;
-+            mWantRenderNotification = false;
-+            mGLSurfaceViewWeakRef = glSurfaceViewWeakRef;
-+        }
-+
-+        @Override
-+        public void run() {
-+            setName("GLThread " + getId());
-+            if (LOG_THREADS) {
-+                Log.i("GLThread", "starting tid=" + getId());
-+            }
-+
-+            try {
-+                guardedRun();
-+            } catch (InterruptedException e) {
-+                // fall thru and exit normally
-+            } finally {
-+                sGLThreadManager.threadExiting(this);
-+            }
-+        }
-+
-+        /*
-+         * This private method should only be called inside a
-+         * synchronized(sGLThreadManager) block.
-+         */
-+        private void stopEglSurfaceLocked() {
-+            if (mHaveEglSurface) {
-+                mHaveEglSurface = false;
-+                mEglHelper.destroySurface();
-+            }
-+        }
-+
-+        /*
-+         * This private method should only be called inside a
-+         * synchronized(sGLThreadManager) block.
-+         */
-+        private void stopEglContextLocked() {
-+            if (mHaveEglContext) {
-+                mEglHelper.finish();
-+                mHaveEglContext = false;
-+                sGLThreadManager.releaseEglContextLocked(this);
-+            }
-+        }
-+        private void guardedRun() throws InterruptedException {
-+            mEglHelper = new EglHelper(mGLSurfaceViewWeakRef);
-+            mHaveEglContext = false;
-+            mHaveEglSurface = false;
-+            mWantRenderNotification = false;
-+
-+            try {
-+                GL10 gl = null;
-+                boolean createEglContext = false;
-+                boolean createEglSurface = false;
-+                boolean createGlInterface = false;
-+                boolean lostEglContext = false;
-+                boolean sizeChanged = false;
-+                boolean wantRenderNotification = false;
-+                boolean doRenderNotification = false;
-+                boolean askedToReleaseEglContext = false;
-+                int w = 0;
-+                int h = 0;
-+                Runnable event = null;
-+
-+                while (true) {
-+                    synchronized (sGLThreadManager) {
-+                        while (true) {
-+                            if (mShouldExit) {
-+                                return;
-+                            }
-+
-+                            if (! mEventQueue.isEmpty()) {
-+                                event = mEventQueue.remove(0);
-+                                break;
-+                            }
-+
-+                            // Update the pause state.
-+                            boolean pausing = false;
-+                            if (mPaused != mRequestPaused) {
-+                                pausing = mRequestPaused;
-+                                mPaused = mRequestPaused;
-+                                sGLThreadManager.notifyAll();
-+                                if (LOG_PAUSE_RESUME) {
-+                                    Log.i("GLThread", "mPaused is now " + mPaused + " tid=" + getId());
-+                                }
-+                            }
-+
-+                            // Do we need to give up the EGL context?
-+                            if (mShouldReleaseEglContext) {
-+                                if (LOG_SURFACE) {
-+                                    Log.i("GLThread", "releasing EGL context because asked to tid=" + getId());
-+                                }
-+                                stopEglSurfaceLocked();
-+                                stopEglContextLocked();
-+                                mShouldReleaseEglContext = false;
-+                                askedToReleaseEglContext = true;
-+                            }
-+
-+                            // Have we lost the EGL context?
-+                            if (lostEglContext) {
-+                                stopEglSurfaceLocked();
-+                                stopEglContextLocked();
-+                                lostEglContext = false;
-+                            }
-+
-+                            // When pausing, release the EGL surface:
-+                            if (pausing && mHaveEglSurface) {
-+                                if (LOG_SURFACE) {
-+                                    Log.i("GLThread", "releasing EGL surface because paused tid=" + getId());
-+                                }
-+                                stopEglSurfaceLocked();
-+                            }
-+
-+                            // When pausing, optionally release the EGL Context:
-+                            if (pausing && mHaveEglContext) {
-+                                GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-+                                boolean preserveEglContextOnPause = view == null ?
-+                                        false : view.mPreserveEGLContextOnPause;
-+                                if (!preserveEglContextOnPause) {
-+                                    stopEglContextLocked();
-+                                    if (LOG_SURFACE) {
-+                                        Log.i("GLThread", "releasing EGL context because paused tid=" + getId());
-+                                    }
-+                                }
-+                            }
-+
-+                            // Have we lost the SurfaceView surface?
-+                            if ((! mHasSurface) && (! mWaitingForSurface)) {
-+                                if (LOG_SURFACE) {
-+                                    Log.i("GLThread", "noticed surfaceView surface lost tid=" + getId());
-+                                }
-+                                if (mHaveEglSurface) {
-+                                    stopEglSurfaceLocked();
-+                                }
-+                                mWaitingForSurface = true;
-+                                mSurfaceIsBad = false;
-+                                sGLThreadManager.notifyAll();
-+                            }
-+
-+                            // Have we acquired the surface view surface?
-+                            if (mHasSurface && mWaitingForSurface) {
-+                                if (LOG_SURFACE) {
-+                                    Log.i("GLThread", "noticed surfaceView surface acquired tid=" + getId());
-+                                }
-+                                mWaitingForSurface = false;
-+                                sGLThreadManager.notifyAll();
-+                            }
-+
-+                            if (doRenderNotification) {
-+                                if (LOG_SURFACE) {
-+                                    Log.i("GLThread", "sending render notification tid=" + getId());
-+                                }
-+                                mWantRenderNotification = false;
-+                                doRenderNotification = false;
-+                                mRenderComplete = true;
-+                                sGLThreadManager.notifyAll();
-+                            }
-+
-+                            // Ready to draw?
-+                            if (readyToDraw()) {
-+
-+                                // If we don't have an EGL context, try to acquire one.
-+                                if (! mHaveEglContext) {
-+                                    if (askedToReleaseEglContext) {
-+                                        askedToReleaseEglContext = false;
-+                                    } else {
-+                                        try {
-+                                            mEglHelper.start();
-+                                        } catch (RuntimeException t) {
-+                                            sGLThreadManager.releaseEglContextLocked(this);
-+                                            throw t;
-+                                        }
-+                                        mHaveEglContext = true;
-+                                        createEglContext = true;
-+
-+                                        sGLThreadManager.notifyAll();
-+                                    }
-+                                }
-+
-+                                if (mHaveEglContext && !mHaveEglSurface) {
-+                                    mHaveEglSurface = true;
-+                                    createEglSurface = true;
-+                                    createGlInterface = true;
-+                                    sizeChanged = true;
-+                                }
-+
-+                                if (mHaveEglSurface) {
-+                                    if (mSizeChanged) {
-+                                        sizeChanged = true;
-+                                        w = mWidth;
-+                                        h = mHeight;
-+                                        mWantRenderNotification = true;
-+                                        if (LOG_SURFACE) {
-+                                            Log.i("GLThread",
-+                                                    "noticing that we want render notification tid="
-+                                                    + getId());
-+                                        }
-+
-+                                        // Destroy and recreate the EGL surface.
-+                                        createEglSurface = true;
-+
-+                                        mSizeChanged = false;
-+                                    }
-+                                    mRequestRender = false;
-+                                    sGLThreadManager.notifyAll();
-+                                    if (mWantRenderNotification) {
-+                                        wantRenderNotification = true;
-+                                    }
-+                                    break;
-+                                }
-+                            }
-+
-+                            // By design, this is the only place in a GLThread thread where we wait().
-+                            if (LOG_THREADS) {
-+                                Log.i("GLThread", "waiting tid=" + getId()
-+                                    + " mHaveEglContext: " + mHaveEglContext
-+                                    + " mHaveEglSurface: " + mHaveEglSurface
-+                                    + " mFinishedCreatingEglSurface: " + mFinishedCreatingEglSurface
-+                                    + " mPaused: " + mPaused
-+                                    + " mHasSurface: " + mHasSurface
-+                                    + " mSurfaceIsBad: " + mSurfaceIsBad
-+                                    + " mWaitingForSurface: " + mWaitingForSurface
-+                                    + " mWidth: " + mWidth
-+                                    + " mHeight: " + mHeight
-+                                    + " mRequestRender: " + mRequestRender
-+                                    + " mRenderMode: " + mRenderMode);
-+                            }
-+                            sGLThreadManager.wait();
-+                        }
-+                    } // end of synchronized(sGLThreadManager)
-+
-+                    if (event != null) {
-+                        event.run();
-+                        event = null;
-+                        continue;
-+                    }
-+
-+                    if (createEglSurface) {
-+                        if (LOG_SURFACE) {
-+                            Log.w("GLThread", "egl createSurface");
-+                        }
-+                        if (mEglHelper.createSurface()) {
-+                            synchronized(sGLThreadManager) {
-+                                mFinishedCreatingEglSurface = true;
-+                                sGLThreadManager.notifyAll();
-+                            }
-+                        } else {
-+                            synchronized(sGLThreadManager) {
-+                                mFinishedCreatingEglSurface = true;
-+                                mSurfaceIsBad = true;
-+                                sGLThreadManager.notifyAll();
-+                            }
-+                            continue;
-+                        }
-+                        createEglSurface = false;
-+                    }
-+
-+                    if (createGlInterface) {
-+                        gl = (GL10) mEglHelper.createGL();
-+
-+                        createGlInterface = false;
-+                    }
-+
-+                    if (createEglContext) {
-+                        if (LOG_RENDERER) {
-+                            Log.w("GLThread", "onSurfaceCreated");
-+                        }
-+                        GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-+                        if (view != null) {
-+                            try {
-+                                Trace.traceBegin(Trace.TRACE_TAG_VIEW, "onSurfaceCreated");
-+                                view.mRenderer.onSurfaceCreated(gl, mEglHelper.mEglConfig);
-+                            } finally {
-+                                Trace.traceEnd(Trace.TRACE_TAG_VIEW);
-+                            }
-+                        }
-+                        createEglContext = false;
-+                    }
-+
-+                    if (sizeChanged) {
-+                        if (LOG_RENDERER) {
-+                            Log.w("GLThread", "onSurfaceChanged(" + w + ", " + h + ")");
-+                        }
-+                        GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-+                        if (view != null) {
-+                            try {
-+                                Trace.traceBegin(Trace.TRACE_TAG_VIEW, "onSurfaceChanged");
-+                                view.mRenderer.onSurfaceChanged(gl, w, h);
-+                            } finally {
-+                                Trace.traceEnd(Trace.TRACE_TAG_VIEW);
-+                            }
-+                        }
-+                        sizeChanged = false;
-+                    }
-+
-+                    if (LOG_RENDERER_DRAW_FRAME) {
-+                        Log.w("GLThread", "onDrawFrame tid=" + getId());
-+                    }
-+                    {
-+                        GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-+                        if (view != null) {
-+                            try {
-+                                Trace.traceBegin(Trace.TRACE_TAG_VIEW, "onDrawFrame");
-+                                view.mRenderer.onDrawFrame(gl);
-+                            } finally {
-+                                Trace.traceEnd(Trace.TRACE_TAG_VIEW);
-+                            }
-+                        }
-+                    }
-+                    int swapError = mEglHelper.swap();
-+                    switch (swapError) {
-+                        case EGL10.EGL_SUCCESS:
-+                            break;
-+                        case EGL11.EGL_CONTEXT_LOST:
-+                            if (LOG_SURFACE) {
-+                                Log.i("GLThread", "egl context lost tid=" + getId());
-+                            }
-+                            lostEglContext = true;
-+                            break;
-+                        default:
-+                            // Other errors typically mean that the current surface is bad,
-+                            // probably because the SurfaceView surface has been destroyed,
-+                            // but we haven't been notified yet.
-+                            // Log the error to help developers understand why rendering stopped.
-+                            EglHelper.logEglErrorAsWarning("GLThread", "eglSwapBuffers", swapError);
-+
-+                            synchronized(sGLThreadManager) {
-+                                mSurfaceIsBad = true;
-+                                sGLThreadManager.notifyAll();
-+                            }
-+                            break;
-+                    }
-+
-+                    if (wantRenderNotification) {
-+                        doRenderNotification = true;
-+                        wantRenderNotification = false;
-+                    }
-+                }
-+
-+            } finally {
-+                /*
-+                 * clean-up everything...
-+                 */
-+                synchronized (sGLThreadManager) {
-+                    stopEglSurfaceLocked();
-+                    stopEglContextLocked();
-+                }
-+            }
-+        }
-+
-+        public boolean ableToDraw() {
-+            return mHaveEglContext && mHaveEglSurface && readyToDraw();
-+        }
-+
-+        private boolean readyToDraw() {
-+            return (!mPaused) && mHasSurface && (!mSurfaceIsBad)
-+                && (mWidth > 0) && (mHeight > 0)
-+                && (mRequestRender || (mRenderMode == RENDERMODE_CONTINUOUSLY));
-+        }
-+
-+        public void setRenderMode(int renderMode) {
-+            if ( !((RENDERMODE_WHEN_DIRTY <= renderMode) && (renderMode <= RENDERMODE_CONTINUOUSLY)) ) {
-+                throw new IllegalArgumentException("renderMode");
-+            }
-+            synchronized(sGLThreadManager) {
-+                mRenderMode = renderMode;
-+                sGLThreadManager.notifyAll();
-+            }
-+        }
-+
-+        public int getRenderMode() {
-+            synchronized(sGLThreadManager) {
-+                return mRenderMode;
-+            }
-+        }
-+
-+        public void requestRender() {
-+            synchronized(sGLThreadManager) {
-+                mRequestRender = true;
-+                sGLThreadManager.notifyAll();
-+            }
-+        }
-+
-+        public void requestRenderAndWait() {
-+            synchronized(sGLThreadManager) {
-+                // If we are already on the GL thread, this means a client callback
-+                // has caused reentrancy, for example via updating the SurfaceView parameters.
-+                // We will return to the client rendering code, so here we don't need to
-+                // do anything.
-+                if (Thread.currentThread() == this) {
-+                    return;
-+                }
-+
-+                mWantRenderNotification = true;
-+                mRequestRender = true;
-+                mRenderComplete = false;
-+
-+                sGLThreadManager.notifyAll();
-+
-+                while (!mExited && !mPaused && !mRenderComplete && ableToDraw()) {
-+                    try {
-+                        sGLThreadManager.wait();
-+                    } catch (InterruptedException ex) {
-+                        Thread.currentThread().interrupt();
-+                    }
-+                }
-+
-+            }
-+        }
-+
-+        public void surfaceCreated() {
-+            synchronized(sGLThreadManager) {
-+                if (LOG_THREADS) {
-+                    Log.i("GLThread", "surfaceCreated tid=" + getId());
-+                }
-+                mHasSurface = true;
-+                mFinishedCreatingEglSurface = false;
-+                sGLThreadManager.notifyAll();
-+                while (mWaitingForSurface
-+                       && !mFinishedCreatingEglSurface
-+                       && !mExited) {
-+                    try {
-+                        sGLThreadManager.wait();
-+                    } catch (InterruptedException e) {
-+                        Thread.currentThread().interrupt();
-+                    }
-+                }
-+            }
-+        }
-+
-+        public void surfaceDestroyed() {
-+            synchronized(sGLThreadManager) {
-+                if (LOG_THREADS) {
-+                    Log.i("GLThread", "surfaceDestroyed tid=" + getId());
-+                }
-+                mHasSurface = false;
-+                sGLThreadManager.notifyAll();
-+                while((!mWaitingForSurface) && (!mExited)) {
-+                    try {
-+                        sGLThreadManager.wait();
-+                    } catch (InterruptedException e) {
-+                        Thread.currentThread().interrupt();
-+                    }
-+                }
-+            }
-+        }
-+
-+        public void onPause() {
-+            synchronized (sGLThreadManager) {
-+                if (LOG_PAUSE_RESUME) {
-+                    Log.i("GLThread", "onPause tid=" + getId());
-+                }
-+                mRequestPaused = true;
-+                sGLThreadManager.notifyAll();
-+                while ((! mExited) && (! mPaused)) {
-+                    if (LOG_PAUSE_RESUME) {
-+                        Log.i("Main thread", "onPause waiting for mPaused.");
-+                    }
-+                    try {
-+                        sGLThreadManager.wait();
-+                    } catch (InterruptedException ex) {
-+                        Thread.currentThread().interrupt();
-+                    }
-+                }
-+            }
-+        }
-+
-+        public void onResume() {
-+            synchronized (sGLThreadManager) {
-+                if (LOG_PAUSE_RESUME) {
-+                    Log.i("GLThread", "onResume tid=" + getId());
-+                }
-+                mRequestPaused = false;
-+                mRequestRender = true;
-+                mRenderComplete = false;
-+                sGLThreadManager.notifyAll();
-+                while ((! mExited) && mPaused && (!mRenderComplete)) {
-+                    if (LOG_PAUSE_RESUME) {
-+                        Log.i("Main thread", "onResume waiting for !mPaused.");
-+                    }
-+                    try {
-+                        sGLThreadManager.wait();
-+                    } catch (InterruptedException ex) {
-+                        Thread.currentThread().interrupt();
-+                    }
-+                }
-+            }
-+        }
-+
-+        public void onWindowResize(int w, int h) {
-+            synchronized (sGLThreadManager) {
-+                mWidth = w;
-+                mHeight = h;
-+                mSizeChanged = true;
-+                mRequestRender = true;
-+                mRenderComplete = false;
-+
-+                // If we are already on the GL thread, this means a client callback
-+                // has caused reentrancy, for example via updating the SurfaceView parameters.
-+                // We need to process the size change eventually though and update our EGLSurface.
-+                // So we set the parameters and return so they can be processed on our
-+                // next iteration.
-+                if (Thread.currentThread() == this) {
-+                    return;
-+                }
-+
-+                sGLThreadManager.notifyAll();
-+
-+                // Wait for thread to react to resize and render a frame
-+                while (! mExited && !mPaused && !mRenderComplete
-+                        && ableToDraw()) {
-+                    if (LOG_SURFACE) {
-+                        Log.i("Main thread", "onWindowResize waiting for render complete from tid=" + getId());
-+                    }
-+                    try {
-+                        sGLThreadManager.wait();
-+                    } catch (InterruptedException ex) {
-+                        Thread.currentThread().interrupt();
-+                    }
-+                }
-+            }
-+        }
-+
-+        public void requestExitAndWait() {
-+            // don't call this from GLThread thread or it is a guaranteed
-+            // deadlock!
-+            synchronized(sGLThreadManager) {
-+                mShouldExit = true;
-+                sGLThreadManager.notifyAll();
-+                while (! mExited) {
-+                    try {
-+                        sGLThreadManager.wait();
-+                    } catch (InterruptedException ex) {
-+                        Thread.currentThread().interrupt();
-+                    }
-+                }
-+            }
-+        }
-+
-+        public void requestReleaseEglContextLocked() {
-+            mShouldReleaseEglContext = true;
-+            sGLThreadManager.notifyAll();
-+        }
-+
-+        /**
-+         * Queue an "event" to be run on the GL rendering thread.
-+         * @param r the runnable to be run on the GL rendering thread.
-+         */
-+        public void queueEvent(Runnable r) {
-+            if (r == null) {
-+                throw new IllegalArgumentException("r must not be null");
-+            }
-+            synchronized(sGLThreadManager) {
-+                mEventQueue.add(r);
-+                sGLThreadManager.notifyAll();
-+            }
-+        }
-+
-+        // Once the thread is started, all accesses to the following member
-+        // variables are protected by the sGLThreadManager monitor
-+        private boolean mShouldExit;
-+        private boolean mExited;
-+        private boolean mRequestPaused;
-+        private boolean mPaused;
-+        private boolean mHasSurface;
-+        private boolean mSurfaceIsBad;
-+        private boolean mWaitingForSurface;
-+        private boolean mHaveEglContext;
-+        private boolean mHaveEglSurface;
-+        private boolean mFinishedCreatingEglSurface;
-+        private boolean mShouldReleaseEglContext;
-+        private int mWidth;
-+        private int mHeight;
-+        private int mRenderMode;
-+        private boolean mRequestRender;
-+        private boolean mWantRenderNotification;
-+        private boolean mRenderComplete;
-+        private ArrayList<Runnable> mEventQueue = new ArrayList<Runnable>();
-+        private boolean mSizeChanged = true;
-+
-+        // End of member variables protected by the sGLThreadManager monitor.
-+
-+        private EglHelper mEglHelper;
-+
-+        /**
-+         * Set once at thread construction time, nulled out when the parent view is garbage
-+         * called. This weak reference allows the GLSurfaceView to be garbage collected while
-+         * the GLThread is still alive.
-+         */
-+        private WeakReference<GLSurfaceView> mGLSurfaceViewWeakRef;
-+
-+    }
-+
-+    static class LogWriter extends Writer {
-+
-+        @Override public void close() {
-+            flushBuilder();
-+        }
-+
-+        @Override public void flush() {
-+            flushBuilder();
-+        }
-+
-+        @Override public void write(char[] buf, int offset, int count) {
-+            for(int i = 0; i < count; i++) {
-+                char c = buf[offset + i];
-+                if ( c == '\n') {
-+                    flushBuilder();
-+                }
-+                else {
-+                    mBuilder.append(c);
-+                }
-+            }
-+        }
-+
-+        private void flushBuilder() {
-+            if (mBuilder.length() > 0) {
-+                Log.v("GLSurfaceView", mBuilder.toString());
-+                mBuilder.delete(0, mBuilder.length());
-+            }
-+        }
-+
-+        private StringBuilder mBuilder = new StringBuilder();
-+    }
-+
-+
-+    private void checkRenderThreadState() {
-+        if (mGLThread != null) {
-+            throw new IllegalStateException(
-+                    "setRenderer has already been called for this instance.");
-+        }
-+    }
-+
-+    private static class GLThreadManager {
-+        private static String TAG = "GLThreadManager";
-+
-+        public synchronized void threadExiting(GLThread thread) {
-+            if (LOG_THREADS) {
-+                Log.i("GLThread", "exiting tid=" +  thread.getId());
-+            }
-+            thread.mExited = true;
-+            notifyAll();
-+        }
-+
-+        /*
-+         * Releases the EGL context. Requires that we are already in the
-+         * sGLThreadManager monitor when this is called.
-+         */
-+        public void releaseEglContextLocked(GLThread thread) {
-+            notifyAll();
-+        }
-+    }
-+
-+    private static final GLThreadManager sGLThreadManager = new GLThreadManager();
-+
-+    private final WeakReference<GLSurfaceView> mThisWeakRef =
-+            new WeakReference<GLSurfaceView>(this);
-+    private GLThread mGLThread;
-+    private Renderer mRenderer;
-+    private boolean mDetached;
-+    private EGLConfigChooser mEGLConfigChooser;
-+    private EGLContextFactory mEGLContextFactory;
-+    private EGLWindowSurfaceFactory mEGLWindowSurfaceFactory;
-+    private GLWrapper mGLWrapper;
-+    private int mDebugFlags;
-+    private int mEGLContextClientVersion;
-+    private boolean mPreserveEGLContextOnPause;
-+}
diff -Naur frameworksRaw/base/opengl/java/android/opengl/GLSurfaceView.java.orig.rej frameworksModified/base/opengl/java/android/opengl/GLSurfaceView.java.orig.rej
--- frameworksRaw/base/opengl/java/android/opengl/GLSurfaceView.java.orig.rej	2017-07-06 15:34:16.022010952 +0530
+++ frameworksModified/base/opengl/java/android/opengl/GLSurfaceView.java.orig.rej	1970-01-01 05:30:00.000000000 +0530
@@ -1,1915 +0,0 @@
---- base/opengl/java/android/opengl/GLSurfaceView.java.orig	1970-01-01 05:30:00.000000000 +0530
-+++ base/opengl/java/android/opengl/GLSurfaceView.java.orig	2017-07-06 13:50:03.679302904 +0530
-@@ -0,0 +1,1912 @@
-+/*
-+ * Copyright (C) 2008 The Android Open Source Project
-+ *
-+ * Licensed under the Apache License, Version 2.0 (the "License");
-+ * you may not use this file except in compliance with the License.
-+ * You may obtain a copy of the License at
-+ *
-+ *      http://www.apache.org/licenses/LICENSE-2.0
-+ *
-+ * Unless required by applicable law or agreed to in writing, software
-+ * distributed under the License is distributed on an "AS IS" BASIS,
-+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-+ * See the License for the specific language governing permissions and
-+ * limitations under the License.
-+ */
-+
-+package android.opengl;
-+
-+import android.content.Context;
-+import android.os.Trace;
-+import android.util.AttributeSet;
-+import android.util.Log;
-+import android.view.SurfaceHolder;
-+import android.view.SurfaceView;
-+
-+import java.io.Writer;
-+import java.lang.ref.WeakReference;
-+import java.util.ArrayList;
-+
-+import javax.microedition.khronos.egl.EGL10;
-+import javax.microedition.khronos.egl.EGL11;
-+import javax.microedition.khronos.egl.EGLConfig;
-+import javax.microedition.khronos.egl.EGLContext;
-+import javax.microedition.khronos.egl.EGLDisplay;
-+import javax.microedition.khronos.egl.EGLSurface;
-+import javax.microedition.khronos.opengles.GL;
-+import javax.microedition.khronos.opengles.GL10;
-+
-+/**
-+ * An implementation of SurfaceView that uses the dedicated surface for
-+ * displaying OpenGL rendering.
-+ * <p>
-+ * A GLSurfaceView provides the following features:
-+ * <p>
-+ * <ul>
-+ * <li>Manages a surface, which is a special piece of memory that can be
-+ * composited into the Android view system.
-+ * <li>Manages an EGL display, which enables OpenGL to render into a surface.
-+ * <li>Accepts a user-provided Renderer object that does the actual rendering.
-+ * <li>Renders on a dedicated thread to decouple rendering performance from the
-+ * UI thread.
-+ * <li>Supports both on-demand and continuous rendering.
-+ * <li>Optionally wraps, traces, and/or error-checks the renderer's OpenGL calls.
-+ * </ul>
-+ *
-+ * <div class="special reference">
-+ * <h3>Developer Guides</h3>
-+ * <p>For more information about how to use OpenGL, read the
-+ * <a href="{@docRoot}guide/topics/graphics/opengl.html">OpenGL</a> developer guide.</p>
-+ * </div>
-+ *
-+ * <h3>Using GLSurfaceView</h3>
-+ * <p>
-+ * Typically you use GLSurfaceView by subclassing it and overriding one or more of the
-+ * View system input event methods. If your application does not need to override event
-+ * methods then GLSurfaceView can be used as-is. For the most part
-+ * GLSurfaceView behavior is customized by calling "set" methods rather than by subclassing.
-+ * For example, unlike a regular View, drawing is delegated to a separate Renderer object which
-+ * is registered with the GLSurfaceView
-+ * using the {@link #setRenderer(Renderer)} call.
-+ * <p>
-+ * <h3>Initializing GLSurfaceView</h3>
-+ * All you have to do to initialize a GLSurfaceView is call {@link #setRenderer(Renderer)}.
-+ * However, if desired, you can modify the default behavior of GLSurfaceView by calling one or
-+ * more of these methods before calling setRenderer:
-+ * <ul>
-+ * <li>{@link #setDebugFlags(int)}
-+ * <li>{@link #setEGLConfigChooser(boolean)}
-+ * <li>{@link #setEGLConfigChooser(EGLConfigChooser)}
-+ * <li>{@link #setEGLConfigChooser(int, int, int, int, int, int)}
-+ * <li>{@link #setGLWrapper(GLWrapper)}
-+ * </ul>
-+ * <p>
-+ * <h4>Specifying the android.view.Surface</h4>
-+ * By default GLSurfaceView will create a PixelFormat.RGB_888 format surface. If a translucent
-+ * surface is required, call getHolder().setFormat(PixelFormat.TRANSLUCENT).
-+ * The exact format of a TRANSLUCENT surface is device dependent, but it will be
-+ * a 32-bit-per-pixel surface with 8 bits per component.
-+ * <p>
-+ * <h4>Choosing an EGL Configuration</h4>
-+ * A given Android device may support multiple EGLConfig rendering configurations.
-+ * The available configurations may differ in how may channels of data are present, as
-+ * well as how many bits are allocated to each channel. Therefore, the first thing
-+ * GLSurfaceView has to do when starting to render is choose what EGLConfig to use.
-+ * <p>
-+ * By default GLSurfaceView chooses a EGLConfig that has an RGB_888 pixel format,
-+ * with at least a 16-bit depth buffer and no stencil.
-+ * <p>
-+ * If you would prefer a different EGLConfig
-+ * you can override the default behavior by calling one of the
-+ * setEGLConfigChooser methods.
-+ * <p>
-+ * <h4>Debug Behavior</h4>
-+ * You can optionally modify the behavior of GLSurfaceView by calling
-+ * one or more of the debugging methods {@link #setDebugFlags(int)},
-+ * and {@link #setGLWrapper}. These methods may be called before and/or after setRenderer, but
-+ * typically they are called before setRenderer so that they take effect immediately.
-+ * <p>
-+ * <h4>Setting a Renderer</h4>
-+ * Finally, you must call {@link #setRenderer} to register a {@link Renderer}.
-+ * The renderer is
-+ * responsible for doing the actual OpenGL rendering.
-+ * <p>
-+ * <h3>Rendering Mode</h3>
-+ * Once the renderer is set, you can control whether the renderer draws
-+ * continuously or on-demand by calling
-+ * {@link #setRenderMode}. The default is continuous rendering.
-+ * <p>
-+ * <h3>Activity Life-cycle</h3>
-+ * A GLSurfaceView must be notified when to pause and resume rendering. GLSurfaceView clients
-+ * are required to call {@link #onPause()} when the activity stops and
-+ * {@link #onResume()} when the activity starts. These calls allow GLSurfaceView to
-+ * pause and resume the rendering thread, and also allow GLSurfaceView to release and recreate
-+ * the OpenGL display.
-+ * <p>
-+ * <h3>Handling events</h3>
-+ * <p>
-+ * To handle an event you will typically subclass GLSurfaceView and override the
-+ * appropriate method, just as you would with any other View. However, when handling
-+ * the event, you may need to communicate with the Renderer object
-+ * that's running in the rendering thread. You can do this using any
-+ * standard Java cross-thread communication mechanism. In addition,
-+ * one relatively easy way to communicate with your renderer is
-+ * to call
-+ * {@link #queueEvent(Runnable)}. For example:
-+ * <pre class="prettyprint">
-+ * class MyGLSurfaceView extends GLSurfaceView {
-+ *
-+ *     private MyRenderer mMyRenderer;
-+ *
-+ *     public void start() {
-+ *         mMyRenderer = ...;
-+ *         setRenderer(mMyRenderer);
-+ *     }
-+ *
-+ *     public boolean onKeyDown(int keyCode, KeyEvent event) {
-+ *         if (keyCode == KeyEvent.KEYCODE_DPAD_CENTER) {
-+ *             queueEvent(new Runnable() {
-+ *                 // This method will be called on the rendering
-+ *                 // thread:
-+ *                 public void run() {
-+ *                     mMyRenderer.handleDpadCenter();
-+ *                 }});
-+ *             return true;
-+ *         }
-+ *         return super.onKeyDown(keyCode, event);
-+ *     }
-+ * }
-+ * </pre>
-+ *
-+ */
-+public class GLSurfaceView extends SurfaceView implements SurfaceHolder.Callback2 {
-+    private final static String TAG = "GLSurfaceView";
-+    private final static boolean LOG_ATTACH_DETACH = false;
-+    private final static boolean LOG_THREADS = false;
-+    private final static boolean LOG_PAUSE_RESUME = false;
-+    private final static boolean LOG_SURFACE = false;
-+    private final static boolean LOG_RENDERER = false;
-+    private final static boolean LOG_RENDERER_DRAW_FRAME = false;
-+    private final static boolean LOG_EGL = false;
-+    /**
-+     * The renderer only renders
-+     * when the surface is created, or when {@link #requestRender} is called.
-+     *
-+     * @see #getRenderMode()
-+     * @see #setRenderMode(int)
-+     * @see #requestRender()
-+     */
-+    public final static int RENDERMODE_WHEN_DIRTY = 0;
-+    /**
-+     * The renderer is called
-+     * continuously to re-render the scene.
-+     *
-+     * @see #getRenderMode()
-+     * @see #setRenderMode(int)
-+     */
-+    public final static int RENDERMODE_CONTINUOUSLY = 1;
-+
-+    /**
-+     * Check glError() after every GL call and throw an exception if glError indicates
-+     * that an error has occurred. This can be used to help track down which OpenGL ES call
-+     * is causing an error.
-+     *
-+     * @see #getDebugFlags
-+     * @see #setDebugFlags
-+     */
-+    public final static int DEBUG_CHECK_GL_ERROR = 1;
-+
-+    /**
-+     * Log GL calls to the system log at "verbose" level with tag "GLSurfaceView".
-+     *
-+     * @see #getDebugFlags
-+     * @see #setDebugFlags
-+     */
-+    public final static int DEBUG_LOG_GL_CALLS = 2;
-+
-+    /**
-+     * Standard View constructor. In order to render something, you
-+     * must call {@link #setRenderer} to register a renderer.
-+     */
-+    public GLSurfaceView(Context context) {
-+        super(context);
-+        init();
-+    }
-+
-+    /**
-+     * Standard View constructor. In order to render something, you
-+     * must call {@link #setRenderer} to register a renderer.
-+     */
-+    public GLSurfaceView(Context context, AttributeSet attrs) {
-+        super(context, attrs);
-+        init();
-+    }
-+
-+    @Override
-+    protected void finalize() throws Throwable {
-+        try {
-+            if (mGLThread != null) {
-+                // GLThread may still be running if this view was never
-+                // attached to a window.
-+                mGLThread.requestExitAndWait();
-+            }
-+        } finally {
-+            super.finalize();
-+        }
-+    }
-+
-+    private void init() {
-+        // Install a SurfaceHolder.Callback so we get notified when the
-+        // underlying surface is created and destroyed
-+        SurfaceHolder holder = getHolder();
-+        holder.addCallback(this);
-+        // setFormat is done by SurfaceView in SDK 2.3 and newer. Uncomment
-+        // this statement if back-porting to 2.2 or older:
-+        // holder.setFormat(PixelFormat.RGB_565);
-+        //
-+        // setType is not needed for SDK 2.0 or newer. Uncomment this
-+        // statement if back-porting this code to older SDKs.
-+        // holder.setType(SurfaceHolder.SURFACE_TYPE_GPU);
-+    }
-+
-+    /**
-+     * Set the glWrapper. If the glWrapper is not null, its
-+     * {@link GLWrapper#wrap(GL)} method is called
-+     * whenever a surface is created. A GLWrapper can be used to wrap
-+     * the GL object that's passed to the renderer. Wrapping a GL
-+     * object enables examining and modifying the behavior of the
-+     * GL calls made by the renderer.
-+     * <p>
-+     * Wrapping is typically used for debugging purposes.
-+     * <p>
-+     * The default value is null.
-+     * @param glWrapper the new GLWrapper
-+     */
-+    public void setGLWrapper(GLWrapper glWrapper) {
-+        mGLWrapper = glWrapper;
-+    }
-+
-+    /**
-+     * Set the debug flags to a new value. The value is
-+     * constructed by OR-together zero or more
-+     * of the DEBUG_CHECK_* constants. The debug flags take effect
-+     * whenever a surface is created. The default value is zero.
-+     * @param debugFlags the new debug flags
-+     * @see #DEBUG_CHECK_GL_ERROR
-+     * @see #DEBUG_LOG_GL_CALLS
-+     */
-+    public void setDebugFlags(int debugFlags) {
-+        mDebugFlags = debugFlags;
-+    }
-+
-+    /**
-+     * Get the current value of the debug flags.
-+     * @return the current value of the debug flags.
-+     */
-+    public int getDebugFlags() {
-+        return mDebugFlags;
-+    }
-+
-+    /**
-+     * Control whether the EGL context is preserved when the GLSurfaceView is paused and
-+     * resumed.
-+     * <p>
-+     * If set to true, then the EGL context may be preserved when the GLSurfaceView is paused.
-+     * <p>
-+     * Prior to API level 11, whether the EGL context is actually preserved or not
-+     * depends upon whether the Android device can support an arbitrary number of
-+     * EGL contexts or not. Devices that can only support a limited number of EGL
-+     * contexts must release the EGL context in order to allow multiple applications
-+     * to share the GPU.
-+     * <p>
-+     * If set to false, the EGL context will be released when the GLSurfaceView is paused,
-+     * and recreated when the GLSurfaceView is resumed.
-+     * <p>
-+     *
-+     * The default is false.
-+     *
-+     * @param preserveOnPause preserve the EGL context when paused
-+     */
-+    public void setPreserveEGLContextOnPause(boolean preserveOnPause) {
-+        mPreserveEGLContextOnPause = preserveOnPause;
-+    }
-+
-+    /**
-+     * @return true if the EGL context will be preserved when paused
-+     */
-+    public boolean getPreserveEGLContextOnPause() {
-+        return mPreserveEGLContextOnPause;
-+    }
-+
-+    /**
-+     * Set the renderer associated with this view. Also starts the thread that
-+     * will call the renderer, which in turn causes the rendering to start.
-+     * <p>This method should be called once and only once in the life-cycle of
-+     * a GLSurfaceView.
-+     * <p>The following GLSurfaceView methods can only be called <em>before</em>
-+     * setRenderer is called:
-+     * <ul>
-+     * <li>{@link #setEGLConfigChooser(boolean)}
-+     * <li>{@link #setEGLConfigChooser(EGLConfigChooser)}
-+     * <li>{@link #setEGLConfigChooser(int, int, int, int, int, int)}
-+     * </ul>
-+     * <p>
-+     * The following GLSurfaceView methods can only be called <em>after</em>
-+     * setRenderer is called:
-+     * <ul>
-+     * <li>{@link #getRenderMode()}
-+     * <li>{@link #onPause()}
-+     * <li>{@link #onResume()}
-+     * <li>{@link #queueEvent(Runnable)}
-+     * <li>{@link #requestRender()}
-+     * <li>{@link #setRenderMode(int)}
-+     * </ul>
-+     *
-+     * @param renderer the renderer to use to perform OpenGL drawing.
-+     */
-+    public void setRenderer(Renderer renderer) {
-+        checkRenderThreadState();
-+        if (mEGLConfigChooser == null) {
-+            mEGLConfigChooser = new SimpleEGLConfigChooser(true);
-+        }
-+        if (mEGLContextFactory == null) {
-+            mEGLContextFactory = new DefaultContextFactory();
-+        }
-+        if (mEGLWindowSurfaceFactory == null) {
-+            mEGLWindowSurfaceFactory = new DefaultWindowSurfaceFactory();
-+        }
-+        mRenderer = renderer;
-+        mGLThread = new GLThread(mThisWeakRef);
-+        mGLThread.start();
-+    }
-+
-+    /**
-+     * Install a custom EGLContextFactory.
-+     * <p>If this method is
-+     * called, it must be called before {@link #setRenderer(Renderer)}
-+     * is called.
-+     * <p>
-+     * If this method is not called, then by default
-+     * a context will be created with no shared context and
-+     * with a null attribute list.
-+     */
-+    public void setEGLContextFactory(EGLContextFactory factory) {
-+        checkRenderThreadState();
-+        mEGLContextFactory = factory;
-+    }
-+
-+    /**
-+     * Install a custom EGLWindowSurfaceFactory.
-+     * <p>If this method is
-+     * called, it must be called before {@link #setRenderer(Renderer)}
-+     * is called.
-+     * <p>
-+     * If this method is not called, then by default
-+     * a window surface will be created with a null attribute list.
-+     */
-+    public void setEGLWindowSurfaceFactory(EGLWindowSurfaceFactory factory) {
-+        checkRenderThreadState();
-+        mEGLWindowSurfaceFactory = factory;
-+    }
-+
-+    /**
-+     * Install a custom EGLConfigChooser.
-+     * <p>If this method is
-+     * called, it must be called before {@link #setRenderer(Renderer)}
-+     * is called.
-+     * <p>
-+     * If no setEGLConfigChooser method is called, then by default the
-+     * view will choose an EGLConfig that is compatible with the current
-+     * android.view.Surface, with a depth buffer depth of
-+     * at least 16 bits.
-+     * @param configChooser
-+     */
-+    public void setEGLConfigChooser(EGLConfigChooser configChooser) {
-+        checkRenderThreadState();
-+        mEGLConfigChooser = configChooser;
-+    }
-+
-+    /**
-+     * Install a config chooser which will choose a config
-+     * as close to 16-bit RGB as possible, with or without an optional depth
-+     * buffer as close to 16-bits as possible.
-+     * <p>If this method is
-+     * called, it must be called before {@link #setRenderer(Renderer)}
-+     * is called.
-+     * <p>
-+     * If no setEGLConfigChooser method is called, then by default the
-+     * view will choose an RGB_888 surface with a depth buffer depth of
-+     * at least 16 bits.
-+     *
-+     * @param needDepth
-+     */
-+    public void setEGLConfigChooser(boolean needDepth) {
-+        setEGLConfigChooser(new SimpleEGLConfigChooser(needDepth));
-+    }
-+
-+    /**
-+     * Install a config chooser which will choose a config
-+     * with at least the specified depthSize and stencilSize,
-+     * and exactly the specified redSize, greenSize, blueSize and alphaSize.
-+     * <p>If this method is
-+     * called, it must be called before {@link #setRenderer(Renderer)}
-+     * is called.
-+     * <p>
-+     * If no setEGLConfigChooser method is called, then by default the
-+     * view will choose an RGB_888 surface with a depth buffer depth of
-+     * at least 16 bits.
-+     *
-+     */
-+    public void setEGLConfigChooser(int redSize, int greenSize, int blueSize,
-+            int alphaSize, int depthSize, int stencilSize) {
-+        setEGLConfigChooser(new ComponentSizeChooser(redSize, greenSize,
-+                blueSize, alphaSize, depthSize, stencilSize));
-+    }
-+
-+    /**
-+     * Inform the default EGLContextFactory and default EGLConfigChooser
-+     * which EGLContext client version to pick.
-+     * <p>Use this method to create an OpenGL ES 2.0-compatible context.
-+     * Example:
-+     * <pre class="prettyprint">
-+     *     public MyView(Context context) {
-+     *         super(context);
-+     *         setEGLContextClientVersion(2); // Pick an OpenGL ES 2.0 context.
-+     *         setRenderer(new MyRenderer());
-+     *     }
-+     * </pre>
-+     * <p>Note: Activities which require OpenGL ES 2.0 should indicate this by
-+     * setting @lt;uses-feature android:glEsVersion="0x00020000" /> in the activity's
-+     * AndroidManifest.xml file.
-+     * <p>If this method is called, it must be called before {@link #setRenderer(Renderer)}
-+     * is called.
-+     * <p>This method only affects the behavior of the default EGLContexFactory and the
-+     * default EGLConfigChooser. If
-+     * {@link #setEGLContextFactory(EGLContextFactory)} has been called, then the supplied
-+     * EGLContextFactory is responsible for creating an OpenGL ES 2.0-compatible context.
-+     * If
-+     * {@link #setEGLConfigChooser(EGLConfigChooser)} has been called, then the supplied
-+     * EGLConfigChooser is responsible for choosing an OpenGL ES 2.0-compatible config.
-+     * @param version The EGLContext client version to choose. Use 2 for OpenGL ES 2.0
-+     */
-+    public void setEGLContextClientVersion(int version) {
-+        checkRenderThreadState();
-+        mEGLContextClientVersion = version;
-+    }
-+
-+    /**
-+     * Set the rendering mode. When renderMode is
-+     * RENDERMODE_CONTINUOUSLY, the renderer is called
-+     * repeatedly to re-render the scene. When renderMode
-+     * is RENDERMODE_WHEN_DIRTY, the renderer only rendered when the surface
-+     * is created, or when {@link #requestRender} is called. Defaults to RENDERMODE_CONTINUOUSLY.
-+     * <p>
-+     * Using RENDERMODE_WHEN_DIRTY can improve battery life and overall system performance
-+     * by allowing the GPU and CPU to idle when the view does not need to be updated.
-+     * <p>
-+     * This method can only be called after {@link #setRenderer(Renderer)}
-+     *
-+     * @param renderMode one of the RENDERMODE_X constants
-+     * @see #RENDERMODE_CONTINUOUSLY
-+     * @see #RENDERMODE_WHEN_DIRTY
-+     */
-+    public void setRenderMode(int renderMode) {
-+        mGLThread.setRenderMode(renderMode);
-+    }
-+
-+    /**
-+     * Get the current rendering mode. May be called
-+     * from any thread. Must not be called before a renderer has been set.
-+     * @return the current rendering mode.
-+     * @see #RENDERMODE_CONTINUOUSLY
-+     * @see #RENDERMODE_WHEN_DIRTY
-+     */
-+    public int getRenderMode() {
-+        return mGLThread.getRenderMode();
-+    }
-+
-+    /**
-+     * Request that the renderer render a frame.
-+     * This method is typically used when the render mode has been set to
-+     * {@link #RENDERMODE_WHEN_DIRTY}, so that frames are only rendered on demand.
-+     * May be called
-+     * from any thread. Must not be called before a renderer has been set.
-+     */
-+    public void requestRender() {
-+        mGLThread.requestRender();
-+    }
-+
-+    /**
-+     * This method is part of the SurfaceHolder.Callback interface, and is
-+     * not normally called or subclassed by clients of GLSurfaceView.
-+     */
-+    public void surfaceCreated(SurfaceHolder holder) {
-+        mGLThread.surfaceCreated();
-+    }
-+
-+    /**
-+     * This method is part of the SurfaceHolder.Callback interface, and is
-+     * not normally called or subclassed by clients of GLSurfaceView.
-+     */
-+    public void surfaceDestroyed(SurfaceHolder holder) {
-+        // Surface will be destroyed when we return
-+        mGLThread.surfaceDestroyed();
-+    }
-+
-+    /**
-+     * This method is part of the SurfaceHolder.Callback interface, and is
-+     * not normally called or subclassed by clients of GLSurfaceView.
-+     */
-+    public void surfaceChanged(SurfaceHolder holder, int format, int w, int h) {
-+        mGLThread.onWindowResize(w, h);
-+    }
-+
-+    /**
-+     * This method is part of the SurfaceHolder.Callback interface, and is
-+     * not normally called or subclassed by clients of GLSurfaceView.
-+     */
-+    @Override
-+    public void surfaceRedrawNeeded(SurfaceHolder holder) {
-+        if (mGLThread != null) {
-+            mGLThread.requestRenderAndWait();
-+        }
-+    }
-+
-+
-+    /**
-+     * Pause the rendering thread, optionally tearing down the EGL context
-+     * depending upon the value of {@link #setPreserveEGLContextOnPause(boolean)}.
-+     *
-+     * This method should be called when it is no longer desirable for the
-+     * GLSurfaceView to continue rendering, such as in response to
-+     * {@link android.app.Activity#onStop Activity.onStop}.
-+     *
-+     * Must not be called before a renderer has been set.
-+     */
-+    public void onPause() {
-+        mGLThread.onPause();
-+    }
-+
-+    /**
-+     * Resumes the rendering thread, re-creating the OpenGL context if necessary. It
-+     * is the counterpart to {@link #onPause()}.
-+     *
-+     * This method should typically be called in
-+     * {@link android.app.Activity#onStart Activity.onStart}.
-+     *
-+     * Must not be called before a renderer has been set.
-+     */
-+    public void onResume() {
-+        mGLThread.onResume();
-+    }
-+
-+    /**
-+     * Queue a runnable to be run on the GL rendering thread. This can be used
-+     * to communicate with the Renderer on the rendering thread.
-+     * Must not be called before a renderer has been set.
-+     * @param r the runnable to be run on the GL rendering thread.
-+     */
-+    public void queueEvent(Runnable r) {
-+        mGLThread.queueEvent(r);
-+    }
-+
-+    /**
-+     * This method is used as part of the View class and is not normally
-+     * called or subclassed by clients of GLSurfaceView.
-+     */
-+    @Override
-+    protected void onAttachedToWindow() {
-+        super.onAttachedToWindow();
-+        if (LOG_ATTACH_DETACH) {
-+            Log.d(TAG, "onAttachedToWindow reattach =" + mDetached);
-+        }
-+        if (mDetached && (mRenderer != null)) {
-+            int renderMode = RENDERMODE_CONTINUOUSLY;
-+            if (mGLThread != null) {
-+                renderMode = mGLThread.getRenderMode();
-+            }
-+            mGLThread = new GLThread(mThisWeakRef);
-+            if (renderMode != RENDERMODE_CONTINUOUSLY) {
-+                mGLThread.setRenderMode(renderMode);
-+            }
-+            mGLThread.start();
-+        }
-+        mDetached = false;
-+    }
-+
-+    @Override
-+    protected void onDetachedFromWindow() {
-+        if (LOG_ATTACH_DETACH) {
-+            Log.d(TAG, "onDetachedFromWindow");
-+        }
-+        if (mGLThread != null) {
-+            mGLThread.requestExitAndWait();
-+        }
-+        mDetached = true;
-+        super.onDetachedFromWindow();
-+    }
-+
-+    // ----------------------------------------------------------------------
-+
-+    /**
-+     * An interface used to wrap a GL interface.
-+     * <p>Typically
-+     * used for implementing debugging and tracing on top of the default
-+     * GL interface. You would typically use this by creating your own class
-+     * that implemented all the GL methods by delegating to another GL instance.
-+     * Then you could add your own behavior before or after calling the
-+     * delegate. All the GLWrapper would do was instantiate and return the
-+     * wrapper GL instance:
-+     * <pre class="prettyprint">
-+     * class MyGLWrapper implements GLWrapper {
-+     *     GL wrap(GL gl) {
-+     *         return new MyGLImplementation(gl);
-+     *     }
-+     *     static class MyGLImplementation implements GL,GL10,GL11,... {
-+     *         ...
-+     *     }
-+     * }
-+     * </pre>
-+     * @see #setGLWrapper(GLWrapper)
-+     */
-+    public interface GLWrapper {
-+        /**
-+         * Wraps a gl interface in another gl interface.
-+         * @param gl a GL interface that is to be wrapped.
-+         * @return either the input argument or another GL object that wraps the input argument.
-+         */
-+        GL wrap(GL gl);
-+    }
-+
-+    /**
-+     * A generic renderer interface.
-+     * <p>
-+     * The renderer is responsible for making OpenGL calls to render a frame.
-+     * <p>
-+     * GLSurfaceView clients typically create their own classes that implement
-+     * this interface, and then call {@link GLSurfaceView#setRenderer} to
-+     * register the renderer with the GLSurfaceView.
-+     * <p>
-+     *
-+     * <div class="special reference">
-+     * <h3>Developer Guides</h3>
-+     * <p>For more information about how to use OpenGL, read the
-+     * <a href="{@docRoot}guide/topics/graphics/opengl.html">OpenGL</a> developer guide.</p>
-+     * </div>
-+     *
-+     * <h3>Threading</h3>
-+     * The renderer will be called on a separate thread, so that rendering
-+     * performance is decoupled from the UI thread. Clients typically need to
-+     * communicate with the renderer from the UI thread, because that's where
-+     * input events are received. Clients can communicate using any of the
-+     * standard Java techniques for cross-thread communication, or they can
-+     * use the {@link GLSurfaceView#queueEvent(Runnable)} convenience method.
-+     * <p>
-+     * <h3>EGL Context Lost</h3>
-+     * There are situations where the EGL rendering context will be lost. This
-+     * typically happens when device wakes up after going to sleep. When
-+     * the EGL context is lost, all OpenGL resources (such as textures) that are
-+     * associated with that context will be automatically deleted. In order to
-+     * keep rendering correctly, a renderer must recreate any lost resources
-+     * that it still needs. The {@link #onSurfaceCreated(GL10, EGLConfig)} method
-+     * is a convenient place to do this.
-+     *
-+     *
-+     * @see #setRenderer(Renderer)
-+     */
-+    public interface Renderer {
-+        /**
-+         * Called when the surface is created or recreated.
-+         * <p>
-+         * Called when the rendering thread
-+         * starts and whenever the EGL context is lost. The EGL context will typically
-+         * be lost when the Android device awakes after going to sleep.
-+         * <p>
-+         * Since this method is called at the beginning of rendering, as well as
-+         * every time the EGL context is lost, this method is a convenient place to put
-+         * code to create resources that need to be created when the rendering
-+         * starts, and that need to be recreated when the EGL context is lost.
-+         * Textures are an example of a resource that you might want to create
-+         * here.
-+         * <p>
-+         * Note that when the EGL context is lost, all OpenGL resources associated
-+         * with that context will be automatically deleted. You do not need to call
-+         * the corresponding "glDelete" methods such as glDeleteTextures to
-+         * manually delete these lost resources.
-+         * <p>
-+         * @param gl the GL interface. Use <code>instanceof</code> to
-+         * test if the interface supports GL11 or higher interfaces.
-+         * @param config the EGLConfig of the created surface. Can be used
-+         * to create matching pbuffers.
-+         */
-+        void onSurfaceCreated(GL10 gl, EGLConfig config);
-+
-+        /**
-+         * Called when the surface changed size.
-+         * <p>
-+         * Called after the surface is created and whenever
-+         * the OpenGL ES surface size changes.
-+         * <p>
-+         * Typically you will set your viewport here. If your camera
-+         * is fixed then you could also set your projection matrix here:
-+         * <pre class="prettyprint">
-+         * void onSurfaceChanged(GL10 gl, int width, int height) {
-+         *     gl.glViewport(0, 0, width, height);
-+         *     // for a fixed camera, set the projection too
-+         *     float ratio = (float) width / height;
-+         *     gl.glMatrixMode(GL10.GL_PROJECTION);
-+         *     gl.glLoadIdentity();
-+         *     gl.glFrustumf(-ratio, ratio, -1, 1, 1, 10);
-+         * }
-+         * </pre>
-+         * @param gl the GL interface. Use <code>instanceof</code> to
-+         * test if the interface supports GL11 or higher interfaces.
-+         * @param width
-+         * @param height
-+         */
-+        void onSurfaceChanged(GL10 gl, int width, int height);
-+
-+        /**
-+         * Called to draw the current frame.
-+         * <p>
-+         * This method is responsible for drawing the current frame.
-+         * <p>
-+         * The implementation of this method typically looks like this:
-+         * <pre class="prettyprint">
-+         * void onDrawFrame(GL10 gl) {
-+         *     gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
-+         *     //... other gl calls to render the scene ...
-+         * }
-+         * </pre>
-+         * @param gl the GL interface. Use <code>instanceof</code> to
-+         * test if the interface supports GL11 or higher interfaces.
-+         */
-+        void onDrawFrame(GL10 gl);
-+    }
-+
-+    /**
-+     * An interface for customizing the eglCreateContext and eglDestroyContext calls.
-+     * <p>
-+     * This interface must be implemented by clients wishing to call
-+     * {@link GLSurfaceView#setEGLContextFactory(EGLContextFactory)}
-+     */
-+    public interface EGLContextFactory {
-+        EGLContext createContext(EGL10 egl, EGLDisplay display, EGLConfig eglConfig);
-+        void destroyContext(EGL10 egl, EGLDisplay display, EGLContext context);
-+    }
-+
-+    private class DefaultContextFactory implements EGLContextFactory {
-+        private int EGL_CONTEXT_CLIENT_VERSION = 0x3098;
-+
-+        public EGLContext createContext(EGL10 egl, EGLDisplay display, EGLConfig config) {
-+            int[] attrib_list = {EGL_CONTEXT_CLIENT_VERSION, mEGLContextClientVersion,
-+                    EGL10.EGL_NONE };
-+
-+            return egl.eglCreateContext(display, config, EGL10.EGL_NO_CONTEXT,
-+                    mEGLContextClientVersion != 0 ? attrib_list : null);
-+        }
-+
-+        public void destroyContext(EGL10 egl, EGLDisplay display,
-+                EGLContext context) {
-+            if (!egl.eglDestroyContext(display, context)) {
-+                Log.e("DefaultContextFactory", "display:" + display + " context: " + context);
-+                if (LOG_THREADS) {
-+                    Log.i("DefaultContextFactory", "tid=" + Thread.currentThread().getId());
-+                }
-+                EglHelper.throwEglException("eglDestroyContex", egl.eglGetError());
-+            }
-+        }
-+    }
-+
-+    /**
-+     * An interface for customizing the eglCreateWindowSurface and eglDestroySurface calls.
-+     * <p>
-+     * This interface must be implemented by clients wishing to call
-+     * {@link GLSurfaceView#setEGLWindowSurfaceFactory(EGLWindowSurfaceFactory)}
-+     */
-+    public interface EGLWindowSurfaceFactory {
-+        /**
-+         *  @return null if the surface cannot be constructed.
-+         */
-+        EGLSurface createWindowSurface(EGL10 egl, EGLDisplay display, EGLConfig config,
-+                Object nativeWindow);
-+        void destroySurface(EGL10 egl, EGLDisplay display, EGLSurface surface);
-+    }
-+
-+    private static class DefaultWindowSurfaceFactory implements EGLWindowSurfaceFactory {
-+
-+        public EGLSurface createWindowSurface(EGL10 egl, EGLDisplay display,
-+                EGLConfig config, Object nativeWindow) {
-+            EGLSurface result = null;
-+            try {
-+                result = egl.eglCreateWindowSurface(display, config, nativeWindow, null);
-+            } catch (IllegalArgumentException e) {
-+                // This exception indicates that the surface flinger surface
-+                // is not valid. This can happen if the surface flinger surface has
-+                // been torn down, but the application has not yet been
-+                // notified via SurfaceHolder.Callback.surfaceDestroyed.
-+                // In theory the application should be notified first,
-+                // but in practice sometimes it is not. See b/4588890
-+                Log.e(TAG, "eglCreateWindowSurface", e);
-+            }
-+            return result;
-+        }
-+
-+        public void destroySurface(EGL10 egl, EGLDisplay display,
-+                EGLSurface surface) {
-+            egl.eglDestroySurface(display, surface);
-+        }
-+    }
-+
-+    /**
-+     * An interface for choosing an EGLConfig configuration from a list of
-+     * potential configurations.
-+     * <p>
-+     * This interface must be implemented by clients wishing to call
-+     * {@link GLSurfaceView#setEGLConfigChooser(EGLConfigChooser)}
-+     */
-+    public interface EGLConfigChooser {
-+        /**
-+         * Choose a configuration from the list. Implementors typically
-+         * implement this method by calling
-+         * {@link EGL10#eglChooseConfig} and iterating through the results. Please consult the
-+         * EGL specification available from The Khronos Group to learn how to call eglChooseConfig.
-+         * @param egl the EGL10 for the current display.
-+         * @param display the current display.
-+         * @return the chosen configuration.
-+         */
-+        EGLConfig chooseConfig(EGL10 egl, EGLDisplay display);
-+    }
-+
-+    private abstract class BaseConfigChooser
-+            implements EGLConfigChooser {
-+        public BaseConfigChooser(int[] configSpec) {
-+            mConfigSpec = filterConfigSpec(configSpec);
-+        }
-+
-+        public EGLConfig chooseConfig(EGL10 egl, EGLDisplay display) {
-+            int[] num_config = new int[1];
-+            if (!egl.eglChooseConfig(display, mConfigSpec, null, 0,
-+                    num_config)) {
-+                throw new IllegalArgumentException("eglChooseConfig failed");
-+            }
-+
-+            int numConfigs = num_config[0];
-+
-+            if (numConfigs <= 0) {
-+                throw new IllegalArgumentException(
-+                        "No configs match configSpec");
-+            }
-+
-+            EGLConfig[] configs = new EGLConfig[numConfigs];
-+            if (!egl.eglChooseConfig(display, mConfigSpec, configs, numConfigs,
-+                    num_config)) {
-+                throw new IllegalArgumentException("eglChooseConfig#2 failed");
-+            }
-+            EGLConfig config = chooseConfig(egl, display, configs);
-+            if (config == null) {
-+                throw new IllegalArgumentException("No config chosen");
-+            }
-+            return config;
-+        }
-+
-+        abstract EGLConfig chooseConfig(EGL10 egl, EGLDisplay display,
-+                EGLConfig[] configs);
-+
-+        protected int[] mConfigSpec;
-+
-+        private int[] filterConfigSpec(int[] configSpec) {
-+            if (mEGLContextClientVersion != 2 && mEGLContextClientVersion != 3) {
-+                return configSpec;
-+            }
-+            /* We know none of the subclasses define EGL_RENDERABLE_TYPE.
-+             * And we know the configSpec is well formed.
-+             */
-+            int len = configSpec.length;
-+            int[] newConfigSpec = new int[len + 2];
-+            System.arraycopy(configSpec, 0, newConfigSpec, 0, len-1);
-+            newConfigSpec[len-1] = EGL10.EGL_RENDERABLE_TYPE;
-+            if (mEGLContextClientVersion == 2) {
-+                newConfigSpec[len] = EGL14.EGL_OPENGL_ES2_BIT;  /* EGL_OPENGL_ES2_BIT */
-+            } else {
-+                newConfigSpec[len] = EGLExt.EGL_OPENGL_ES3_BIT_KHR; /* EGL_OPENGL_ES3_BIT_KHR */
-+            }
-+            newConfigSpec[len+1] = EGL10.EGL_NONE;
-+            return newConfigSpec;
-+        }
-+    }
-+
-+    /**
-+     * Choose a configuration with exactly the specified r,g,b,a sizes,
-+     * and at least the specified depth and stencil sizes.
-+     */
-+    private class ComponentSizeChooser extends BaseConfigChooser {
-+        public ComponentSizeChooser(int redSize, int greenSize, int blueSize,
-+                int alphaSize, int depthSize, int stencilSize) {
-+            super(new int[] {
-+                    EGL10.EGL_RED_SIZE, redSize,
-+                    EGL10.EGL_GREEN_SIZE, greenSize,
-+                    EGL10.EGL_BLUE_SIZE, blueSize,
-+                    EGL10.EGL_ALPHA_SIZE, alphaSize,
-+                    EGL10.EGL_DEPTH_SIZE, depthSize,
-+                    EGL10.EGL_STENCIL_SIZE, stencilSize,
-+                    EGL10.EGL_NONE});
-+            mValue = new int[1];
-+            mRedSize = redSize;
-+            mGreenSize = greenSize;
-+            mBlueSize = blueSize;
-+            mAlphaSize = alphaSize;
-+            mDepthSize = depthSize;
-+            mStencilSize = stencilSize;
-+       }
-+
-+        @Override
-+        public EGLConfig chooseConfig(EGL10 egl, EGLDisplay display,
-+                EGLConfig[] configs) {
-+            for (EGLConfig config : configs) {
-+                int d = findConfigAttrib(egl, display, config,
-+                        EGL10.EGL_DEPTH_SIZE, 0);
-+                int s = findConfigAttrib(egl, display, config,
-+                        EGL10.EGL_STENCIL_SIZE, 0);
-+                if ((d >= mDepthSize) && (s >= mStencilSize)) {
-+                    int r = findConfigAttrib(egl, display, config,
-+                            EGL10.EGL_RED_SIZE, 0);
-+                    int g = findConfigAttrib(egl, display, config,
-+                             EGL10.EGL_GREEN_SIZE, 0);
-+                    int b = findConfigAttrib(egl, display, config,
-+                              EGL10.EGL_BLUE_SIZE, 0);
-+                    int a = findConfigAttrib(egl, display, config,
-+                            EGL10.EGL_ALPHA_SIZE, 0);
-+                    if ((r == mRedSize) && (g == mGreenSize)
-+                            && (b == mBlueSize) && (a == mAlphaSize)) {
-+                        return config;
-+                    }
-+                }
-+            }
-+            return null;
-+        }
-+
-+        private int findConfigAttrib(EGL10 egl, EGLDisplay display,
-+                EGLConfig config, int attribute, int defaultValue) {
-+
-+            if (egl.eglGetConfigAttrib(display, config, attribute, mValue)) {
-+                return mValue[0];
-+            }
-+            return defaultValue;
-+        }
-+
-+        private int[] mValue;
-+        // Subclasses can adjust these values:
-+        protected int mRedSize;
-+        protected int mGreenSize;
-+        protected int mBlueSize;
-+        protected int mAlphaSize;
-+        protected int mDepthSize;
-+        protected int mStencilSize;
-+        }
-+
-+    /**
-+     * This class will choose a RGB_888 surface with
-+     * or without a depth buffer.
-+     *
-+     */
-+    private class SimpleEGLConfigChooser extends ComponentSizeChooser {
-+        public SimpleEGLConfigChooser(boolean withDepthBuffer) {
-+            super(8, 8, 8, 0, withDepthBuffer ? 16 : 0, 0);
-+        }
-+    }
-+
-+    /**
-+     * An EGL helper class.
-+     */
-+
-+    private static class EglHelper {
-+        public EglHelper(WeakReference<GLSurfaceView> glSurfaceViewWeakRef) {
-+            mGLSurfaceViewWeakRef = glSurfaceViewWeakRef;
-+        }
-+
-+        /**
-+         * Initialize EGL for a given configuration spec.
-+         * @param configSpec
-+         */
-+        public void start() {
-+            if (LOG_EGL) {
-+                Log.w("EglHelper", "start() tid=" + Thread.currentThread().getId());
-+            }
-+            /*
-+             * Get an EGL instance
-+             */
-+            mEgl = (EGL10) EGLContext.getEGL();
-+
-+            /*
-+             * Get to the default display.
-+             */
-+            mEglDisplay = mEgl.eglGetDisplay(EGL10.EGL_DEFAULT_DISPLAY);
-+
-+            if (mEglDisplay == EGL10.EGL_NO_DISPLAY) {
-+                throw new RuntimeException("eglGetDisplay failed");
-+            }
-+
-+            /*
-+             * We can now initialize EGL for that display
-+             */
-+            int[] version = new int[2];
-+            if(!mEgl.eglInitialize(mEglDisplay, version)) {
-+                throw new RuntimeException("eglInitialize failed");
-+            }
-+            GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-+            if (view == null) {
-+                mEglConfig = null;
-+                mEglContext = null;
-+            } else {
-+                mEglConfig = view.mEGLConfigChooser.chooseConfig(mEgl, mEglDisplay);
-+
-+                /*
-+                * Create an EGL context. We want to do this as rarely as we can, because an
-+                * EGL context is a somewhat heavy object.
-+                */
-+                mEglContext = view.mEGLContextFactory.createContext(mEgl, mEglDisplay, mEglConfig);
-+            }
-+            if (mEglContext == null || mEglContext == EGL10.EGL_NO_CONTEXT) {
-+                mEglContext = null;
-+                throwEglException("createContext");
-+            }
-+            if (LOG_EGL) {
-+                Log.w("EglHelper", "createContext " + mEglContext + " tid=" + Thread.currentThread().getId());
-+            }
-+
-+            mEglSurface = null;
-+        }
-+
-+        /**
-+         * Create an egl surface for the current SurfaceHolder surface. If a surface
-+         * already exists, destroy it before creating the new surface.
-+         *
-+         * @return true if the surface was created successfully.
-+         */
-+        public boolean createSurface() {
-+            if (LOG_EGL) {
-+                Log.w("EglHelper", "createSurface()  tid=" + Thread.currentThread().getId());
-+            }
-+            /*
-+             * Check preconditions.
-+             */
-+            if (mEgl == null) {
-+                throw new RuntimeException("egl not initialized");
-+            }
-+            if (mEglDisplay == null) {
-+                throw new RuntimeException("eglDisplay not initialized");
-+            }
-+            if (mEglConfig == null) {
-+                throw new RuntimeException("mEglConfig not initialized");
-+            }
-+
-+            /*
-+             *  The window size has changed, so we need to create a new
-+             *  surface.
-+             */
-+            destroySurfaceImp();
-+
-+            /*
-+             * Create an EGL surface we can render into.
-+             */
-+            GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-+            if (view != null) {
-+                mEglSurface = view.mEGLWindowSurfaceFactory.createWindowSurface(mEgl,
-+                        mEglDisplay, mEglConfig, view.getHolder());
-+            } else {
-+                mEglSurface = null;
-+            }
-+
-+            if (mEglSurface == null || mEglSurface == EGL10.EGL_NO_SURFACE) {
-+                int error = mEgl.eglGetError();
-+                if (error == EGL10.EGL_BAD_NATIVE_WINDOW) {
-+                    Log.e("EglHelper", "createWindowSurface returned EGL_BAD_NATIVE_WINDOW.");
-+                }
-+                return false;
-+            }
-+
-+            /*
-+             * Before we can issue GL commands, we need to make sure
-+             * the context is current and bound to a surface.
-+             */
-+            if (!mEgl.eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface, mEglContext)) {
-+                /*
-+                 * Could not make the context current, probably because the underlying
-+                 * SurfaceView surface has been destroyed.
-+                 */
-+                logEglErrorAsWarning("EGLHelper", "eglMakeCurrent", mEgl.eglGetError());
-+                return false;
-+            }
-+
-+            return true;
-+        }
-+
-+        /**
-+         * Create a GL object for the current EGL context.
-+         * @return
-+         */
-+        GL createGL() {
-+
-+            GL gl = mEglContext.getGL();
-+            GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-+            if (view != null) {
-+                if (view.mGLWrapper != null) {
-+                    gl = view.mGLWrapper.wrap(gl);
-+                }
-+
-+                if ((view.mDebugFlags & (DEBUG_CHECK_GL_ERROR | DEBUG_LOG_GL_CALLS)) != 0) {
-+                    int configFlags = 0;
-+                    Writer log = null;
-+                    if ((view.mDebugFlags & DEBUG_CHECK_GL_ERROR) != 0) {
-+                        configFlags |= GLDebugHelper.CONFIG_CHECK_GL_ERROR;
-+                    }
-+                    if ((view.mDebugFlags & DEBUG_LOG_GL_CALLS) != 0) {
-+                        log = new LogWriter();
-+                    }
-+                    gl = GLDebugHelper.wrap(gl, configFlags, log);
-+                }
-+            }
-+            return gl;
-+        }
-+
-+        /**
-+         * Display the current render surface.
-+         * @return the EGL error code from eglSwapBuffers.
-+         */
-+        public int swap() {
-+            if (! mEgl.eglSwapBuffers(mEglDisplay, mEglSurface)) {
-+                return mEgl.eglGetError();
-+            }
-+            return EGL10.EGL_SUCCESS;
-+        }
-+
-+        public void destroySurface() {
-+            if (LOG_EGL) {
-+                Log.w("EglHelper", "destroySurface()  tid=" + Thread.currentThread().getId());
-+            }
-+            destroySurfaceImp();
-+        }
-+
-+        private void destroySurfaceImp() {
-+            if (mEglSurface != null && mEglSurface != EGL10.EGL_NO_SURFACE) {
-+                mEgl.eglMakeCurrent(mEglDisplay, EGL10.EGL_NO_SURFACE,
-+                        EGL10.EGL_NO_SURFACE,
-+                        EGL10.EGL_NO_CONTEXT);
-+                GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-+                if (view != null) {
-+                    view.mEGLWindowSurfaceFactory.destroySurface(mEgl, mEglDisplay, mEglSurface);
-+                }
-+                mEglSurface = null;
-+            }
-+        }
-+
-+        public void finish() {
-+            if (LOG_EGL) {
-+                Log.w("EglHelper", "finish() tid=" + Thread.currentThread().getId());
-+            }
-+            if (mEglContext != null) {
-+                GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-+                if (view != null) {
-+                    view.mEGLContextFactory.destroyContext(mEgl, mEglDisplay, mEglContext);
-+                }
-+                mEglContext = null;
-+            }
-+            if (mEglDisplay != null) {
-+                mEgl.eglTerminate(mEglDisplay);
-+                mEglDisplay = null;
-+            }
-+        }
-+
-+        private void throwEglException(String function) {
-+            throwEglException(function, mEgl.eglGetError());
-+        }
-+
-+        public static void throwEglException(String function, int error) {
-+            String message = formatEglError(function, error);
-+            if (LOG_THREADS) {
-+                Log.e("EglHelper", "throwEglException tid=" + Thread.currentThread().getId() + " "
-+                        + message);
-+            }
-+            throw new RuntimeException(message);
-+        }
-+
-+        public static void logEglErrorAsWarning(String tag, String function, int error) {
-+            Log.w(tag, formatEglError(function, error));
-+        }
-+
-+        public static String formatEglError(String function, int error) {
-+            return function + " failed: " + EGLLogWrapper.getErrorString(error);
-+        }
-+
-+        private WeakReference<GLSurfaceView> mGLSurfaceViewWeakRef;
-+        EGL10 mEgl;
-+        EGLDisplay mEglDisplay;
-+        EGLSurface mEglSurface;
-+        EGLConfig mEglConfig;
-+        EGLContext mEglContext;
-+
-+    }
-+
-+    /**
-+     * A generic GL Thread. Takes care of initializing EGL and GL. Delegates
-+     * to a Renderer instance to do the actual drawing. Can be configured to
-+     * render continuously or on request.
-+     *
-+     * All potentially blocking synchronization is done through the
-+     * sGLThreadManager object. This avoids multiple-lock ordering issues.
-+     *
-+     */
-+    static class GLThread extends Thread {
-+        GLThread(WeakReference<GLSurfaceView> glSurfaceViewWeakRef) {
-+            super();
-+            mWidth = 0;
-+            mHeight = 0;
-+            mRequestRender = true;
-+            mRenderMode = RENDERMODE_CONTINUOUSLY;
-+            mWantRenderNotification = false;
-+            mGLSurfaceViewWeakRef = glSurfaceViewWeakRef;
-+        }
-+
-+        @Override
-+        public void run() {
-+            setName("GLThread " + getId());
-+            if (LOG_THREADS) {
-+                Log.i("GLThread", "starting tid=" + getId());
-+            }
-+
-+            try {
-+                guardedRun();
-+            } catch (InterruptedException e) {
-+                // fall thru and exit normally
-+            } finally {
-+                sGLThreadManager.threadExiting(this);
-+            }
-+        }
-+
-+        /*
-+         * This private method should only be called inside a
-+         * synchronized(sGLThreadManager) block.
-+         */
-+        private void stopEglSurfaceLocked() {
-+            if (mHaveEglSurface) {
-+                mHaveEglSurface = false;
-+                mEglHelper.destroySurface();
-+            }
-+        }
-+
-+        /*
-+         * This private method should only be called inside a
-+         * synchronized(sGLThreadManager) block.
-+         */
-+        private void stopEglContextLocked() {
-+            if (mHaveEglContext) {
-+                mEglHelper.finish();
-+                mHaveEglContext = false;
-+                sGLThreadManager.releaseEglContextLocked(this);
-+            }
-+        }
-+        private void guardedRun() throws InterruptedException {
-+            mEglHelper = new EglHelper(mGLSurfaceViewWeakRef);
-+            mHaveEglContext = false;
-+            mHaveEglSurface = false;
-+            mWantRenderNotification = false;
-+
-+            try {
-+                GL10 gl = null;
-+                boolean createEglContext = false;
-+                boolean createEglSurface = false;
-+                boolean createGlInterface = false;
-+                boolean lostEglContext = false;
-+                boolean sizeChanged = false;
-+                boolean wantRenderNotification = false;
-+                boolean doRenderNotification = false;
-+                boolean askedToReleaseEglContext = false;
-+                int w = 0;
-+                int h = 0;
-+                Runnable event = null;
-+
-+                while (true) {
-+                    synchronized (sGLThreadManager) {
-+                        while (true) {
-+                            if (mShouldExit) {
-+                                return;
-+                            }
-+
-+                            if (! mEventQueue.isEmpty()) {
-+                                event = mEventQueue.remove(0);
-+                                break;
-+                            }
-+
-+                            // Update the pause state.
-+                            boolean pausing = false;
-+                            if (mPaused != mRequestPaused) {
-+                                pausing = mRequestPaused;
-+                                mPaused = mRequestPaused;
-+                                sGLThreadManager.notifyAll();
-+                                if (LOG_PAUSE_RESUME) {
-+                                    Log.i("GLThread", "mPaused is now " + mPaused + " tid=" + getId());
-+                                }
-+                            }
-+
-+                            // Do we need to give up the EGL context?
-+                            if (mShouldReleaseEglContext) {
-+                                if (LOG_SURFACE) {
-+                                    Log.i("GLThread", "releasing EGL context because asked to tid=" + getId());
-+                                }
-+                                stopEglSurfaceLocked();
-+                                stopEglContextLocked();
-+                                mShouldReleaseEglContext = false;
-+                                askedToReleaseEglContext = true;
-+                            }
-+
-+                            // Have we lost the EGL context?
-+                            if (lostEglContext) {
-+                                stopEglSurfaceLocked();
-+                                stopEglContextLocked();
-+                                lostEglContext = false;
-+                            }
-+
-+                            // When pausing, release the EGL surface:
-+                            if (pausing && mHaveEglSurface) {
-+                                if (LOG_SURFACE) {
-+                                    Log.i("GLThread", "releasing EGL surface because paused tid=" + getId());
-+                                }
-+                                stopEglSurfaceLocked();
-+                            }
-+
-+                            // When pausing, optionally release the EGL Context:
-+                            if (pausing && mHaveEglContext) {
-+                                GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-+                                boolean preserveEglContextOnPause = view == null ?
-+                                        false : view.mPreserveEGLContextOnPause;
-+                                if (!preserveEglContextOnPause) {
-+                                    stopEglContextLocked();
-+                                    if (LOG_SURFACE) {
-+                                        Log.i("GLThread", "releasing EGL context because paused tid=" + getId());
-+                                    }
-+                                }
-+                            }
-+
-+                            // Have we lost the SurfaceView surface?
-+                            if ((! mHasSurface) && (! mWaitingForSurface)) {
-+                                if (LOG_SURFACE) {
-+                                    Log.i("GLThread", "noticed surfaceView surface lost tid=" + getId());
-+                                }
-+                                if (mHaveEglSurface) {
-+                                    stopEglSurfaceLocked();
-+                                }
-+                                mWaitingForSurface = true;
-+                                mSurfaceIsBad = false;
-+                                sGLThreadManager.notifyAll();
-+                            }
-+
-+                            // Have we acquired the surface view surface?
-+                            if (mHasSurface && mWaitingForSurface) {
-+                                if (LOG_SURFACE) {
-+                                    Log.i("GLThread", "noticed surfaceView surface acquired tid=" + getId());
-+                                }
-+                                mWaitingForSurface = false;
-+                                sGLThreadManager.notifyAll();
-+                            }
-+
-+                            if (doRenderNotification) {
-+                                if (LOG_SURFACE) {
-+                                    Log.i("GLThread", "sending render notification tid=" + getId());
-+                                }
-+                                mWantRenderNotification = false;
-+                                doRenderNotification = false;
-+                                mRenderComplete = true;
-+                                sGLThreadManager.notifyAll();
-+                            }
-+
-+                            // Ready to draw?
-+                            if (readyToDraw()) {
-+
-+                                // If we don't have an EGL context, try to acquire one.
-+                                if (! mHaveEglContext) {
-+                                    if (askedToReleaseEglContext) {
-+                                        askedToReleaseEglContext = false;
-+                                    } else {
-+                                        try {
-+                                            mEglHelper.start();
-+                                        } catch (RuntimeException t) {
-+                                            sGLThreadManager.releaseEglContextLocked(this);
-+                                            throw t;
-+                                        }
-+                                        mHaveEglContext = true;
-+                                        createEglContext = true;
-+
-+                                        sGLThreadManager.notifyAll();
-+                                    }
-+                                }
-+
-+                                if (mHaveEglContext && !mHaveEglSurface) {
-+                                    mHaveEglSurface = true;
-+                                    createEglSurface = true;
-+                                    createGlInterface = true;
-+                                    sizeChanged = true;
-+                                }
-+
-+                                if (mHaveEglSurface) {
-+                                    if (mSizeChanged) {
-+                                        sizeChanged = true;
-+                                        w = mWidth;
-+                                        h = mHeight;
-+                                        mWantRenderNotification = true;
-+                                        if (LOG_SURFACE) {
-+                                            Log.i("GLThread",
-+                                                    "noticing that we want render notification tid="
-+                                                    + getId());
-+                                        }
-+
-+                                        // Destroy and recreate the EGL surface.
-+                                        createEglSurface = true;
-+
-+                                        mSizeChanged = false;
-+                                    }
-+                                    mRequestRender = false;
-+                                    sGLThreadManager.notifyAll();
-+                                    if (mWantRenderNotification) {
-+                                        wantRenderNotification = true;
-+                                    }
-+                                    break;
-+                                }
-+                            }
-+
-+                            // By design, this is the only place in a GLThread thread where we wait().
-+                            if (LOG_THREADS) {
-+                                Log.i("GLThread", "waiting tid=" + getId()
-+                                    + " mHaveEglContext: " + mHaveEglContext
-+                                    + " mHaveEglSurface: " + mHaveEglSurface
-+                                    + " mFinishedCreatingEglSurface: " + mFinishedCreatingEglSurface
-+                                    + " mPaused: " + mPaused
-+                                    + " mHasSurface: " + mHasSurface
-+                                    + " mSurfaceIsBad: " + mSurfaceIsBad
-+                                    + " mWaitingForSurface: " + mWaitingForSurface
-+                                    + " mWidth: " + mWidth
-+                                    + " mHeight: " + mHeight
-+                                    + " mRequestRender: " + mRequestRender
-+                                    + " mRenderMode: " + mRenderMode);
-+                            }
-+                            sGLThreadManager.wait();
-+                        }
-+                    } // end of synchronized(sGLThreadManager)
-+
-+                    if (event != null) {
-+                        event.run();
-+                        event = null;
-+                        continue;
-+                    }
-+
-+                    if (createEglSurface) {
-+                        if (LOG_SURFACE) {
-+                            Log.w("GLThread", "egl createSurface");
-+                        }
-+                        if (mEglHelper.createSurface()) {
-+                            synchronized(sGLThreadManager) {
-+                                mFinishedCreatingEglSurface = true;
-+                                sGLThreadManager.notifyAll();
-+                            }
-+                        } else {
-+                            synchronized(sGLThreadManager) {
-+                                mFinishedCreatingEglSurface = true;
-+                                mSurfaceIsBad = true;
-+                                sGLThreadManager.notifyAll();
-+                            }
-+                            continue;
-+                        }
-+                        createEglSurface = false;
-+                    }
-+
-+                    if (createGlInterface) {
-+                        gl = (GL10) mEglHelper.createGL();
-+
-+                        createGlInterface = false;
-+                    }
-+
-+                    if (createEglContext) {
-+                        if (LOG_RENDERER) {
-+                            Log.w("GLThread", "onSurfaceCreated");
-+                        }
-+                        GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-+                        if (view != null) {
-+                            try {
-+                                Trace.traceBegin(Trace.TRACE_TAG_VIEW, "onSurfaceCreated");
-+                                view.mRenderer.onSurfaceCreated(gl, mEglHelper.mEglConfig);
-+                            } finally {
-+                                Trace.traceEnd(Trace.TRACE_TAG_VIEW);
-+                            }
-+                        }
-+                        createEglContext = false;
-+                    }
-+
-+                    if (sizeChanged) {
-+                        if (LOG_RENDERER) {
-+                            Log.w("GLThread", "onSurfaceChanged(" + w + ", " + h + ")");
-+                        }
-+                        GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-+                        if (view != null) {
-+                            try {
-+                                Trace.traceBegin(Trace.TRACE_TAG_VIEW, "onSurfaceChanged");
-+                                view.mRenderer.onSurfaceChanged(gl, w, h);
-+                            } finally {
-+                                Trace.traceEnd(Trace.TRACE_TAG_VIEW);
-+                            }
-+                        }
-+                        sizeChanged = false;
-+                    }
-+
-+                    if (LOG_RENDERER_DRAW_FRAME) {
-+                        Log.w("GLThread", "onDrawFrame tid=" + getId());
-+                    }
-+                    {
-+                        GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-+                        if (view != null) {
-+                            try {
-+                                Trace.traceBegin(Trace.TRACE_TAG_VIEW, "onDrawFrame");
-+                                view.mRenderer.onDrawFrame(gl);
-+                            } finally {
-+                                Trace.traceEnd(Trace.TRACE_TAG_VIEW);
-+                            }
-+                        }
-+                    }
-+                    int swapError = mEglHelper.swap();
-+                    switch (swapError) {
-+                        case EGL10.EGL_SUCCESS:
-+                            break;
-+                        case EGL11.EGL_CONTEXT_LOST:
-+                            if (LOG_SURFACE) {
-+                                Log.i("GLThread", "egl context lost tid=" + getId());
-+                            }
-+                            lostEglContext = true;
-+                            break;
-+                        default:
-+                            // Other errors typically mean that the current surface is bad,
-+                            // probably because the SurfaceView surface has been destroyed,
-+                            // but we haven't been notified yet.
-+                            // Log the error to help developers understand why rendering stopped.
-+                            EglHelper.logEglErrorAsWarning("GLThread", "eglSwapBuffers", swapError);
-+
-+                            synchronized(sGLThreadManager) {
-+                                mSurfaceIsBad = true;
-+                                sGLThreadManager.notifyAll();
-+                            }
-+                            break;
-+                    }
-+
-+                    if (wantRenderNotification) {
-+                        doRenderNotification = true;
-+                        wantRenderNotification = false;
-+                    }
-+                }
-+
-+            } finally {
-+                /*
-+                 * clean-up everything...
-+                 */
-+                synchronized (sGLThreadManager) {
-+                    stopEglSurfaceLocked();
-+                    stopEglContextLocked();
-+                }
-+            }
-+        }
-+
-+        public boolean ableToDraw() {
-+            return mHaveEglContext && mHaveEglSurface && readyToDraw();
-+        }
-+
-+        private boolean readyToDraw() {
-+            return (!mPaused) && mHasSurface && (!mSurfaceIsBad)
-+                && (mWidth > 0) && (mHeight > 0)
-+                && (mRequestRender || (mRenderMode == RENDERMODE_CONTINUOUSLY));
-+        }
-+
-+        public void setRenderMode(int renderMode) {
-+            if ( !((RENDERMODE_WHEN_DIRTY <= renderMode) && (renderMode <= RENDERMODE_CONTINUOUSLY)) ) {
-+                throw new IllegalArgumentException("renderMode");
-+            }
-+            synchronized(sGLThreadManager) {
-+                mRenderMode = renderMode;
-+                sGLThreadManager.notifyAll();
-+            }
-+        }
-+
-+        public int getRenderMode() {
-+            synchronized(sGLThreadManager) {
-+                return mRenderMode;
-+            }
-+        }
-+
-+        public void requestRender() {
-+            synchronized(sGLThreadManager) {
-+                mRequestRender = true;
-+                sGLThreadManager.notifyAll();
-+            }
-+        }
-+
-+        public void requestRenderAndWait() {
-+            synchronized(sGLThreadManager) {
-+                // If we are already on the GL thread, this means a client callback
-+                // has caused reentrancy, for example via updating the SurfaceView parameters.
-+                // We will return to the client rendering code, so here we don't need to
-+                // do anything.
-+                if (Thread.currentThread() == this) {
-+                    return;
-+                }
-+
-+                mWantRenderNotification = true;
-+                mRequestRender = true;
-+                mRenderComplete = false;
-+
-+                sGLThreadManager.notifyAll();
-+
-+                while (!mExited && !mPaused && !mRenderComplete && ableToDraw()) {
-+                    try {
-+                        sGLThreadManager.wait();
-+                    } catch (InterruptedException ex) {
-+                        Thread.currentThread().interrupt();
-+                    }
-+                }
-+
-+            }
-+        }
-+
-+        public void surfaceCreated() {
-+            synchronized(sGLThreadManager) {
-+                if (LOG_THREADS) {
-+                    Log.i("GLThread", "surfaceCreated tid=" + getId());
-+                }
-+                mHasSurface = true;
-+                mFinishedCreatingEglSurface = false;
-+                sGLThreadManager.notifyAll();
-+                while (mWaitingForSurface
-+                       && !mFinishedCreatingEglSurface
-+                       && !mExited) {
-+                    try {
-+                        sGLThreadManager.wait();
-+                    } catch (InterruptedException e) {
-+                        Thread.currentThread().interrupt();
-+                    }
-+                }
-+            }
-+        }
-+
-+        public void surfaceDestroyed() {
-+            synchronized(sGLThreadManager) {
-+                if (LOG_THREADS) {
-+                    Log.i("GLThread", "surfaceDestroyed tid=" + getId());
-+                }
-+                mHasSurface = false;
-+                sGLThreadManager.notifyAll();
-+                while((!mWaitingForSurface) && (!mExited)) {
-+                    try {
-+                        sGLThreadManager.wait();
-+                    } catch (InterruptedException e) {
-+                        Thread.currentThread().interrupt();
-+                    }
-+                }
-+            }
-+        }
-+
-+        public void onPause() {
-+            synchronized (sGLThreadManager) {
-+                if (LOG_PAUSE_RESUME) {
-+                    Log.i("GLThread", "onPause tid=" + getId());
-+                }
-+                mRequestPaused = true;
-+                sGLThreadManager.notifyAll();
-+                while ((! mExited) && (! mPaused)) {
-+                    if (LOG_PAUSE_RESUME) {
-+                        Log.i("Main thread", "onPause waiting for mPaused.");
-+                    }
-+                    try {
-+                        sGLThreadManager.wait();
-+                    } catch (InterruptedException ex) {
-+                        Thread.currentThread().interrupt();
-+                    }
-+                }
-+            }
-+        }
-+
-+        public void onResume() {
-+            synchronized (sGLThreadManager) {
-+                if (LOG_PAUSE_RESUME) {
-+                    Log.i("GLThread", "onResume tid=" + getId());
-+                }
-+                mRequestPaused = false;
-+                mRequestRender = true;
-+                mRenderComplete = false;
-+                sGLThreadManager.notifyAll();
-+                while ((! mExited) && mPaused && (!mRenderComplete)) {
-+                    if (LOG_PAUSE_RESUME) {
-+                        Log.i("Main thread", "onResume waiting for !mPaused.");
-+                    }
-+                    try {
-+                        sGLThreadManager.wait();
-+                    } catch (InterruptedException ex) {
-+                        Thread.currentThread().interrupt();
-+                    }
-+                }
-+            }
-+        }
-+
-+        public void onWindowResize(int w, int h) {
-+            synchronized (sGLThreadManager) {
-+                mWidth = w;
-+                mHeight = h;
-+                mSizeChanged = true;
-+                mRequestRender = true;
-+                mRenderComplete = false;
-+
-+                // If we are already on the GL thread, this means a client callback
-+                // has caused reentrancy, for example via updating the SurfaceView parameters.
-+                // We need to process the size change eventually though and update our EGLSurface.
-+                // So we set the parameters and return so they can be processed on our
-+                // next iteration.
-+                if (Thread.currentThread() == this) {
-+                    return;
-+                }
-+
-+                sGLThreadManager.notifyAll();
-+
-+                // Wait for thread to react to resize and render a frame
-+                while (! mExited && !mPaused && !mRenderComplete
-+                        && ableToDraw()) {
-+                    if (LOG_SURFACE) {
-+                        Log.i("Main thread", "onWindowResize waiting for render complete from tid=" + getId());
-+                    }
-+                    try {
-+                        sGLThreadManager.wait();
-+                    } catch (InterruptedException ex) {
-+                        Thread.currentThread().interrupt();
-+                    }
-+                }
-+            }
-+        }
-+
-+        public void requestExitAndWait() {
-+            // don't call this from GLThread thread or it is a guaranteed
-+            // deadlock!
-+            synchronized(sGLThreadManager) {
-+                mShouldExit = true;
-+                sGLThreadManager.notifyAll();
-+                while (! mExited) {
-+                    try {
-+                        sGLThreadManager.wait();
-+                    } catch (InterruptedException ex) {
-+                        Thread.currentThread().interrupt();
-+                    }
-+                }
-+            }
-+        }
-+
-+        public void requestReleaseEglContextLocked() {
-+            mShouldReleaseEglContext = true;
-+            sGLThreadManager.notifyAll();
-+        }
-+
-+        /**
-+         * Queue an "event" to be run on the GL rendering thread.
-+         * @param r the runnable to be run on the GL rendering thread.
-+         */
-+        public void queueEvent(Runnable r) {
-+            if (r == null) {
-+                throw new IllegalArgumentException("r must not be null");
-+            }
-+            synchronized(sGLThreadManager) {
-+                mEventQueue.add(r);
-+                sGLThreadManager.notifyAll();
-+            }
-+        }
-+
-+        // Once the thread is started, all accesses to the following member
-+        // variables are protected by the sGLThreadManager monitor
-+        private boolean mShouldExit;
-+        private boolean mExited;
-+        private boolean mRequestPaused;
-+        private boolean mPaused;
-+        private boolean mHasSurface;
-+        private boolean mSurfaceIsBad;
-+        private boolean mWaitingForSurface;
-+        private boolean mHaveEglContext;
-+        private boolean mHaveEglSurface;
-+        private boolean mFinishedCreatingEglSurface;
-+        private boolean mShouldReleaseEglContext;
-+        private int mWidth;
-+        private int mHeight;
-+        private int mRenderMode;
-+        private boolean mRequestRender;
-+        private boolean mWantRenderNotification;
-+        private boolean mRenderComplete;
-+        private ArrayList<Runnable> mEventQueue = new ArrayList<Runnable>();
-+        private boolean mSizeChanged = true;
-+
-+        // End of member variables protected by the sGLThreadManager monitor.
-+
-+        private EglHelper mEglHelper;
-+
-+        /**
-+         * Set once at thread construction time, nulled out when the parent view is garbage
-+         * called. This weak reference allows the GLSurfaceView to be garbage collected while
-+         * the GLThread is still alive.
-+         */
-+        private WeakReference<GLSurfaceView> mGLSurfaceViewWeakRef;
-+
-+    }
-+
-+    static class LogWriter extends Writer {
-+
-+        @Override public void close() {
-+            flushBuilder();
-+        }
-+
-+        @Override public void flush() {
-+            flushBuilder();
-+        }
-+
-+        @Override public void write(char[] buf, int offset, int count) {
-+            for(int i = 0; i < count; i++) {
-+                char c = buf[offset + i];
-+                if ( c == '\n') {
-+                    flushBuilder();
-+                }
-+                else {
-+                    mBuilder.append(c);
-+                }
-+            }
-+        }
-+
-+        private void flushBuilder() {
-+            if (mBuilder.length() > 0) {
-+                Log.v("GLSurfaceView", mBuilder.toString());
-+                mBuilder.delete(0, mBuilder.length());
-+            }
-+        }
-+
-+        private StringBuilder mBuilder = new StringBuilder();
-+    }
-+
-+
-+    private void checkRenderThreadState() {
-+        if (mGLThread != null) {
-+            throw new IllegalStateException(
-+                    "setRenderer has already been called for this instance.");
-+        }
-+    }
-+
-+    private static class GLThreadManager {
-+        private static String TAG = "GLThreadManager";
-+
-+        public synchronized void threadExiting(GLThread thread) {
-+            if (LOG_THREADS) {
-+                Log.i("GLThread", "exiting tid=" +  thread.getId());
-+            }
-+            thread.mExited = true;
-+            notifyAll();
-+        }
-+
-+        /*
-+         * Releases the EGL context. Requires that we are already in the
-+         * sGLThreadManager monitor when this is called.
-+         */
-+        public void releaseEglContextLocked(GLThread thread) {
-+            notifyAll();
-+        }
-+    }
-+
-+    private static final GLThreadManager sGLThreadManager = new GLThreadManager();
-+
-+    private final WeakReference<GLSurfaceView> mThisWeakRef =
-+            new WeakReference<GLSurfaceView>(this);
-+    private GLThread mGLThread;
-+    private Renderer mRenderer;
-+    private boolean mDetached;
-+    private EGLConfigChooser mEGLConfigChooser;
-+    private EGLContextFactory mEGLContextFactory;
-+    private EGLWindowSurfaceFactory mEGLWindowSurfaceFactory;
-+    private GLWrapper mGLWrapper;
-+    private int mDebugFlags;
-+    private int mEGLContextClientVersion;
-+    private boolean mPreserveEGLContextOnPause;
-+}
diff -Naur frameworksRaw/base/opengl/java/android/opengl/GLSurfaceView.java.orig.rej.orig frameworksModified/base/opengl/java/android/opengl/GLSurfaceView.java.orig.rej.orig
--- frameworksRaw/base/opengl/java/android/opengl/GLSurfaceView.java.orig.rej.orig	2017-07-06 15:34:16.038012304 +0530
+++ frameworksModified/base/opengl/java/android/opengl/GLSurfaceView.java.orig.rej.orig	1970-01-01 05:30:00.000000000 +0530
@@ -1,1915 +0,0 @@
---- base/opengl/java/android/opengl/GLSurfaceView.java.orig	1970-01-01 05:30:00.000000000 +0530
-+++ base/opengl/java/android/opengl/GLSurfaceView.java.orig	2017-07-06 13:50:03.679302904 +0530
-@@ -0,0 +1,1912 @@
-+/*
-+ * Copyright (C) 2008 The Android Open Source Project
-+ *
-+ * Licensed under the Apache License, Version 2.0 (the "License");
-+ * you may not use this file except in compliance with the License.
-+ * You may obtain a copy of the License at
-+ *
-+ *      http://www.apache.org/licenses/LICENSE-2.0
-+ *
-+ * Unless required by applicable law or agreed to in writing, software
-+ * distributed under the License is distributed on an "AS IS" BASIS,
-+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-+ * See the License for the specific language governing permissions and
-+ * limitations under the License.
-+ */
-+
-+package android.opengl;
-+
-+import android.content.Context;
-+import android.os.Trace;
-+import android.util.AttributeSet;
-+import android.util.Log;
-+import android.view.SurfaceHolder;
-+import android.view.SurfaceView;
-+
-+import java.io.Writer;
-+import java.lang.ref.WeakReference;
-+import java.util.ArrayList;
-+
-+import javax.microedition.khronos.egl.EGL10;
-+import javax.microedition.khronos.egl.EGL11;
-+import javax.microedition.khronos.egl.EGLConfig;
-+import javax.microedition.khronos.egl.EGLContext;
-+import javax.microedition.khronos.egl.EGLDisplay;
-+import javax.microedition.khronos.egl.EGLSurface;
-+import javax.microedition.khronos.opengles.GL;
-+import javax.microedition.khronos.opengles.GL10;
-+
-+/**
-+ * An implementation of SurfaceView that uses the dedicated surface for
-+ * displaying OpenGL rendering.
-+ * <p>
-+ * A GLSurfaceView provides the following features:
-+ * <p>
-+ * <ul>
-+ * <li>Manages a surface, which is a special piece of memory that can be
-+ * composited into the Android view system.
-+ * <li>Manages an EGL display, which enables OpenGL to render into a surface.
-+ * <li>Accepts a user-provided Renderer object that does the actual rendering.
-+ * <li>Renders on a dedicated thread to decouple rendering performance from the
-+ * UI thread.
-+ * <li>Supports both on-demand and continuous rendering.
-+ * <li>Optionally wraps, traces, and/or error-checks the renderer's OpenGL calls.
-+ * </ul>
-+ *
-+ * <div class="special reference">
-+ * <h3>Developer Guides</h3>
-+ * <p>For more information about how to use OpenGL, read the
-+ * <a href="{@docRoot}guide/topics/graphics/opengl.html">OpenGL</a> developer guide.</p>
-+ * </div>
-+ *
-+ * <h3>Using GLSurfaceView</h3>
-+ * <p>
-+ * Typically you use GLSurfaceView by subclassing it and overriding one or more of the
-+ * View system input event methods. If your application does not need to override event
-+ * methods then GLSurfaceView can be used as-is. For the most part
-+ * GLSurfaceView behavior is customized by calling "set" methods rather than by subclassing.
-+ * For example, unlike a regular View, drawing is delegated to a separate Renderer object which
-+ * is registered with the GLSurfaceView
-+ * using the {@link #setRenderer(Renderer)} call.
-+ * <p>
-+ * <h3>Initializing GLSurfaceView</h3>
-+ * All you have to do to initialize a GLSurfaceView is call {@link #setRenderer(Renderer)}.
-+ * However, if desired, you can modify the default behavior of GLSurfaceView by calling one or
-+ * more of these methods before calling setRenderer:
-+ * <ul>
-+ * <li>{@link #setDebugFlags(int)}
-+ * <li>{@link #setEGLConfigChooser(boolean)}
-+ * <li>{@link #setEGLConfigChooser(EGLConfigChooser)}
-+ * <li>{@link #setEGLConfigChooser(int, int, int, int, int, int)}
-+ * <li>{@link #setGLWrapper(GLWrapper)}
-+ * </ul>
-+ * <p>
-+ * <h4>Specifying the android.view.Surface</h4>
-+ * By default GLSurfaceView will create a PixelFormat.RGB_888 format surface. If a translucent
-+ * surface is required, call getHolder().setFormat(PixelFormat.TRANSLUCENT).
-+ * The exact format of a TRANSLUCENT surface is device dependent, but it will be
-+ * a 32-bit-per-pixel surface with 8 bits per component.
-+ * <p>
-+ * <h4>Choosing an EGL Configuration</h4>
-+ * A given Android device may support multiple EGLConfig rendering configurations.
-+ * The available configurations may differ in how may channels of data are present, as
-+ * well as how many bits are allocated to each channel. Therefore, the first thing
-+ * GLSurfaceView has to do when starting to render is choose what EGLConfig to use.
-+ * <p>
-+ * By default GLSurfaceView chooses a EGLConfig that has an RGB_888 pixel format,
-+ * with at least a 16-bit depth buffer and no stencil.
-+ * <p>
-+ * If you would prefer a different EGLConfig
-+ * you can override the default behavior by calling one of the
-+ * setEGLConfigChooser methods.
-+ * <p>
-+ * <h4>Debug Behavior</h4>
-+ * You can optionally modify the behavior of GLSurfaceView by calling
-+ * one or more of the debugging methods {@link #setDebugFlags(int)},
-+ * and {@link #setGLWrapper}. These methods may be called before and/or after setRenderer, but
-+ * typically they are called before setRenderer so that they take effect immediately.
-+ * <p>
-+ * <h4>Setting a Renderer</h4>
-+ * Finally, you must call {@link #setRenderer} to register a {@link Renderer}.
-+ * The renderer is
-+ * responsible for doing the actual OpenGL rendering.
-+ * <p>
-+ * <h3>Rendering Mode</h3>
-+ * Once the renderer is set, you can control whether the renderer draws
-+ * continuously or on-demand by calling
-+ * {@link #setRenderMode}. The default is continuous rendering.
-+ * <p>
-+ * <h3>Activity Life-cycle</h3>
-+ * A GLSurfaceView must be notified when to pause and resume rendering. GLSurfaceView clients
-+ * are required to call {@link #onPause()} when the activity stops and
-+ * {@link #onResume()} when the activity starts. These calls allow GLSurfaceView to
-+ * pause and resume the rendering thread, and also allow GLSurfaceView to release and recreate
-+ * the OpenGL display.
-+ * <p>
-+ * <h3>Handling events</h3>
-+ * <p>
-+ * To handle an event you will typically subclass GLSurfaceView and override the
-+ * appropriate method, just as you would with any other View. However, when handling
-+ * the event, you may need to communicate with the Renderer object
-+ * that's running in the rendering thread. You can do this using any
-+ * standard Java cross-thread communication mechanism. In addition,
-+ * one relatively easy way to communicate with your renderer is
-+ * to call
-+ * {@link #queueEvent(Runnable)}. For example:
-+ * <pre class="prettyprint">
-+ * class MyGLSurfaceView extends GLSurfaceView {
-+ *
-+ *     private MyRenderer mMyRenderer;
-+ *
-+ *     public void start() {
-+ *         mMyRenderer = ...;
-+ *         setRenderer(mMyRenderer);
-+ *     }
-+ *
-+ *     public boolean onKeyDown(int keyCode, KeyEvent event) {
-+ *         if (keyCode == KeyEvent.KEYCODE_DPAD_CENTER) {
-+ *             queueEvent(new Runnable() {
-+ *                 // This method will be called on the rendering
-+ *                 // thread:
-+ *                 public void run() {
-+ *                     mMyRenderer.handleDpadCenter();
-+ *                 }});
-+ *             return true;
-+ *         }
-+ *         return super.onKeyDown(keyCode, event);
-+ *     }
-+ * }
-+ * </pre>
-+ *
-+ */
-+public class GLSurfaceView extends SurfaceView implements SurfaceHolder.Callback2 {
-+    private final static String TAG = "GLSurfaceView";
-+    private final static boolean LOG_ATTACH_DETACH = false;
-+    private final static boolean LOG_THREADS = false;
-+    private final static boolean LOG_PAUSE_RESUME = false;
-+    private final static boolean LOG_SURFACE = false;
-+    private final static boolean LOG_RENDERER = false;
-+    private final static boolean LOG_RENDERER_DRAW_FRAME = false;
-+    private final static boolean LOG_EGL = false;
-+    /**
-+     * The renderer only renders
-+     * when the surface is created, or when {@link #requestRender} is called.
-+     *
-+     * @see #getRenderMode()
-+     * @see #setRenderMode(int)
-+     * @see #requestRender()
-+     */
-+    public final static int RENDERMODE_WHEN_DIRTY = 0;
-+    /**
-+     * The renderer is called
-+     * continuously to re-render the scene.
-+     *
-+     * @see #getRenderMode()
-+     * @see #setRenderMode(int)
-+     */
-+    public final static int RENDERMODE_CONTINUOUSLY = 1;
-+
-+    /**
-+     * Check glError() after every GL call and throw an exception if glError indicates
-+     * that an error has occurred. This can be used to help track down which OpenGL ES call
-+     * is causing an error.
-+     *
-+     * @see #getDebugFlags
-+     * @see #setDebugFlags
-+     */
-+    public final static int DEBUG_CHECK_GL_ERROR = 1;
-+
-+    /**
-+     * Log GL calls to the system log at "verbose" level with tag "GLSurfaceView".
-+     *
-+     * @see #getDebugFlags
-+     * @see #setDebugFlags
-+     */
-+    public final static int DEBUG_LOG_GL_CALLS = 2;
-+
-+    /**
-+     * Standard View constructor. In order to render something, you
-+     * must call {@link #setRenderer} to register a renderer.
-+     */
-+    public GLSurfaceView(Context context) {
-+        super(context);
-+        init();
-+    }
-+
-+    /**
-+     * Standard View constructor. In order to render something, you
-+     * must call {@link #setRenderer} to register a renderer.
-+     */
-+    public GLSurfaceView(Context context, AttributeSet attrs) {
-+        super(context, attrs);
-+        init();
-+    }
-+
-+    @Override
-+    protected void finalize() throws Throwable {
-+        try {
-+            if (mGLThread != null) {
-+                // GLThread may still be running if this view was never
-+                // attached to a window.
-+                mGLThread.requestExitAndWait();
-+            }
-+        } finally {
-+            super.finalize();
-+        }
-+    }
-+
-+    private void init() {
-+        // Install a SurfaceHolder.Callback so we get notified when the
-+        // underlying surface is created and destroyed
-+        SurfaceHolder holder = getHolder();
-+        holder.addCallback(this);
-+        // setFormat is done by SurfaceView in SDK 2.3 and newer. Uncomment
-+        // this statement if back-porting to 2.2 or older:
-+        // holder.setFormat(PixelFormat.RGB_565);
-+        //
-+        // setType is not needed for SDK 2.0 or newer. Uncomment this
-+        // statement if back-porting this code to older SDKs.
-+        // holder.setType(SurfaceHolder.SURFACE_TYPE_GPU);
-+    }
-+
-+    /**
-+     * Set the glWrapper. If the glWrapper is not null, its
-+     * {@link GLWrapper#wrap(GL)} method is called
-+     * whenever a surface is created. A GLWrapper can be used to wrap
-+     * the GL object that's passed to the renderer. Wrapping a GL
-+     * object enables examining and modifying the behavior of the
-+     * GL calls made by the renderer.
-+     * <p>
-+     * Wrapping is typically used for debugging purposes.
-+     * <p>
-+     * The default value is null.
-+     * @param glWrapper the new GLWrapper
-+     */
-+    public void setGLWrapper(GLWrapper glWrapper) {
-+        mGLWrapper = glWrapper;
-+    }
-+
-+    /**
-+     * Set the debug flags to a new value. The value is
-+     * constructed by OR-together zero or more
-+     * of the DEBUG_CHECK_* constants. The debug flags take effect
-+     * whenever a surface is created. The default value is zero.
-+     * @param debugFlags the new debug flags
-+     * @see #DEBUG_CHECK_GL_ERROR
-+     * @see #DEBUG_LOG_GL_CALLS
-+     */
-+    public void setDebugFlags(int debugFlags) {
-+        mDebugFlags = debugFlags;
-+    }
-+
-+    /**
-+     * Get the current value of the debug flags.
-+     * @return the current value of the debug flags.
-+     */
-+    public int getDebugFlags() {
-+        return mDebugFlags;
-+    }
-+
-+    /**
-+     * Control whether the EGL context is preserved when the GLSurfaceView is paused and
-+     * resumed.
-+     * <p>
-+     * If set to true, then the EGL context may be preserved when the GLSurfaceView is paused.
-+     * <p>
-+     * Prior to API level 11, whether the EGL context is actually preserved or not
-+     * depends upon whether the Android device can support an arbitrary number of
-+     * EGL contexts or not. Devices that can only support a limited number of EGL
-+     * contexts must release the EGL context in order to allow multiple applications
-+     * to share the GPU.
-+     * <p>
-+     * If set to false, the EGL context will be released when the GLSurfaceView is paused,
-+     * and recreated when the GLSurfaceView is resumed.
-+     * <p>
-+     *
-+     * The default is false.
-+     *
-+     * @param preserveOnPause preserve the EGL context when paused
-+     */
-+    public void setPreserveEGLContextOnPause(boolean preserveOnPause) {
-+        mPreserveEGLContextOnPause = preserveOnPause;
-+    }
-+
-+    /**
-+     * @return true if the EGL context will be preserved when paused
-+     */
-+    public boolean getPreserveEGLContextOnPause() {
-+        return mPreserveEGLContextOnPause;
-+    }
-+
-+    /**
-+     * Set the renderer associated with this view. Also starts the thread that
-+     * will call the renderer, which in turn causes the rendering to start.
-+     * <p>This method should be called once and only once in the life-cycle of
-+     * a GLSurfaceView.
-+     * <p>The following GLSurfaceView methods can only be called <em>before</em>
-+     * setRenderer is called:
-+     * <ul>
-+     * <li>{@link #setEGLConfigChooser(boolean)}
-+     * <li>{@link #setEGLConfigChooser(EGLConfigChooser)}
-+     * <li>{@link #setEGLConfigChooser(int, int, int, int, int, int)}
-+     * </ul>
-+     * <p>
-+     * The following GLSurfaceView methods can only be called <em>after</em>
-+     * setRenderer is called:
-+     * <ul>
-+     * <li>{@link #getRenderMode()}
-+     * <li>{@link #onPause()}
-+     * <li>{@link #onResume()}
-+     * <li>{@link #queueEvent(Runnable)}
-+     * <li>{@link #requestRender()}
-+     * <li>{@link #setRenderMode(int)}
-+     * </ul>
-+     *
-+     * @param renderer the renderer to use to perform OpenGL drawing.
-+     */
-+    public void setRenderer(Renderer renderer) {
-+        checkRenderThreadState();
-+        if (mEGLConfigChooser == null) {
-+            mEGLConfigChooser = new SimpleEGLConfigChooser(true);
-+        }
-+        if (mEGLContextFactory == null) {
-+            mEGLContextFactory = new DefaultContextFactory();
-+        }
-+        if (mEGLWindowSurfaceFactory == null) {
-+            mEGLWindowSurfaceFactory = new DefaultWindowSurfaceFactory();
-+        }
-+        mRenderer = renderer;
-+        mGLThread = new GLThread(mThisWeakRef);
-+        mGLThread.start();
-+    }
-+
-+    /**
-+     * Install a custom EGLContextFactory.
-+     * <p>If this method is
-+     * called, it must be called before {@link #setRenderer(Renderer)}
-+     * is called.
-+     * <p>
-+     * If this method is not called, then by default
-+     * a context will be created with no shared context and
-+     * with a null attribute list.
-+     */
-+    public void setEGLContextFactory(EGLContextFactory factory) {
-+        checkRenderThreadState();
-+        mEGLContextFactory = factory;
-+    }
-+
-+    /**
-+     * Install a custom EGLWindowSurfaceFactory.
-+     * <p>If this method is
-+     * called, it must be called before {@link #setRenderer(Renderer)}
-+     * is called.
-+     * <p>
-+     * If this method is not called, then by default
-+     * a window surface will be created with a null attribute list.
-+     */
-+    public void setEGLWindowSurfaceFactory(EGLWindowSurfaceFactory factory) {
-+        checkRenderThreadState();
-+        mEGLWindowSurfaceFactory = factory;
-+    }
-+
-+    /**
-+     * Install a custom EGLConfigChooser.
-+     * <p>If this method is
-+     * called, it must be called before {@link #setRenderer(Renderer)}
-+     * is called.
-+     * <p>
-+     * If no setEGLConfigChooser method is called, then by default the
-+     * view will choose an EGLConfig that is compatible with the current
-+     * android.view.Surface, with a depth buffer depth of
-+     * at least 16 bits.
-+     * @param configChooser
-+     */
-+    public void setEGLConfigChooser(EGLConfigChooser configChooser) {
-+        checkRenderThreadState();
-+        mEGLConfigChooser = configChooser;
-+    }
-+
-+    /**
-+     * Install a config chooser which will choose a config
-+     * as close to 16-bit RGB as possible, with or without an optional depth
-+     * buffer as close to 16-bits as possible.
-+     * <p>If this method is
-+     * called, it must be called before {@link #setRenderer(Renderer)}
-+     * is called.
-+     * <p>
-+     * If no setEGLConfigChooser method is called, then by default the
-+     * view will choose an RGB_888 surface with a depth buffer depth of
-+     * at least 16 bits.
-+     *
-+     * @param needDepth
-+     */
-+    public void setEGLConfigChooser(boolean needDepth) {
-+        setEGLConfigChooser(new SimpleEGLConfigChooser(needDepth));
-+    }
-+
-+    /**
-+     * Install a config chooser which will choose a config
-+     * with at least the specified depthSize and stencilSize,
-+     * and exactly the specified redSize, greenSize, blueSize and alphaSize.
-+     * <p>If this method is
-+     * called, it must be called before {@link #setRenderer(Renderer)}
-+     * is called.
-+     * <p>
-+     * If no setEGLConfigChooser method is called, then by default the
-+     * view will choose an RGB_888 surface with a depth buffer depth of
-+     * at least 16 bits.
-+     *
-+     */
-+    public void setEGLConfigChooser(int redSize, int greenSize, int blueSize,
-+            int alphaSize, int depthSize, int stencilSize) {
-+        setEGLConfigChooser(new ComponentSizeChooser(redSize, greenSize,
-+                blueSize, alphaSize, depthSize, stencilSize));
-+    }
-+
-+    /**
-+     * Inform the default EGLContextFactory and default EGLConfigChooser
-+     * which EGLContext client version to pick.
-+     * <p>Use this method to create an OpenGL ES 2.0-compatible context.
-+     * Example:
-+     * <pre class="prettyprint">
-+     *     public MyView(Context context) {
-+     *         super(context);
-+     *         setEGLContextClientVersion(2); // Pick an OpenGL ES 2.0 context.
-+     *         setRenderer(new MyRenderer());
-+     *     }
-+     * </pre>
-+     * <p>Note: Activities which require OpenGL ES 2.0 should indicate this by
-+     * setting @lt;uses-feature android:glEsVersion="0x00020000" /> in the activity's
-+     * AndroidManifest.xml file.
-+     * <p>If this method is called, it must be called before {@link #setRenderer(Renderer)}
-+     * is called.
-+     * <p>This method only affects the behavior of the default EGLContexFactory and the
-+     * default EGLConfigChooser. If
-+     * {@link #setEGLContextFactory(EGLContextFactory)} has been called, then the supplied
-+     * EGLContextFactory is responsible for creating an OpenGL ES 2.0-compatible context.
-+     * If
-+     * {@link #setEGLConfigChooser(EGLConfigChooser)} has been called, then the supplied
-+     * EGLConfigChooser is responsible for choosing an OpenGL ES 2.0-compatible config.
-+     * @param version The EGLContext client version to choose. Use 2 for OpenGL ES 2.0
-+     */
-+    public void setEGLContextClientVersion(int version) {
-+        checkRenderThreadState();
-+        mEGLContextClientVersion = version;
-+    }
-+
-+    /**
-+     * Set the rendering mode. When renderMode is
-+     * RENDERMODE_CONTINUOUSLY, the renderer is called
-+     * repeatedly to re-render the scene. When renderMode
-+     * is RENDERMODE_WHEN_DIRTY, the renderer only rendered when the surface
-+     * is created, or when {@link #requestRender} is called. Defaults to RENDERMODE_CONTINUOUSLY.
-+     * <p>
-+     * Using RENDERMODE_WHEN_DIRTY can improve battery life and overall system performance
-+     * by allowing the GPU and CPU to idle when the view does not need to be updated.
-+     * <p>
-+     * This method can only be called after {@link #setRenderer(Renderer)}
-+     *
-+     * @param renderMode one of the RENDERMODE_X constants
-+     * @see #RENDERMODE_CONTINUOUSLY
-+     * @see #RENDERMODE_WHEN_DIRTY
-+     */
-+    public void setRenderMode(int renderMode) {
-+        mGLThread.setRenderMode(renderMode);
-+    }
-+
-+    /**
-+     * Get the current rendering mode. May be called
-+     * from any thread. Must not be called before a renderer has been set.
-+     * @return the current rendering mode.
-+     * @see #RENDERMODE_CONTINUOUSLY
-+     * @see #RENDERMODE_WHEN_DIRTY
-+     */
-+    public int getRenderMode() {
-+        return mGLThread.getRenderMode();
-+    }
-+
-+    /**
-+     * Request that the renderer render a frame.
-+     * This method is typically used when the render mode has been set to
-+     * {@link #RENDERMODE_WHEN_DIRTY}, so that frames are only rendered on demand.
-+     * May be called
-+     * from any thread. Must not be called before a renderer has been set.
-+     */
-+    public void requestRender() {
-+        mGLThread.requestRender();
-+    }
-+
-+    /**
-+     * This method is part of the SurfaceHolder.Callback interface, and is
-+     * not normally called or subclassed by clients of GLSurfaceView.
-+     */
-+    public void surfaceCreated(SurfaceHolder holder) {
-+        mGLThread.surfaceCreated();
-+    }
-+
-+    /**
-+     * This method is part of the SurfaceHolder.Callback interface, and is
-+     * not normally called or subclassed by clients of GLSurfaceView.
-+     */
-+    public void surfaceDestroyed(SurfaceHolder holder) {
-+        // Surface will be destroyed when we return
-+        mGLThread.surfaceDestroyed();
-+    }
-+
-+    /**
-+     * This method is part of the SurfaceHolder.Callback interface, and is
-+     * not normally called or subclassed by clients of GLSurfaceView.
-+     */
-+    public void surfaceChanged(SurfaceHolder holder, int format, int w, int h) {
-+        mGLThread.onWindowResize(w, h);
-+    }
-+
-+    /**
-+     * This method is part of the SurfaceHolder.Callback interface, and is
-+     * not normally called or subclassed by clients of GLSurfaceView.
-+     */
-+    @Override
-+    public void surfaceRedrawNeeded(SurfaceHolder holder) {
-+        if (mGLThread != null) {
-+            mGLThread.requestRenderAndWait();
-+        }
-+    }
-+
-+
-+    /**
-+     * Pause the rendering thread, optionally tearing down the EGL context
-+     * depending upon the value of {@link #setPreserveEGLContextOnPause(boolean)}.
-+     *
-+     * This method should be called when it is no longer desirable for the
-+     * GLSurfaceView to continue rendering, such as in response to
-+     * {@link android.app.Activity#onStop Activity.onStop}.
-+     *
-+     * Must not be called before a renderer has been set.
-+     */
-+    public void onPause() {
-+        mGLThread.onPause();
-+    }
-+
-+    /**
-+     * Resumes the rendering thread, re-creating the OpenGL context if necessary. It
-+     * is the counterpart to {@link #onPause()}.
-+     *
-+     * This method should typically be called in
-+     * {@link android.app.Activity#onStart Activity.onStart}.
-+     *
-+     * Must not be called before a renderer has been set.
-+     */
-+    public void onResume() {
-+        mGLThread.onResume();
-+    }
-+
-+    /**
-+     * Queue a runnable to be run on the GL rendering thread. This can be used
-+     * to communicate with the Renderer on the rendering thread.
-+     * Must not be called before a renderer has been set.
-+     * @param r the runnable to be run on the GL rendering thread.
-+     */
-+    public void queueEvent(Runnable r) {
-+        mGLThread.queueEvent(r);
-+    }
-+
-+    /**
-+     * This method is used as part of the View class and is not normally
-+     * called or subclassed by clients of GLSurfaceView.
-+     */
-+    @Override
-+    protected void onAttachedToWindow() {
-+        super.onAttachedToWindow();
-+        if (LOG_ATTACH_DETACH) {
-+            Log.d(TAG, "onAttachedToWindow reattach =" + mDetached);
-+        }
-+        if (mDetached && (mRenderer != null)) {
-+            int renderMode = RENDERMODE_CONTINUOUSLY;
-+            if (mGLThread != null) {
-+                renderMode = mGLThread.getRenderMode();
-+            }
-+            mGLThread = new GLThread(mThisWeakRef);
-+            if (renderMode != RENDERMODE_CONTINUOUSLY) {
-+                mGLThread.setRenderMode(renderMode);
-+            }
-+            mGLThread.start();
-+        }
-+        mDetached = false;
-+    }
-+
-+    @Override
-+    protected void onDetachedFromWindow() {
-+        if (LOG_ATTACH_DETACH) {
-+            Log.d(TAG, "onDetachedFromWindow");
-+        }
-+        if (mGLThread != null) {
-+            mGLThread.requestExitAndWait();
-+        }
-+        mDetached = true;
-+        super.onDetachedFromWindow();
-+    }
-+
-+    // ----------------------------------------------------------------------
-+
-+    /**
-+     * An interface used to wrap a GL interface.
-+     * <p>Typically
-+     * used for implementing debugging and tracing on top of the default
-+     * GL interface. You would typically use this by creating your own class
-+     * that implemented all the GL methods by delegating to another GL instance.
-+     * Then you could add your own behavior before or after calling the
-+     * delegate. All the GLWrapper would do was instantiate and return the
-+     * wrapper GL instance:
-+     * <pre class="prettyprint">
-+     * class MyGLWrapper implements GLWrapper {
-+     *     GL wrap(GL gl) {
-+     *         return new MyGLImplementation(gl);
-+     *     }
-+     *     static class MyGLImplementation implements GL,GL10,GL11,... {
-+     *         ...
-+     *     }
-+     * }
-+     * </pre>
-+     * @see #setGLWrapper(GLWrapper)
-+     */
-+    public interface GLWrapper {
-+        /**
-+         * Wraps a gl interface in another gl interface.
-+         * @param gl a GL interface that is to be wrapped.
-+         * @return either the input argument or another GL object that wraps the input argument.
-+         */
-+        GL wrap(GL gl);
-+    }
-+
-+    /**
-+     * A generic renderer interface.
-+     * <p>
-+     * The renderer is responsible for making OpenGL calls to render a frame.
-+     * <p>
-+     * GLSurfaceView clients typically create their own classes that implement
-+     * this interface, and then call {@link GLSurfaceView#setRenderer} to
-+     * register the renderer with the GLSurfaceView.
-+     * <p>
-+     *
-+     * <div class="special reference">
-+     * <h3>Developer Guides</h3>
-+     * <p>For more information about how to use OpenGL, read the
-+     * <a href="{@docRoot}guide/topics/graphics/opengl.html">OpenGL</a> developer guide.</p>
-+     * </div>
-+     *
-+     * <h3>Threading</h3>
-+     * The renderer will be called on a separate thread, so that rendering
-+     * performance is decoupled from the UI thread. Clients typically need to
-+     * communicate with the renderer from the UI thread, because that's where
-+     * input events are received. Clients can communicate using any of the
-+     * standard Java techniques for cross-thread communication, or they can
-+     * use the {@link GLSurfaceView#queueEvent(Runnable)} convenience method.
-+     * <p>
-+     * <h3>EGL Context Lost</h3>
-+     * There are situations where the EGL rendering context will be lost. This
-+     * typically happens when device wakes up after going to sleep. When
-+     * the EGL context is lost, all OpenGL resources (such as textures) that are
-+     * associated with that context will be automatically deleted. In order to
-+     * keep rendering correctly, a renderer must recreate any lost resources
-+     * that it still needs. The {@link #onSurfaceCreated(GL10, EGLConfig)} method
-+     * is a convenient place to do this.
-+     *
-+     *
-+     * @see #setRenderer(Renderer)
-+     */
-+    public interface Renderer {
-+        /**
-+         * Called when the surface is created or recreated.
-+         * <p>
-+         * Called when the rendering thread
-+         * starts and whenever the EGL context is lost. The EGL context will typically
-+         * be lost when the Android device awakes after going to sleep.
-+         * <p>
-+         * Since this method is called at the beginning of rendering, as well as
-+         * every time the EGL context is lost, this method is a convenient place to put
-+         * code to create resources that need to be created when the rendering
-+         * starts, and that need to be recreated when the EGL context is lost.
-+         * Textures are an example of a resource that you might want to create
-+         * here.
-+         * <p>
-+         * Note that when the EGL context is lost, all OpenGL resources associated
-+         * with that context will be automatically deleted. You do not need to call
-+         * the corresponding "glDelete" methods such as glDeleteTextures to
-+         * manually delete these lost resources.
-+         * <p>
-+         * @param gl the GL interface. Use <code>instanceof</code> to
-+         * test if the interface supports GL11 or higher interfaces.
-+         * @param config the EGLConfig of the created surface. Can be used
-+         * to create matching pbuffers.
-+         */
-+        void onSurfaceCreated(GL10 gl, EGLConfig config);
-+
-+        /**
-+         * Called when the surface changed size.
-+         * <p>
-+         * Called after the surface is created and whenever
-+         * the OpenGL ES surface size changes.
-+         * <p>
-+         * Typically you will set your viewport here. If your camera
-+         * is fixed then you could also set your projection matrix here:
-+         * <pre class="prettyprint">
-+         * void onSurfaceChanged(GL10 gl, int width, int height) {
-+         *     gl.glViewport(0, 0, width, height);
-+         *     // for a fixed camera, set the projection too
-+         *     float ratio = (float) width / height;
-+         *     gl.glMatrixMode(GL10.GL_PROJECTION);
-+         *     gl.glLoadIdentity();
-+         *     gl.glFrustumf(-ratio, ratio, -1, 1, 1, 10);
-+         * }
-+         * </pre>
-+         * @param gl the GL interface. Use <code>instanceof</code> to
-+         * test if the interface supports GL11 or higher interfaces.
-+         * @param width
-+         * @param height
-+         */
-+        void onSurfaceChanged(GL10 gl, int width, int height);
-+
-+        /**
-+         * Called to draw the current frame.
-+         * <p>
-+         * This method is responsible for drawing the current frame.
-+         * <p>
-+         * The implementation of this method typically looks like this:
-+         * <pre class="prettyprint">
-+         * void onDrawFrame(GL10 gl) {
-+         *     gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
-+         *     //... other gl calls to render the scene ...
-+         * }
-+         * </pre>
-+         * @param gl the GL interface. Use <code>instanceof</code> to
-+         * test if the interface supports GL11 or higher interfaces.
-+         */
-+        void onDrawFrame(GL10 gl);
-+    }
-+
-+    /**
-+     * An interface for customizing the eglCreateContext and eglDestroyContext calls.
-+     * <p>
-+     * This interface must be implemented by clients wishing to call
-+     * {@link GLSurfaceView#setEGLContextFactory(EGLContextFactory)}
-+     */
-+    public interface EGLContextFactory {
-+        EGLContext createContext(EGL10 egl, EGLDisplay display, EGLConfig eglConfig);
-+        void destroyContext(EGL10 egl, EGLDisplay display, EGLContext context);
-+    }
-+
-+    private class DefaultContextFactory implements EGLContextFactory {
-+        private int EGL_CONTEXT_CLIENT_VERSION = 0x3098;
-+
-+        public EGLContext createContext(EGL10 egl, EGLDisplay display, EGLConfig config) {
-+            int[] attrib_list = {EGL_CONTEXT_CLIENT_VERSION, mEGLContextClientVersion,
-+                    EGL10.EGL_NONE };
-+
-+            return egl.eglCreateContext(display, config, EGL10.EGL_NO_CONTEXT,
-+                    mEGLContextClientVersion != 0 ? attrib_list : null);
-+        }
-+
-+        public void destroyContext(EGL10 egl, EGLDisplay display,
-+                EGLContext context) {
-+            if (!egl.eglDestroyContext(display, context)) {
-+                Log.e("DefaultContextFactory", "display:" + display + " context: " + context);
-+                if (LOG_THREADS) {
-+                    Log.i("DefaultContextFactory", "tid=" + Thread.currentThread().getId());
-+                }
-+                EglHelper.throwEglException("eglDestroyContex", egl.eglGetError());
-+            }
-+        }
-+    }
-+
-+    /**
-+     * An interface for customizing the eglCreateWindowSurface and eglDestroySurface calls.
-+     * <p>
-+     * This interface must be implemented by clients wishing to call
-+     * {@link GLSurfaceView#setEGLWindowSurfaceFactory(EGLWindowSurfaceFactory)}
-+     */
-+    public interface EGLWindowSurfaceFactory {
-+        /**
-+         *  @return null if the surface cannot be constructed.
-+         */
-+        EGLSurface createWindowSurface(EGL10 egl, EGLDisplay display, EGLConfig config,
-+                Object nativeWindow);
-+        void destroySurface(EGL10 egl, EGLDisplay display, EGLSurface surface);
-+    }
-+
-+    private static class DefaultWindowSurfaceFactory implements EGLWindowSurfaceFactory {
-+
-+        public EGLSurface createWindowSurface(EGL10 egl, EGLDisplay display,
-+                EGLConfig config, Object nativeWindow) {
-+            EGLSurface result = null;
-+            try {
-+                result = egl.eglCreateWindowSurface(display, config, nativeWindow, null);
-+            } catch (IllegalArgumentException e) {
-+                // This exception indicates that the surface flinger surface
-+                // is not valid. This can happen if the surface flinger surface has
-+                // been torn down, but the application has not yet been
-+                // notified via SurfaceHolder.Callback.surfaceDestroyed.
-+                // In theory the application should be notified first,
-+                // but in practice sometimes it is not. See b/4588890
-+                Log.e(TAG, "eglCreateWindowSurface", e);
-+            }
-+            return result;
-+        }
-+
-+        public void destroySurface(EGL10 egl, EGLDisplay display,
-+                EGLSurface surface) {
-+            egl.eglDestroySurface(display, surface);
-+        }
-+    }
-+
-+    /**
-+     * An interface for choosing an EGLConfig configuration from a list of
-+     * potential configurations.
-+     * <p>
-+     * This interface must be implemented by clients wishing to call
-+     * {@link GLSurfaceView#setEGLConfigChooser(EGLConfigChooser)}
-+     */
-+    public interface EGLConfigChooser {
-+        /**
-+         * Choose a configuration from the list. Implementors typically
-+         * implement this method by calling
-+         * {@link EGL10#eglChooseConfig} and iterating through the results. Please consult the
-+         * EGL specification available from The Khronos Group to learn how to call eglChooseConfig.
-+         * @param egl the EGL10 for the current display.
-+         * @param display the current display.
-+         * @return the chosen configuration.
-+         */
-+        EGLConfig chooseConfig(EGL10 egl, EGLDisplay display);
-+    }
-+
-+    private abstract class BaseConfigChooser
-+            implements EGLConfigChooser {
-+        public BaseConfigChooser(int[] configSpec) {
-+            mConfigSpec = filterConfigSpec(configSpec);
-+        }
-+
-+        public EGLConfig chooseConfig(EGL10 egl, EGLDisplay display) {
-+            int[] num_config = new int[1];
-+            if (!egl.eglChooseConfig(display, mConfigSpec, null, 0,
-+                    num_config)) {
-+                throw new IllegalArgumentException("eglChooseConfig failed");
-+            }
-+
-+            int numConfigs = num_config[0];
-+
-+            if (numConfigs <= 0) {
-+                throw new IllegalArgumentException(
-+                        "No configs match configSpec");
-+            }
-+
-+            EGLConfig[] configs = new EGLConfig[numConfigs];
-+            if (!egl.eglChooseConfig(display, mConfigSpec, configs, numConfigs,
-+                    num_config)) {
-+                throw new IllegalArgumentException("eglChooseConfig#2 failed");
-+            }
-+            EGLConfig config = chooseConfig(egl, display, configs);
-+            if (config == null) {
-+                throw new IllegalArgumentException("No config chosen");
-+            }
-+            return config;
-+        }
-+
-+        abstract EGLConfig chooseConfig(EGL10 egl, EGLDisplay display,
-+                EGLConfig[] configs);
-+
-+        protected int[] mConfigSpec;
-+
-+        private int[] filterConfigSpec(int[] configSpec) {
-+            if (mEGLContextClientVersion != 2 && mEGLContextClientVersion != 3) {
-+                return configSpec;
-+            }
-+            /* We know none of the subclasses define EGL_RENDERABLE_TYPE.
-+             * And we know the configSpec is well formed.
-+             */
-+            int len = configSpec.length;
-+            int[] newConfigSpec = new int[len + 2];
-+            System.arraycopy(configSpec, 0, newConfigSpec, 0, len-1);
-+            newConfigSpec[len-1] = EGL10.EGL_RENDERABLE_TYPE;
-+            if (mEGLContextClientVersion == 2) {
-+                newConfigSpec[len] = EGL14.EGL_OPENGL_ES2_BIT;  /* EGL_OPENGL_ES2_BIT */
-+            } else {
-+                newConfigSpec[len] = EGLExt.EGL_OPENGL_ES3_BIT_KHR; /* EGL_OPENGL_ES3_BIT_KHR */
-+            }
-+            newConfigSpec[len+1] = EGL10.EGL_NONE;
-+            return newConfigSpec;
-+        }
-+    }
-+
-+    /**
-+     * Choose a configuration with exactly the specified r,g,b,a sizes,
-+     * and at least the specified depth and stencil sizes.
-+     */
-+    private class ComponentSizeChooser extends BaseConfigChooser {
-+        public ComponentSizeChooser(int redSize, int greenSize, int blueSize,
-+                int alphaSize, int depthSize, int stencilSize) {
-+            super(new int[] {
-+                    EGL10.EGL_RED_SIZE, redSize,
-+                    EGL10.EGL_GREEN_SIZE, greenSize,
-+                    EGL10.EGL_BLUE_SIZE, blueSize,
-+                    EGL10.EGL_ALPHA_SIZE, alphaSize,
-+                    EGL10.EGL_DEPTH_SIZE, depthSize,
-+                    EGL10.EGL_STENCIL_SIZE, stencilSize,
-+                    EGL10.EGL_NONE});
-+            mValue = new int[1];
-+            mRedSize = redSize;
-+            mGreenSize = greenSize;
-+            mBlueSize = blueSize;
-+            mAlphaSize = alphaSize;
-+            mDepthSize = depthSize;
-+            mStencilSize = stencilSize;
-+       }
-+
-+        @Override
-+        public EGLConfig chooseConfig(EGL10 egl, EGLDisplay display,
-+                EGLConfig[] configs) {
-+            for (EGLConfig config : configs) {
-+                int d = findConfigAttrib(egl, display, config,
-+                        EGL10.EGL_DEPTH_SIZE, 0);
-+                int s = findConfigAttrib(egl, display, config,
-+                        EGL10.EGL_STENCIL_SIZE, 0);
-+                if ((d >= mDepthSize) && (s >= mStencilSize)) {
-+                    int r = findConfigAttrib(egl, display, config,
-+                            EGL10.EGL_RED_SIZE, 0);
-+                    int g = findConfigAttrib(egl, display, config,
-+                             EGL10.EGL_GREEN_SIZE, 0);
-+                    int b = findConfigAttrib(egl, display, config,
-+                              EGL10.EGL_BLUE_SIZE, 0);
-+                    int a = findConfigAttrib(egl, display, config,
-+                            EGL10.EGL_ALPHA_SIZE, 0);
-+                    if ((r == mRedSize) && (g == mGreenSize)
-+                            && (b == mBlueSize) && (a == mAlphaSize)) {
-+                        return config;
-+                    }
-+                }
-+            }
-+            return null;
-+        }
-+
-+        private int findConfigAttrib(EGL10 egl, EGLDisplay display,
-+                EGLConfig config, int attribute, int defaultValue) {
-+
-+            if (egl.eglGetConfigAttrib(display, config, attribute, mValue)) {
-+                return mValue[0];
-+            }
-+            return defaultValue;
-+        }
-+
-+        private int[] mValue;
-+        // Subclasses can adjust these values:
-+        protected int mRedSize;
-+        protected int mGreenSize;
-+        protected int mBlueSize;
-+        protected int mAlphaSize;
-+        protected int mDepthSize;
-+        protected int mStencilSize;
-+        }
-+
-+    /**
-+     * This class will choose a RGB_888 surface with
-+     * or without a depth buffer.
-+     *
-+     */
-+    private class SimpleEGLConfigChooser extends ComponentSizeChooser {
-+        public SimpleEGLConfigChooser(boolean withDepthBuffer) {
-+            super(8, 8, 8, 0, withDepthBuffer ? 16 : 0, 0);
-+        }
-+    }
-+
-+    /**
-+     * An EGL helper class.
-+     */
-+
-+    private static class EglHelper {
-+        public EglHelper(WeakReference<GLSurfaceView> glSurfaceViewWeakRef) {
-+            mGLSurfaceViewWeakRef = glSurfaceViewWeakRef;
-+        }
-+
-+        /**
-+         * Initialize EGL for a given configuration spec.
-+         * @param configSpec
-+         */
-+        public void start() {
-+            if (LOG_EGL) {
-+                Log.w("EglHelper", "start() tid=" + Thread.currentThread().getId());
-+            }
-+            /*
-+             * Get an EGL instance
-+             */
-+            mEgl = (EGL10) EGLContext.getEGL();
-+
-+            /*
-+             * Get to the default display.
-+             */
-+            mEglDisplay = mEgl.eglGetDisplay(EGL10.EGL_DEFAULT_DISPLAY);
-+
-+            if (mEglDisplay == EGL10.EGL_NO_DISPLAY) {
-+                throw new RuntimeException("eglGetDisplay failed");
-+            }
-+
-+            /*
-+             * We can now initialize EGL for that display
-+             */
-+            int[] version = new int[2];
-+            if(!mEgl.eglInitialize(mEglDisplay, version)) {
-+                throw new RuntimeException("eglInitialize failed");
-+            }
-+            GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-+            if (view == null) {
-+                mEglConfig = null;
-+                mEglContext = null;
-+            } else {
-+                mEglConfig = view.mEGLConfigChooser.chooseConfig(mEgl, mEglDisplay);
-+
-+                /*
-+                * Create an EGL context. We want to do this as rarely as we can, because an
-+                * EGL context is a somewhat heavy object.
-+                */
-+                mEglContext = view.mEGLContextFactory.createContext(mEgl, mEglDisplay, mEglConfig);
-+            }
-+            if (mEglContext == null || mEglContext == EGL10.EGL_NO_CONTEXT) {
-+                mEglContext = null;
-+                throwEglException("createContext");
-+            }
-+            if (LOG_EGL) {
-+                Log.w("EglHelper", "createContext " + mEglContext + " tid=" + Thread.currentThread().getId());
-+            }
-+
-+            mEglSurface = null;
-+        }
-+
-+        /**
-+         * Create an egl surface for the current SurfaceHolder surface. If a surface
-+         * already exists, destroy it before creating the new surface.
-+         *
-+         * @return true if the surface was created successfully.
-+         */
-+        public boolean createSurface() {
-+            if (LOG_EGL) {
-+                Log.w("EglHelper", "createSurface()  tid=" + Thread.currentThread().getId());
-+            }
-+            /*
-+             * Check preconditions.
-+             */
-+            if (mEgl == null) {
-+                throw new RuntimeException("egl not initialized");
-+            }
-+            if (mEglDisplay == null) {
-+                throw new RuntimeException("eglDisplay not initialized");
-+            }
-+            if (mEglConfig == null) {
-+                throw new RuntimeException("mEglConfig not initialized");
-+            }
-+
-+            /*
-+             *  The window size has changed, so we need to create a new
-+             *  surface.
-+             */
-+            destroySurfaceImp();
-+
-+            /*
-+             * Create an EGL surface we can render into.
-+             */
-+            GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-+            if (view != null) {
-+                mEglSurface = view.mEGLWindowSurfaceFactory.createWindowSurface(mEgl,
-+                        mEglDisplay, mEglConfig, view.getHolder());
-+            } else {
-+                mEglSurface = null;
-+            }
-+
-+            if (mEglSurface == null || mEglSurface == EGL10.EGL_NO_SURFACE) {
-+                int error = mEgl.eglGetError();
-+                if (error == EGL10.EGL_BAD_NATIVE_WINDOW) {
-+                    Log.e("EglHelper", "createWindowSurface returned EGL_BAD_NATIVE_WINDOW.");
-+                }
-+                return false;
-+            }
-+
-+            /*
-+             * Before we can issue GL commands, we need to make sure
-+             * the context is current and bound to a surface.
-+             */
-+            if (!mEgl.eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface, mEglContext)) {
-+                /*
-+                 * Could not make the context current, probably because the underlying
-+                 * SurfaceView surface has been destroyed.
-+                 */
-+                logEglErrorAsWarning("EGLHelper", "eglMakeCurrent", mEgl.eglGetError());
-+                return false;
-+            }
-+
-+            return true;
-+        }
-+
-+        /**
-+         * Create a GL object for the current EGL context.
-+         * @return
-+         */
-+        GL createGL() {
-+
-+            GL gl = mEglContext.getGL();
-+            GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-+            if (view != null) {
-+                if (view.mGLWrapper != null) {
-+                    gl = view.mGLWrapper.wrap(gl);
-+                }
-+
-+                if ((view.mDebugFlags & (DEBUG_CHECK_GL_ERROR | DEBUG_LOG_GL_CALLS)) != 0) {
-+                    int configFlags = 0;
-+                    Writer log = null;
-+                    if ((view.mDebugFlags & DEBUG_CHECK_GL_ERROR) != 0) {
-+                        configFlags |= GLDebugHelper.CONFIG_CHECK_GL_ERROR;
-+                    }
-+                    if ((view.mDebugFlags & DEBUG_LOG_GL_CALLS) != 0) {
-+                        log = new LogWriter();
-+                    }
-+                    gl = GLDebugHelper.wrap(gl, configFlags, log);
-+                }
-+            }
-+            return gl;
-+        }
-+
-+        /**
-+         * Display the current render surface.
-+         * @return the EGL error code from eglSwapBuffers.
-+         */
-+        public int swap() {
-+            if (! mEgl.eglSwapBuffers(mEglDisplay, mEglSurface)) {
-+                return mEgl.eglGetError();
-+            }
-+            return EGL10.EGL_SUCCESS;
-+        }
-+
-+        public void destroySurface() {
-+            if (LOG_EGL) {
-+                Log.w("EglHelper", "destroySurface()  tid=" + Thread.currentThread().getId());
-+            }
-+            destroySurfaceImp();
-+        }
-+
-+        private void destroySurfaceImp() {
-+            if (mEglSurface != null && mEglSurface != EGL10.EGL_NO_SURFACE) {
-+                mEgl.eglMakeCurrent(mEglDisplay, EGL10.EGL_NO_SURFACE,
-+                        EGL10.EGL_NO_SURFACE,
-+                        EGL10.EGL_NO_CONTEXT);
-+                GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-+                if (view != null) {
-+                    view.mEGLWindowSurfaceFactory.destroySurface(mEgl, mEglDisplay, mEglSurface);
-+                }
-+                mEglSurface = null;
-+            }
-+        }
-+
-+        public void finish() {
-+            if (LOG_EGL) {
-+                Log.w("EglHelper", "finish() tid=" + Thread.currentThread().getId());
-+            }
-+            if (mEglContext != null) {
-+                GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-+                if (view != null) {
-+                    view.mEGLContextFactory.destroyContext(mEgl, mEglDisplay, mEglContext);
-+                }
-+                mEglContext = null;
-+            }
-+            if (mEglDisplay != null) {
-+                mEgl.eglTerminate(mEglDisplay);
-+                mEglDisplay = null;
-+            }
-+        }
-+
-+        private void throwEglException(String function) {
-+            throwEglException(function, mEgl.eglGetError());
-+        }
-+
-+        public static void throwEglException(String function, int error) {
-+            String message = formatEglError(function, error);
-+            if (LOG_THREADS) {
-+                Log.e("EglHelper", "throwEglException tid=" + Thread.currentThread().getId() + " "
-+                        + message);
-+            }
-+            throw new RuntimeException(message);
-+        }
-+
-+        public static void logEglErrorAsWarning(String tag, String function, int error) {
-+            Log.w(tag, formatEglError(function, error));
-+        }
-+
-+        public static String formatEglError(String function, int error) {
-+            return function + " failed: " + EGLLogWrapper.getErrorString(error);
-+        }
-+
-+        private WeakReference<GLSurfaceView> mGLSurfaceViewWeakRef;
-+        EGL10 mEgl;
-+        EGLDisplay mEglDisplay;
-+        EGLSurface mEglSurface;
-+        EGLConfig mEglConfig;
-+        EGLContext mEglContext;
-+
-+    }
-+
-+    /**
-+     * A generic GL Thread. Takes care of initializing EGL and GL. Delegates
-+     * to a Renderer instance to do the actual drawing. Can be configured to
-+     * render continuously or on request.
-+     *
-+     * All potentially blocking synchronization is done through the
-+     * sGLThreadManager object. This avoids multiple-lock ordering issues.
-+     *
-+     */
-+    static class GLThread extends Thread {
-+        GLThread(WeakReference<GLSurfaceView> glSurfaceViewWeakRef) {
-+            super();
-+            mWidth = 0;
-+            mHeight = 0;
-+            mRequestRender = true;
-+            mRenderMode = RENDERMODE_CONTINUOUSLY;
-+            mWantRenderNotification = false;
-+            mGLSurfaceViewWeakRef = glSurfaceViewWeakRef;
-+        }
-+
-+        @Override
-+        public void run() {
-+            setName("GLThread " + getId());
-+            if (LOG_THREADS) {
-+                Log.i("GLThread", "starting tid=" + getId());
-+            }
-+
-+            try {
-+                guardedRun();
-+            } catch (InterruptedException e) {
-+                // fall thru and exit normally
-+            } finally {
-+                sGLThreadManager.threadExiting(this);
-+            }
-+        }
-+
-+        /*
-+         * This private method should only be called inside a
-+         * synchronized(sGLThreadManager) block.
-+         */
-+        private void stopEglSurfaceLocked() {
-+            if (mHaveEglSurface) {
-+                mHaveEglSurface = false;
-+                mEglHelper.destroySurface();
-+            }
-+        }
-+
-+        /*
-+         * This private method should only be called inside a
-+         * synchronized(sGLThreadManager) block.
-+         */
-+        private void stopEglContextLocked() {
-+            if (mHaveEglContext) {
-+                mEglHelper.finish();
-+                mHaveEglContext = false;
-+                sGLThreadManager.releaseEglContextLocked(this);
-+            }
-+        }
-+        private void guardedRun() throws InterruptedException {
-+            mEglHelper = new EglHelper(mGLSurfaceViewWeakRef);
-+            mHaveEglContext = false;
-+            mHaveEglSurface = false;
-+            mWantRenderNotification = false;
-+
-+            try {
-+                GL10 gl = null;
-+                boolean createEglContext = false;
-+                boolean createEglSurface = false;
-+                boolean createGlInterface = false;
-+                boolean lostEglContext = false;
-+                boolean sizeChanged = false;
-+                boolean wantRenderNotification = false;
-+                boolean doRenderNotification = false;
-+                boolean askedToReleaseEglContext = false;
-+                int w = 0;
-+                int h = 0;
-+                Runnable event = null;
-+
-+                while (true) {
-+                    synchronized (sGLThreadManager) {
-+                        while (true) {
-+                            if (mShouldExit) {
-+                                return;
-+                            }
-+
-+                            if (! mEventQueue.isEmpty()) {
-+                                event = mEventQueue.remove(0);
-+                                break;
-+                            }
-+
-+                            // Update the pause state.
-+                            boolean pausing = false;
-+                            if (mPaused != mRequestPaused) {
-+                                pausing = mRequestPaused;
-+                                mPaused = mRequestPaused;
-+                                sGLThreadManager.notifyAll();
-+                                if (LOG_PAUSE_RESUME) {
-+                                    Log.i("GLThread", "mPaused is now " + mPaused + " tid=" + getId());
-+                                }
-+                            }
-+
-+                            // Do we need to give up the EGL context?
-+                            if (mShouldReleaseEglContext) {
-+                                if (LOG_SURFACE) {
-+                                    Log.i("GLThread", "releasing EGL context because asked to tid=" + getId());
-+                                }
-+                                stopEglSurfaceLocked();
-+                                stopEglContextLocked();
-+                                mShouldReleaseEglContext = false;
-+                                askedToReleaseEglContext = true;
-+                            }
-+
-+                            // Have we lost the EGL context?
-+                            if (lostEglContext) {
-+                                stopEglSurfaceLocked();
-+                                stopEglContextLocked();
-+                                lostEglContext = false;
-+                            }
-+
-+                            // When pausing, release the EGL surface:
-+                            if (pausing && mHaveEglSurface) {
-+                                if (LOG_SURFACE) {
-+                                    Log.i("GLThread", "releasing EGL surface because paused tid=" + getId());
-+                                }
-+                                stopEglSurfaceLocked();
-+                            }
-+
-+                            // When pausing, optionally release the EGL Context:
-+                            if (pausing && mHaveEglContext) {
-+                                GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-+                                boolean preserveEglContextOnPause = view == null ?
-+                                        false : view.mPreserveEGLContextOnPause;
-+                                if (!preserveEglContextOnPause) {
-+                                    stopEglContextLocked();
-+                                    if (LOG_SURFACE) {
-+                                        Log.i("GLThread", "releasing EGL context because paused tid=" + getId());
-+                                    }
-+                                }
-+                            }
-+
-+                            // Have we lost the SurfaceView surface?
-+                            if ((! mHasSurface) && (! mWaitingForSurface)) {
-+                                if (LOG_SURFACE) {
-+                                    Log.i("GLThread", "noticed surfaceView surface lost tid=" + getId());
-+                                }
-+                                if (mHaveEglSurface) {
-+                                    stopEglSurfaceLocked();
-+                                }
-+                                mWaitingForSurface = true;
-+                                mSurfaceIsBad = false;
-+                                sGLThreadManager.notifyAll();
-+                            }
-+
-+                            // Have we acquired the surface view surface?
-+                            if (mHasSurface && mWaitingForSurface) {
-+                                if (LOG_SURFACE) {
-+                                    Log.i("GLThread", "noticed surfaceView surface acquired tid=" + getId());
-+                                }
-+                                mWaitingForSurface = false;
-+                                sGLThreadManager.notifyAll();
-+                            }
-+
-+                            if (doRenderNotification) {
-+                                if (LOG_SURFACE) {
-+                                    Log.i("GLThread", "sending render notification tid=" + getId());
-+                                }
-+                                mWantRenderNotification = false;
-+                                doRenderNotification = false;
-+                                mRenderComplete = true;
-+                                sGLThreadManager.notifyAll();
-+                            }
-+
-+                            // Ready to draw?
-+                            if (readyToDraw()) {
-+
-+                                // If we don't have an EGL context, try to acquire one.
-+                                if (! mHaveEglContext) {
-+                                    if (askedToReleaseEglContext) {
-+                                        askedToReleaseEglContext = false;
-+                                    } else {
-+                                        try {
-+                                            mEglHelper.start();
-+                                        } catch (RuntimeException t) {
-+                                            sGLThreadManager.releaseEglContextLocked(this);
-+                                            throw t;
-+                                        }
-+                                        mHaveEglContext = true;
-+                                        createEglContext = true;
-+
-+                                        sGLThreadManager.notifyAll();
-+                                    }
-+                                }
-+
-+                                if (mHaveEglContext && !mHaveEglSurface) {
-+                                    mHaveEglSurface = true;
-+                                    createEglSurface = true;
-+                                    createGlInterface = true;
-+                                    sizeChanged = true;
-+                                }
-+
-+                                if (mHaveEglSurface) {
-+                                    if (mSizeChanged) {
-+                                        sizeChanged = true;
-+                                        w = mWidth;
-+                                        h = mHeight;
-+                                        mWantRenderNotification = true;
-+                                        if (LOG_SURFACE) {
-+                                            Log.i("GLThread",
-+                                                    "noticing that we want render notification tid="
-+                                                    + getId());
-+                                        }
-+
-+                                        // Destroy and recreate the EGL surface.
-+                                        createEglSurface = true;
-+
-+                                        mSizeChanged = false;
-+                                    }
-+                                    mRequestRender = false;
-+                                    sGLThreadManager.notifyAll();
-+                                    if (mWantRenderNotification) {
-+                                        wantRenderNotification = true;
-+                                    }
-+                                    break;
-+                                }
-+                            }
-+
-+                            // By design, this is the only place in a GLThread thread where we wait().
-+                            if (LOG_THREADS) {
-+                                Log.i("GLThread", "waiting tid=" + getId()
-+                                    + " mHaveEglContext: " + mHaveEglContext
-+                                    + " mHaveEglSurface: " + mHaveEglSurface
-+                                    + " mFinishedCreatingEglSurface: " + mFinishedCreatingEglSurface
-+                                    + " mPaused: " + mPaused
-+                                    + " mHasSurface: " + mHasSurface
-+                                    + " mSurfaceIsBad: " + mSurfaceIsBad
-+                                    + " mWaitingForSurface: " + mWaitingForSurface
-+                                    + " mWidth: " + mWidth
-+                                    + " mHeight: " + mHeight
-+                                    + " mRequestRender: " + mRequestRender
-+                                    + " mRenderMode: " + mRenderMode);
-+                            }
-+                            sGLThreadManager.wait();
-+                        }
-+                    } // end of synchronized(sGLThreadManager)
-+
-+                    if (event != null) {
-+                        event.run();
-+                        event = null;
-+                        continue;
-+                    }
-+
-+                    if (createEglSurface) {
-+                        if (LOG_SURFACE) {
-+                            Log.w("GLThread", "egl createSurface");
-+                        }
-+                        if (mEglHelper.createSurface()) {
-+                            synchronized(sGLThreadManager) {
-+                                mFinishedCreatingEglSurface = true;
-+                                sGLThreadManager.notifyAll();
-+                            }
-+                        } else {
-+                            synchronized(sGLThreadManager) {
-+                                mFinishedCreatingEglSurface = true;
-+                                mSurfaceIsBad = true;
-+                                sGLThreadManager.notifyAll();
-+                            }
-+                            continue;
-+                        }
-+                        createEglSurface = false;
-+                    }
-+
-+                    if (createGlInterface) {
-+                        gl = (GL10) mEglHelper.createGL();
-+
-+                        createGlInterface = false;
-+                    }
-+
-+                    if (createEglContext) {
-+                        if (LOG_RENDERER) {
-+                            Log.w("GLThread", "onSurfaceCreated");
-+                        }
-+                        GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-+                        if (view != null) {
-+                            try {
-+                                Trace.traceBegin(Trace.TRACE_TAG_VIEW, "onSurfaceCreated");
-+                                view.mRenderer.onSurfaceCreated(gl, mEglHelper.mEglConfig);
-+                            } finally {
-+                                Trace.traceEnd(Trace.TRACE_TAG_VIEW);
-+                            }
-+                        }
-+                        createEglContext = false;
-+                    }
-+
-+                    if (sizeChanged) {
-+                        if (LOG_RENDERER) {
-+                            Log.w("GLThread", "onSurfaceChanged(" + w + ", " + h + ")");
-+                        }
-+                        GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-+                        if (view != null) {
-+                            try {
-+                                Trace.traceBegin(Trace.TRACE_TAG_VIEW, "onSurfaceChanged");
-+                                view.mRenderer.onSurfaceChanged(gl, w, h);
-+                            } finally {
-+                                Trace.traceEnd(Trace.TRACE_TAG_VIEW);
-+                            }
-+                        }
-+                        sizeChanged = false;
-+                    }
-+
-+                    if (LOG_RENDERER_DRAW_FRAME) {
-+                        Log.w("GLThread", "onDrawFrame tid=" + getId());
-+                    }
-+                    {
-+                        GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-+                        if (view != null) {
-+                            try {
-+                                Trace.traceBegin(Trace.TRACE_TAG_VIEW, "onDrawFrame");
-+                                view.mRenderer.onDrawFrame(gl);
-+                            } finally {
-+                                Trace.traceEnd(Trace.TRACE_TAG_VIEW);
-+                            }
-+                        }
-+                    }
-+                    int swapError = mEglHelper.swap();
-+                    switch (swapError) {
-+                        case EGL10.EGL_SUCCESS:
-+                            break;
-+                        case EGL11.EGL_CONTEXT_LOST:
-+                            if (LOG_SURFACE) {
-+                                Log.i("GLThread", "egl context lost tid=" + getId());
-+                            }
-+                            lostEglContext = true;
-+                            break;
-+                        default:
-+                            // Other errors typically mean that the current surface is bad,
-+                            // probably because the SurfaceView surface has been destroyed,
-+                            // but we haven't been notified yet.
-+                            // Log the error to help developers understand why rendering stopped.
-+                            EglHelper.logEglErrorAsWarning("GLThread", "eglSwapBuffers", swapError);
-+
-+                            synchronized(sGLThreadManager) {
-+                                mSurfaceIsBad = true;
-+                                sGLThreadManager.notifyAll();
-+                            }
-+                            break;
-+                    }
-+
-+                    if (wantRenderNotification) {
-+                        doRenderNotification = true;
-+                        wantRenderNotification = false;
-+                    }
-+                }
-+
-+            } finally {
-+                /*
-+                 * clean-up everything...
-+                 */
-+                synchronized (sGLThreadManager) {
-+                    stopEglSurfaceLocked();
-+                    stopEglContextLocked();
-+                }
-+            }
-+        }
-+
-+        public boolean ableToDraw() {
-+            return mHaveEglContext && mHaveEglSurface && readyToDraw();
-+        }
-+
-+        private boolean readyToDraw() {
-+            return (!mPaused) && mHasSurface && (!mSurfaceIsBad)
-+                && (mWidth > 0) && (mHeight > 0)
-+                && (mRequestRender || (mRenderMode == RENDERMODE_CONTINUOUSLY));
-+        }
-+
-+        public void setRenderMode(int renderMode) {
-+            if ( !((RENDERMODE_WHEN_DIRTY <= renderMode) && (renderMode <= RENDERMODE_CONTINUOUSLY)) ) {
-+                throw new IllegalArgumentException("renderMode");
-+            }
-+            synchronized(sGLThreadManager) {
-+                mRenderMode = renderMode;
-+                sGLThreadManager.notifyAll();
-+            }
-+        }
-+
-+        public int getRenderMode() {
-+            synchronized(sGLThreadManager) {
-+                return mRenderMode;
-+            }
-+        }
-+
-+        public void requestRender() {
-+            synchronized(sGLThreadManager) {
-+                mRequestRender = true;
-+                sGLThreadManager.notifyAll();
-+            }
-+        }
-+
-+        public void requestRenderAndWait() {
-+            synchronized(sGLThreadManager) {
-+                // If we are already on the GL thread, this means a client callback
-+                // has caused reentrancy, for example via updating the SurfaceView parameters.
-+                // We will return to the client rendering code, so here we don't need to
-+                // do anything.
-+                if (Thread.currentThread() == this) {
-+                    return;
-+                }
-+
-+                mWantRenderNotification = true;
-+                mRequestRender = true;
-+                mRenderComplete = false;
-+
-+                sGLThreadManager.notifyAll();
-+
-+                while (!mExited && !mPaused && !mRenderComplete && ableToDraw()) {
-+                    try {
-+                        sGLThreadManager.wait();
-+                    } catch (InterruptedException ex) {
-+                        Thread.currentThread().interrupt();
-+                    }
-+                }
-+
-+            }
-+        }
-+
-+        public void surfaceCreated() {
-+            synchronized(sGLThreadManager) {
-+                if (LOG_THREADS) {
-+                    Log.i("GLThread", "surfaceCreated tid=" + getId());
-+                }
-+                mHasSurface = true;
-+                mFinishedCreatingEglSurface = false;
-+                sGLThreadManager.notifyAll();
-+                while (mWaitingForSurface
-+                       && !mFinishedCreatingEglSurface
-+                       && !mExited) {
-+                    try {
-+                        sGLThreadManager.wait();
-+                    } catch (InterruptedException e) {
-+                        Thread.currentThread().interrupt();
-+                    }
-+                }
-+            }
-+        }
-+
-+        public void surfaceDestroyed() {
-+            synchronized(sGLThreadManager) {
-+                if (LOG_THREADS) {
-+                    Log.i("GLThread", "surfaceDestroyed tid=" + getId());
-+                }
-+                mHasSurface = false;
-+                sGLThreadManager.notifyAll();
-+                while((!mWaitingForSurface) && (!mExited)) {
-+                    try {
-+                        sGLThreadManager.wait();
-+                    } catch (InterruptedException e) {
-+                        Thread.currentThread().interrupt();
-+                    }
-+                }
-+            }
-+        }
-+
-+        public void onPause() {
-+            synchronized (sGLThreadManager) {
-+                if (LOG_PAUSE_RESUME) {
-+                    Log.i("GLThread", "onPause tid=" + getId());
-+                }
-+                mRequestPaused = true;
-+                sGLThreadManager.notifyAll();
-+                while ((! mExited) && (! mPaused)) {
-+                    if (LOG_PAUSE_RESUME) {
-+                        Log.i("Main thread", "onPause waiting for mPaused.");
-+                    }
-+                    try {
-+                        sGLThreadManager.wait();
-+                    } catch (InterruptedException ex) {
-+                        Thread.currentThread().interrupt();
-+                    }
-+                }
-+            }
-+        }
-+
-+        public void onResume() {
-+            synchronized (sGLThreadManager) {
-+                if (LOG_PAUSE_RESUME) {
-+                    Log.i("GLThread", "onResume tid=" + getId());
-+                }
-+                mRequestPaused = false;
-+                mRequestRender = true;
-+                mRenderComplete = false;
-+                sGLThreadManager.notifyAll();
-+                while ((! mExited) && mPaused && (!mRenderComplete)) {
-+                    if (LOG_PAUSE_RESUME) {
-+                        Log.i("Main thread", "onResume waiting for !mPaused.");
-+                    }
-+                    try {
-+                        sGLThreadManager.wait();
-+                    } catch (InterruptedException ex) {
-+                        Thread.currentThread().interrupt();
-+                    }
-+                }
-+            }
-+        }
-+
-+        public void onWindowResize(int w, int h) {
-+            synchronized (sGLThreadManager) {
-+                mWidth = w;
-+                mHeight = h;
-+                mSizeChanged = true;
-+                mRequestRender = true;
-+                mRenderComplete = false;
-+
-+                // If we are already on the GL thread, this means a client callback
-+                // has caused reentrancy, for example via updating the SurfaceView parameters.
-+                // We need to process the size change eventually though and update our EGLSurface.
-+                // So we set the parameters and return so they can be processed on our
-+                // next iteration.
-+                if (Thread.currentThread() == this) {
-+                    return;
-+                }
-+
-+                sGLThreadManager.notifyAll();
-+
-+                // Wait for thread to react to resize and render a frame
-+                while (! mExited && !mPaused && !mRenderComplete
-+                        && ableToDraw()) {
-+                    if (LOG_SURFACE) {
-+                        Log.i("Main thread", "onWindowResize waiting for render complete from tid=" + getId());
-+                    }
-+                    try {
-+                        sGLThreadManager.wait();
-+                    } catch (InterruptedException ex) {
-+                        Thread.currentThread().interrupt();
-+                    }
-+                }
-+            }
-+        }
-+
-+        public void requestExitAndWait() {
-+            // don't call this from GLThread thread or it is a guaranteed
-+            // deadlock!
-+            synchronized(sGLThreadManager) {
-+                mShouldExit = true;
-+                sGLThreadManager.notifyAll();
-+                while (! mExited) {
-+                    try {
-+                        sGLThreadManager.wait();
-+                    } catch (InterruptedException ex) {
-+                        Thread.currentThread().interrupt();
-+                    }
-+                }
-+            }
-+        }
-+
-+        public void requestReleaseEglContextLocked() {
-+            mShouldReleaseEglContext = true;
-+            sGLThreadManager.notifyAll();
-+        }
-+
-+        /**
-+         * Queue an "event" to be run on the GL rendering thread.
-+         * @param r the runnable to be run on the GL rendering thread.
-+         */
-+        public void queueEvent(Runnable r) {
-+            if (r == null) {
-+                throw new IllegalArgumentException("r must not be null");
-+            }
-+            synchronized(sGLThreadManager) {
-+                mEventQueue.add(r);
-+                sGLThreadManager.notifyAll();
-+            }
-+        }
-+
-+        // Once the thread is started, all accesses to the following member
-+        // variables are protected by the sGLThreadManager monitor
-+        private boolean mShouldExit;
-+        private boolean mExited;
-+        private boolean mRequestPaused;
-+        private boolean mPaused;
-+        private boolean mHasSurface;
-+        private boolean mSurfaceIsBad;
-+        private boolean mWaitingForSurface;
-+        private boolean mHaveEglContext;
-+        private boolean mHaveEglSurface;
-+        private boolean mFinishedCreatingEglSurface;
-+        private boolean mShouldReleaseEglContext;
-+        private int mWidth;
-+        private int mHeight;
-+        private int mRenderMode;
-+        private boolean mRequestRender;
-+        private boolean mWantRenderNotification;
-+        private boolean mRenderComplete;
-+        private ArrayList<Runnable> mEventQueue = new ArrayList<Runnable>();
-+        private boolean mSizeChanged = true;
-+
-+        // End of member variables protected by the sGLThreadManager monitor.
-+
-+        private EglHelper mEglHelper;
-+
-+        /**
-+         * Set once at thread construction time, nulled out when the parent view is garbage
-+         * called. This weak reference allows the GLSurfaceView to be garbage collected while
-+         * the GLThread is still alive.
-+         */
-+        private WeakReference<GLSurfaceView> mGLSurfaceViewWeakRef;
-+
-+    }
-+
-+    static class LogWriter extends Writer {
-+
-+        @Override public void close() {
-+            flushBuilder();
-+        }
-+
-+        @Override public void flush() {
-+            flushBuilder();
-+        }
-+
-+        @Override public void write(char[] buf, int offset, int count) {
-+            for(int i = 0; i < count; i++) {
-+                char c = buf[offset + i];
-+                if ( c == '\n') {
-+                    flushBuilder();
-+                }
-+                else {
-+                    mBuilder.append(c);
-+                }
-+            }
-+        }
-+
-+        private void flushBuilder() {
-+            if (mBuilder.length() > 0) {
-+                Log.v("GLSurfaceView", mBuilder.toString());
-+                mBuilder.delete(0, mBuilder.length());
-+            }
-+        }
-+
-+        private StringBuilder mBuilder = new StringBuilder();
-+    }
-+
-+
-+    private void checkRenderThreadState() {
-+        if (mGLThread != null) {
-+            throw new IllegalStateException(
-+                    "setRenderer has already been called for this instance.");
-+        }
-+    }
-+
-+    private static class GLThreadManager {
-+        private static String TAG = "GLThreadManager";
-+
-+        public synchronized void threadExiting(GLThread thread) {
-+            if (LOG_THREADS) {
-+                Log.i("GLThread", "exiting tid=" +  thread.getId());
-+            }
-+            thread.mExited = true;
-+            notifyAll();
-+        }
-+
-+        /*
-+         * Releases the EGL context. Requires that we are already in the
-+         * sGLThreadManager monitor when this is called.
-+         */
-+        public void releaseEglContextLocked(GLThread thread) {
-+            notifyAll();
-+        }
-+    }
-+
-+    private static final GLThreadManager sGLThreadManager = new GLThreadManager();
-+
-+    private final WeakReference<GLSurfaceView> mThisWeakRef =
-+            new WeakReference<GLSurfaceView>(this);
-+    private GLThread mGLThread;
-+    private Renderer mRenderer;
-+    private boolean mDetached;
-+    private EGLConfigChooser mEGLConfigChooser;
-+    private EGLContextFactory mEGLContextFactory;
-+    private EGLWindowSurfaceFactory mEGLWindowSurfaceFactory;
-+    private GLWrapper mGLWrapper;
-+    private int mDebugFlags;
-+    private int mEGLContextClientVersion;
-+    private boolean mPreserveEGLContextOnPause;
-+}
diff -Naur frameworksRaw/base/opengl/java/android/opengl/GLSurfaceView.java.orig.rej.rej frameworksModified/base/opengl/java/android/opengl/GLSurfaceView.java.orig.rej.rej
--- frameworksRaw/base/opengl/java/android/opengl/GLSurfaceView.java.orig.rej.rej	2017-07-06 15:34:16.034011964 +0530
+++ frameworksModified/base/opengl/java/android/opengl/GLSurfaceView.java.orig.rej.rej	1970-01-01 05:30:00.000000000 +0530
@@ -1,1918 +0,0 @@
---- base/opengl/java/android/opengl/GLSurfaceView.java.orig.rej	1970-01-01 05:30:00.000000000 +0530
-+++ base/opengl/java/android/opengl/GLSurfaceView.java.orig.rej	2017-07-06 13:50:03.663302385 +0530
-@@ -0,0 +1,1915 @@
-+--- base/opengl/java/android/opengl/GLSurfaceView.java.orig	1970-01-01 05:30:00.000000000 +0530
-++++ base/opengl/java/android/opengl/GLSurfaceView.java.orig	2017-07-05 18:25:26.212564099 +0530
-+@@ -0,0 +1,1912 @@
-++/*
-++ * Copyright (C) 2008 The Android Open Source Project
-++ *
-++ * Licensed under the Apache License, Version 2.0 (the "License");
-++ * you may not use this file except in compliance with the License.
-++ * You may obtain a copy of the License at
-++ *
-++ *      http://www.apache.org/licenses/LICENSE-2.0
-++ *
-++ * Unless required by applicable law or agreed to in writing, software
-++ * distributed under the License is distributed on an "AS IS" BASIS,
-++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-++ * See the License for the specific language governing permissions and
-++ * limitations under the License.
-++ */
-++
-++package android.opengl;
-++
-++import android.content.Context;
-++import android.os.Trace;
-++import android.util.AttributeSet;
-++import android.util.Log;
-++import android.view.SurfaceHolder;
-++import android.view.SurfaceView;
-++
-++import java.io.Writer;
-++import java.lang.ref.WeakReference;
-++import java.util.ArrayList;
-++
-++import javax.microedition.khronos.egl.EGL10;
-++import javax.microedition.khronos.egl.EGL11;
-++import javax.microedition.khronos.egl.EGLConfig;
-++import javax.microedition.khronos.egl.EGLContext;
-++import javax.microedition.khronos.egl.EGLDisplay;
-++import javax.microedition.khronos.egl.EGLSurface;
-++import javax.microedition.khronos.opengles.GL;
-++import javax.microedition.khronos.opengles.GL10;
-++
-++/**
-++ * An implementation of SurfaceView that uses the dedicated surface for
-++ * displaying OpenGL rendering.
-++ * <p>
-++ * A GLSurfaceView provides the following features:
-++ * <p>
-++ * <ul>
-++ * <li>Manages a surface, which is a special piece of memory that can be
-++ * composited into the Android view system.
-++ * <li>Manages an EGL display, which enables OpenGL to render into a surface.
-++ * <li>Accepts a user-provided Renderer object that does the actual rendering.
-++ * <li>Renders on a dedicated thread to decouple rendering performance from the
-++ * UI thread.
-++ * <li>Supports both on-demand and continuous rendering.
-++ * <li>Optionally wraps, traces, and/or error-checks the renderer's OpenGL calls.
-++ * </ul>
-++ *
-++ * <div class="special reference">
-++ * <h3>Developer Guides</h3>
-++ * <p>For more information about how to use OpenGL, read the
-++ * <a href="{@docRoot}guide/topics/graphics/opengl.html">OpenGL</a> developer guide.</p>
-++ * </div>
-++ *
-++ * <h3>Using GLSurfaceView</h3>
-++ * <p>
-++ * Typically you use GLSurfaceView by subclassing it and overriding one or more of the
-++ * View system input event methods. If your application does not need to override event
-++ * methods then GLSurfaceView can be used as-is. For the most part
-++ * GLSurfaceView behavior is customized by calling "set" methods rather than by subclassing.
-++ * For example, unlike a regular View, drawing is delegated to a separate Renderer object which
-++ * is registered with the GLSurfaceView
-++ * using the {@link #setRenderer(Renderer)} call.
-++ * <p>
-++ * <h3>Initializing GLSurfaceView</h3>
-++ * All you have to do to initialize a GLSurfaceView is call {@link #setRenderer(Renderer)}.
-++ * However, if desired, you can modify the default behavior of GLSurfaceView by calling one or
-++ * more of these methods before calling setRenderer:
-++ * <ul>
-++ * <li>{@link #setDebugFlags(int)}
-++ * <li>{@link #setEGLConfigChooser(boolean)}
-++ * <li>{@link #setEGLConfigChooser(EGLConfigChooser)}
-++ * <li>{@link #setEGLConfigChooser(int, int, int, int, int, int)}
-++ * <li>{@link #setGLWrapper(GLWrapper)}
-++ * </ul>
-++ * <p>
-++ * <h4>Specifying the android.view.Surface</h4>
-++ * By default GLSurfaceView will create a PixelFormat.RGB_888 format surface. If a translucent
-++ * surface is required, call getHolder().setFormat(PixelFormat.TRANSLUCENT).
-++ * The exact format of a TRANSLUCENT surface is device dependent, but it will be
-++ * a 32-bit-per-pixel surface with 8 bits per component.
-++ * <p>
-++ * <h4>Choosing an EGL Configuration</h4>
-++ * A given Android device may support multiple EGLConfig rendering configurations.
-++ * The available configurations may differ in how may channels of data are present, as
-++ * well as how many bits are allocated to each channel. Therefore, the first thing
-++ * GLSurfaceView has to do when starting to render is choose what EGLConfig to use.
-++ * <p>
-++ * By default GLSurfaceView chooses a EGLConfig that has an RGB_888 pixel format,
-++ * with at least a 16-bit depth buffer and no stencil.
-++ * <p>
-++ * If you would prefer a different EGLConfig
-++ * you can override the default behavior by calling one of the
-++ * setEGLConfigChooser methods.
-++ * <p>
-++ * <h4>Debug Behavior</h4>
-++ * You can optionally modify the behavior of GLSurfaceView by calling
-++ * one or more of the debugging methods {@link #setDebugFlags(int)},
-++ * and {@link #setGLWrapper}. These methods may be called before and/or after setRenderer, but
-++ * typically they are called before setRenderer so that they take effect immediately.
-++ * <p>
-++ * <h4>Setting a Renderer</h4>
-++ * Finally, you must call {@link #setRenderer} to register a {@link Renderer}.
-++ * The renderer is
-++ * responsible for doing the actual OpenGL rendering.
-++ * <p>
-++ * <h3>Rendering Mode</h3>
-++ * Once the renderer is set, you can control whether the renderer draws
-++ * continuously or on-demand by calling
-++ * {@link #setRenderMode}. The default is continuous rendering.
-++ * <p>
-++ * <h3>Activity Life-cycle</h3>
-++ * A GLSurfaceView must be notified when to pause and resume rendering. GLSurfaceView clients
-++ * are required to call {@link #onPause()} when the activity stops and
-++ * {@link #onResume()} when the activity starts. These calls allow GLSurfaceView to
-++ * pause and resume the rendering thread, and also allow GLSurfaceView to release and recreate
-++ * the OpenGL display.
-++ * <p>
-++ * <h3>Handling events</h3>
-++ * <p>
-++ * To handle an event you will typically subclass GLSurfaceView and override the
-++ * appropriate method, just as you would with any other View. However, when handling
-++ * the event, you may need to communicate with the Renderer object
-++ * that's running in the rendering thread. You can do this using any
-++ * standard Java cross-thread communication mechanism. In addition,
-++ * one relatively easy way to communicate with your renderer is
-++ * to call
-++ * {@link #queueEvent(Runnable)}. For example:
-++ * <pre class="prettyprint">
-++ * class MyGLSurfaceView extends GLSurfaceView {
-++ *
-++ *     private MyRenderer mMyRenderer;
-++ *
-++ *     public void start() {
-++ *         mMyRenderer = ...;
-++ *         setRenderer(mMyRenderer);
-++ *     }
-++ *
-++ *     public boolean onKeyDown(int keyCode, KeyEvent event) {
-++ *         if (keyCode == KeyEvent.KEYCODE_DPAD_CENTER) {
-++ *             queueEvent(new Runnable() {
-++ *                 // This method will be called on the rendering
-++ *                 // thread:
-++ *                 public void run() {
-++ *                     mMyRenderer.handleDpadCenter();
-++ *                 }});
-++ *             return true;
-++ *         }
-++ *         return super.onKeyDown(keyCode, event);
-++ *     }
-++ * }
-++ * </pre>
-++ *
-++ */
-++public class GLSurfaceView extends SurfaceView implements SurfaceHolder.Callback2 {
-++    private final static String TAG = "GLSurfaceView";
-++    private final static boolean LOG_ATTACH_DETACH = false;
-++    private final static boolean LOG_THREADS = false;
-++    private final static boolean LOG_PAUSE_RESUME = false;
-++    private final static boolean LOG_SURFACE = false;
-++    private final static boolean LOG_RENDERER = false;
-++    private final static boolean LOG_RENDERER_DRAW_FRAME = false;
-++    private final static boolean LOG_EGL = false;
-++    /**
-++     * The renderer only renders
-++     * when the surface is created, or when {@link #requestRender} is called.
-++     *
-++     * @see #getRenderMode()
-++     * @see #setRenderMode(int)
-++     * @see #requestRender()
-++     */
-++    public final static int RENDERMODE_WHEN_DIRTY = 0;
-++    /**
-++     * The renderer is called
-++     * continuously to re-render the scene.
-++     *
-++     * @see #getRenderMode()
-++     * @see #setRenderMode(int)
-++     */
-++    public final static int RENDERMODE_CONTINUOUSLY = 1;
-++
-++    /**
-++     * Check glError() after every GL call and throw an exception if glError indicates
-++     * that an error has occurred. This can be used to help track down which OpenGL ES call
-++     * is causing an error.
-++     *
-++     * @see #getDebugFlags
-++     * @see #setDebugFlags
-++     */
-++    public final static int DEBUG_CHECK_GL_ERROR = 1;
-++
-++    /**
-++     * Log GL calls to the system log at "verbose" level with tag "GLSurfaceView".
-++     *
-++     * @see #getDebugFlags
-++     * @see #setDebugFlags
-++     */
-++    public final static int DEBUG_LOG_GL_CALLS = 2;
-++
-++    /**
-++     * Standard View constructor. In order to render something, you
-++     * must call {@link #setRenderer} to register a renderer.
-++     */
-++    public GLSurfaceView(Context context) {
-++        super(context);
-++        init();
-++    }
-++
-++    /**
-++     * Standard View constructor. In order to render something, you
-++     * must call {@link #setRenderer} to register a renderer.
-++     */
-++    public GLSurfaceView(Context context, AttributeSet attrs) {
-++        super(context, attrs);
-++        init();
-++    }
-++
-++    @Override
-++    protected void finalize() throws Throwable {
-++        try {
-++            if (mGLThread != null) {
-++                // GLThread may still be running if this view was never
-++                // attached to a window.
-++                mGLThread.requestExitAndWait();
-++            }
-++        } finally {
-++            super.finalize();
-++        }
-++    }
-++
-++    private void init() {
-++        // Install a SurfaceHolder.Callback so we get notified when the
-++        // underlying surface is created and destroyed
-++        SurfaceHolder holder = getHolder();
-++        holder.addCallback(this);
-++        // setFormat is done by SurfaceView in SDK 2.3 and newer. Uncomment
-++        // this statement if back-porting to 2.2 or older:
-++        // holder.setFormat(PixelFormat.RGB_565);
-++        //
-++        // setType is not needed for SDK 2.0 or newer. Uncomment this
-++        // statement if back-porting this code to older SDKs.
-++        // holder.setType(SurfaceHolder.SURFACE_TYPE_GPU);
-++    }
-++
-++    /**
-++     * Set the glWrapper. If the glWrapper is not null, its
-++     * {@link GLWrapper#wrap(GL)} method is called
-++     * whenever a surface is created. A GLWrapper can be used to wrap
-++     * the GL object that's passed to the renderer. Wrapping a GL
-++     * object enables examining and modifying the behavior of the
-++     * GL calls made by the renderer.
-++     * <p>
-++     * Wrapping is typically used for debugging purposes.
-++     * <p>
-++     * The default value is null.
-++     * @param glWrapper the new GLWrapper
-++     */
-++    public void setGLWrapper(GLWrapper glWrapper) {
-++        mGLWrapper = glWrapper;
-++    }
-++
-++    /**
-++     * Set the debug flags to a new value. The value is
-++     * constructed by OR-together zero or more
-++     * of the DEBUG_CHECK_* constants. The debug flags take effect
-++     * whenever a surface is created. The default value is zero.
-++     * @param debugFlags the new debug flags
-++     * @see #DEBUG_CHECK_GL_ERROR
-++     * @see #DEBUG_LOG_GL_CALLS
-++     */
-++    public void setDebugFlags(int debugFlags) {
-++        mDebugFlags = debugFlags;
-++    }
-++
-++    /**
-++     * Get the current value of the debug flags.
-++     * @return the current value of the debug flags.
-++     */
-++    public int getDebugFlags() {
-++        return mDebugFlags;
-++    }
-++
-++    /**
-++     * Control whether the EGL context is preserved when the GLSurfaceView is paused and
-++     * resumed.
-++     * <p>
-++     * If set to true, then the EGL context may be preserved when the GLSurfaceView is paused.
-++     * <p>
-++     * Prior to API level 11, whether the EGL context is actually preserved or not
-++     * depends upon whether the Android device can support an arbitrary number of
-++     * EGL contexts or not. Devices that can only support a limited number of EGL
-++     * contexts must release the EGL context in order to allow multiple applications
-++     * to share the GPU.
-++     * <p>
-++     * If set to false, the EGL context will be released when the GLSurfaceView is paused,
-++     * and recreated when the GLSurfaceView is resumed.
-++     * <p>
-++     *
-++     * The default is false.
-++     *
-++     * @param preserveOnPause preserve the EGL context when paused
-++     */
-++    public void setPreserveEGLContextOnPause(boolean preserveOnPause) {
-++        mPreserveEGLContextOnPause = preserveOnPause;
-++    }
-++
-++    /**
-++     * @return true if the EGL context will be preserved when paused
-++     */
-++    public boolean getPreserveEGLContextOnPause() {
-++        return mPreserveEGLContextOnPause;
-++    }
-++
-++    /**
-++     * Set the renderer associated with this view. Also starts the thread that
-++     * will call the renderer, which in turn causes the rendering to start.
-++     * <p>This method should be called once and only once in the life-cycle of
-++     * a GLSurfaceView.
-++     * <p>The following GLSurfaceView methods can only be called <em>before</em>
-++     * setRenderer is called:
-++     * <ul>
-++     * <li>{@link #setEGLConfigChooser(boolean)}
-++     * <li>{@link #setEGLConfigChooser(EGLConfigChooser)}
-++     * <li>{@link #setEGLConfigChooser(int, int, int, int, int, int)}
-++     * </ul>
-++     * <p>
-++     * The following GLSurfaceView methods can only be called <em>after</em>
-++     * setRenderer is called:
-++     * <ul>
-++     * <li>{@link #getRenderMode()}
-++     * <li>{@link #onPause()}
-++     * <li>{@link #onResume()}
-++     * <li>{@link #queueEvent(Runnable)}
-++     * <li>{@link #requestRender()}
-++     * <li>{@link #setRenderMode(int)}
-++     * </ul>
-++     *
-++     * @param renderer the renderer to use to perform OpenGL drawing.
-++     */
-++    public void setRenderer(Renderer renderer) {
-++        checkRenderThreadState();
-++        if (mEGLConfigChooser == null) {
-++            mEGLConfigChooser = new SimpleEGLConfigChooser(true);
-++        }
-++        if (mEGLContextFactory == null) {
-++            mEGLContextFactory = new DefaultContextFactory();
-++        }
-++        if (mEGLWindowSurfaceFactory == null) {
-++            mEGLWindowSurfaceFactory = new DefaultWindowSurfaceFactory();
-++        }
-++        mRenderer = renderer;
-++        mGLThread = new GLThread(mThisWeakRef);
-++        mGLThread.start();
-++    }
-++
-++    /**
-++     * Install a custom EGLContextFactory.
-++     * <p>If this method is
-++     * called, it must be called before {@link #setRenderer(Renderer)}
-++     * is called.
-++     * <p>
-++     * If this method is not called, then by default
-++     * a context will be created with no shared context and
-++     * with a null attribute list.
-++     */
-++    public void setEGLContextFactory(EGLContextFactory factory) {
-++        checkRenderThreadState();
-++        mEGLContextFactory = factory;
-++    }
-++
-++    /**
-++     * Install a custom EGLWindowSurfaceFactory.
-++     * <p>If this method is
-++     * called, it must be called before {@link #setRenderer(Renderer)}
-++     * is called.
-++     * <p>
-++     * If this method is not called, then by default
-++     * a window surface will be created with a null attribute list.
-++     */
-++    public void setEGLWindowSurfaceFactory(EGLWindowSurfaceFactory factory) {
-++        checkRenderThreadState();
-++        mEGLWindowSurfaceFactory = factory;
-++    }
-++
-++    /**
-++     * Install a custom EGLConfigChooser.
-++     * <p>If this method is
-++     * called, it must be called before {@link #setRenderer(Renderer)}
-++     * is called.
-++     * <p>
-++     * If no setEGLConfigChooser method is called, then by default the
-++     * view will choose an EGLConfig that is compatible with the current
-++     * android.view.Surface, with a depth buffer depth of
-++     * at least 16 bits.
-++     * @param configChooser
-++     */
-++    public void setEGLConfigChooser(EGLConfigChooser configChooser) {
-++        checkRenderThreadState();
-++        mEGLConfigChooser = configChooser;
-++    }
-++
-++    /**
-++     * Install a config chooser which will choose a config
-++     * as close to 16-bit RGB as possible, with or without an optional depth
-++     * buffer as close to 16-bits as possible.
-++     * <p>If this method is
-++     * called, it must be called before {@link #setRenderer(Renderer)}
-++     * is called.
-++     * <p>
-++     * If no setEGLConfigChooser method is called, then by default the
-++     * view will choose an RGB_888 surface with a depth buffer depth of
-++     * at least 16 bits.
-++     *
-++     * @param needDepth
-++     */
-++    public void setEGLConfigChooser(boolean needDepth) {
-++        setEGLConfigChooser(new SimpleEGLConfigChooser(needDepth));
-++    }
-++
-++    /**
-++     * Install a config chooser which will choose a config
-++     * with at least the specified depthSize and stencilSize,
-++     * and exactly the specified redSize, greenSize, blueSize and alphaSize.
-++     * <p>If this method is
-++     * called, it must be called before {@link #setRenderer(Renderer)}
-++     * is called.
-++     * <p>
-++     * If no setEGLConfigChooser method is called, then by default the
-++     * view will choose an RGB_888 surface with a depth buffer depth of
-++     * at least 16 bits.
-++     *
-++     */
-++    public void setEGLConfigChooser(int redSize, int greenSize, int blueSize,
-++            int alphaSize, int depthSize, int stencilSize) {
-++        setEGLConfigChooser(new ComponentSizeChooser(redSize, greenSize,
-++                blueSize, alphaSize, depthSize, stencilSize));
-++    }
-++
-++    /**
-++     * Inform the default EGLContextFactory and default EGLConfigChooser
-++     * which EGLContext client version to pick.
-++     * <p>Use this method to create an OpenGL ES 2.0-compatible context.
-++     * Example:
-++     * <pre class="prettyprint">
-++     *     public MyView(Context context) {
-++     *         super(context);
-++     *         setEGLContextClientVersion(2); // Pick an OpenGL ES 2.0 context.
-++     *         setRenderer(new MyRenderer());
-++     *     }
-++     * </pre>
-++     * <p>Note: Activities which require OpenGL ES 2.0 should indicate this by
-++     * setting @lt;uses-feature android:glEsVersion="0x00020000" /> in the activity's
-++     * AndroidManifest.xml file.
-++     * <p>If this method is called, it must be called before {@link #setRenderer(Renderer)}
-++     * is called.
-++     * <p>This method only affects the behavior of the default EGLContexFactory and the
-++     * default EGLConfigChooser. If
-++     * {@link #setEGLContextFactory(EGLContextFactory)} has been called, then the supplied
-++     * EGLContextFactory is responsible for creating an OpenGL ES 2.0-compatible context.
-++     * If
-++     * {@link #setEGLConfigChooser(EGLConfigChooser)} has been called, then the supplied
-++     * EGLConfigChooser is responsible for choosing an OpenGL ES 2.0-compatible config.
-++     * @param version The EGLContext client version to choose. Use 2 for OpenGL ES 2.0
-++     */
-++    public void setEGLContextClientVersion(int version) {
-++        checkRenderThreadState();
-++        mEGLContextClientVersion = version;
-++    }
-++
-++    /**
-++     * Set the rendering mode. When renderMode is
-++     * RENDERMODE_CONTINUOUSLY, the renderer is called
-++     * repeatedly to re-render the scene. When renderMode
-++     * is RENDERMODE_WHEN_DIRTY, the renderer only rendered when the surface
-++     * is created, or when {@link #requestRender} is called. Defaults to RENDERMODE_CONTINUOUSLY.
-++     * <p>
-++     * Using RENDERMODE_WHEN_DIRTY can improve battery life and overall system performance
-++     * by allowing the GPU and CPU to idle when the view does not need to be updated.
-++     * <p>
-++     * This method can only be called after {@link #setRenderer(Renderer)}
-++     *
-++     * @param renderMode one of the RENDERMODE_X constants
-++     * @see #RENDERMODE_CONTINUOUSLY
-++     * @see #RENDERMODE_WHEN_DIRTY
-++     */
-++    public void setRenderMode(int renderMode) {
-++        mGLThread.setRenderMode(renderMode);
-++    }
-++
-++    /**
-++     * Get the current rendering mode. May be called
-++     * from any thread. Must not be called before a renderer has been set.
-++     * @return the current rendering mode.
-++     * @see #RENDERMODE_CONTINUOUSLY
-++     * @see #RENDERMODE_WHEN_DIRTY
-++     */
-++    public int getRenderMode() {
-++        return mGLThread.getRenderMode();
-++    }
-++
-++    /**
-++     * Request that the renderer render a frame.
-++     * This method is typically used when the render mode has been set to
-++     * {@link #RENDERMODE_WHEN_DIRTY}, so that frames are only rendered on demand.
-++     * May be called
-++     * from any thread. Must not be called before a renderer has been set.
-++     */
-++    public void requestRender() {
-++        mGLThread.requestRender();
-++    }
-++
-++    /**
-++     * This method is part of the SurfaceHolder.Callback interface, and is
-++     * not normally called or subclassed by clients of GLSurfaceView.
-++     */
-++    public void surfaceCreated(SurfaceHolder holder) {
-++        mGLThread.surfaceCreated();
-++    }
-++
-++    /**
-++     * This method is part of the SurfaceHolder.Callback interface, and is
-++     * not normally called or subclassed by clients of GLSurfaceView.
-++     */
-++    public void surfaceDestroyed(SurfaceHolder holder) {
-++        // Surface will be destroyed when we return
-++        mGLThread.surfaceDestroyed();
-++    }
-++
-++    /**
-++     * This method is part of the SurfaceHolder.Callback interface, and is
-++     * not normally called or subclassed by clients of GLSurfaceView.
-++     */
-++    public void surfaceChanged(SurfaceHolder holder, int format, int w, int h) {
-++        mGLThread.onWindowResize(w, h);
-++    }
-++
-++    /**
-++     * This method is part of the SurfaceHolder.Callback interface, and is
-++     * not normally called or subclassed by clients of GLSurfaceView.
-++     */
-++    @Override
-++    public void surfaceRedrawNeeded(SurfaceHolder holder) {
-++        if (mGLThread != null) {
-++            mGLThread.requestRenderAndWait();
-++        }
-++    }
-++
-++
-++    /**
-++     * Pause the rendering thread, optionally tearing down the EGL context
-++     * depending upon the value of {@link #setPreserveEGLContextOnPause(boolean)}.
-++     *
-++     * This method should be called when it is no longer desirable for the
-++     * GLSurfaceView to continue rendering, such as in response to
-++     * {@link android.app.Activity#onStop Activity.onStop}.
-++     *
-++     * Must not be called before a renderer has been set.
-++     */
-++    public void onPause() {
-++        mGLThread.onPause();
-++    }
-++
-++    /**
-++     * Resumes the rendering thread, re-creating the OpenGL context if necessary. It
-++     * is the counterpart to {@link #onPause()}.
-++     *
-++     * This method should typically be called in
-++     * {@link android.app.Activity#onStart Activity.onStart}.
-++     *
-++     * Must not be called before a renderer has been set.
-++     */
-++    public void onResume() {
-++        mGLThread.onResume();
-++    }
-++
-++    /**
-++     * Queue a runnable to be run on the GL rendering thread. This can be used
-++     * to communicate with the Renderer on the rendering thread.
-++     * Must not be called before a renderer has been set.
-++     * @param r the runnable to be run on the GL rendering thread.
-++     */
-++    public void queueEvent(Runnable r) {
-++        mGLThread.queueEvent(r);
-++    }
-++
-++    /**
-++     * This method is used as part of the View class and is not normally
-++     * called or subclassed by clients of GLSurfaceView.
-++     */
-++    @Override
-++    protected void onAttachedToWindow() {
-++        super.onAttachedToWindow();
-++        if (LOG_ATTACH_DETACH) {
-++            Log.d(TAG, "onAttachedToWindow reattach =" + mDetached);
-++        }
-++        if (mDetached && (mRenderer != null)) {
-++            int renderMode = RENDERMODE_CONTINUOUSLY;
-++            if (mGLThread != null) {
-++                renderMode = mGLThread.getRenderMode();
-++            }
-++            mGLThread = new GLThread(mThisWeakRef);
-++            if (renderMode != RENDERMODE_CONTINUOUSLY) {
-++                mGLThread.setRenderMode(renderMode);
-++            }
-++            mGLThread.start();
-++        }
-++        mDetached = false;
-++    }
-++
-++    @Override
-++    protected void onDetachedFromWindow() {
-++        if (LOG_ATTACH_DETACH) {
-++            Log.d(TAG, "onDetachedFromWindow");
-++        }
-++        if (mGLThread != null) {
-++            mGLThread.requestExitAndWait();
-++        }
-++        mDetached = true;
-++        super.onDetachedFromWindow();
-++    }
-++
-++    // ----------------------------------------------------------------------
-++
-++    /**
-++     * An interface used to wrap a GL interface.
-++     * <p>Typically
-++     * used for implementing debugging and tracing on top of the default
-++     * GL interface. You would typically use this by creating your own class
-++     * that implemented all the GL methods by delegating to another GL instance.
-++     * Then you could add your own behavior before or after calling the
-++     * delegate. All the GLWrapper would do was instantiate and return the
-++     * wrapper GL instance:
-++     * <pre class="prettyprint">
-++     * class MyGLWrapper implements GLWrapper {
-++     *     GL wrap(GL gl) {
-++     *         return new MyGLImplementation(gl);
-++     *     }
-++     *     static class MyGLImplementation implements GL,GL10,GL11,... {
-++     *         ...
-++     *     }
-++     * }
-++     * </pre>
-++     * @see #setGLWrapper(GLWrapper)
-++     */
-++    public interface GLWrapper {
-++        /**
-++         * Wraps a gl interface in another gl interface.
-++         * @param gl a GL interface that is to be wrapped.
-++         * @return either the input argument or another GL object that wraps the input argument.
-++         */
-++        GL wrap(GL gl);
-++    }
-++
-++    /**
-++     * A generic renderer interface.
-++     * <p>
-++     * The renderer is responsible for making OpenGL calls to render a frame.
-++     * <p>
-++     * GLSurfaceView clients typically create their own classes that implement
-++     * this interface, and then call {@link GLSurfaceView#setRenderer} to
-++     * register the renderer with the GLSurfaceView.
-++     * <p>
-++     *
-++     * <div class="special reference">
-++     * <h3>Developer Guides</h3>
-++     * <p>For more information about how to use OpenGL, read the
-++     * <a href="{@docRoot}guide/topics/graphics/opengl.html">OpenGL</a> developer guide.</p>
-++     * </div>
-++     *
-++     * <h3>Threading</h3>
-++     * The renderer will be called on a separate thread, so that rendering
-++     * performance is decoupled from the UI thread. Clients typically need to
-++     * communicate with the renderer from the UI thread, because that's where
-++     * input events are received. Clients can communicate using any of the
-++     * standard Java techniques for cross-thread communication, or they can
-++     * use the {@link GLSurfaceView#queueEvent(Runnable)} convenience method.
-++     * <p>
-++     * <h3>EGL Context Lost</h3>
-++     * There are situations where the EGL rendering context will be lost. This
-++     * typically happens when device wakes up after going to sleep. When
-++     * the EGL context is lost, all OpenGL resources (such as textures) that are
-++     * associated with that context will be automatically deleted. In order to
-++     * keep rendering correctly, a renderer must recreate any lost resources
-++     * that it still needs. The {@link #onSurfaceCreated(GL10, EGLConfig)} method
-++     * is a convenient place to do this.
-++     *
-++     *
-++     * @see #setRenderer(Renderer)
-++     */
-++    public interface Renderer {
-++        /**
-++         * Called when the surface is created or recreated.
-++         * <p>
-++         * Called when the rendering thread
-++         * starts and whenever the EGL context is lost. The EGL context will typically
-++         * be lost when the Android device awakes after going to sleep.
-++         * <p>
-++         * Since this method is called at the beginning of rendering, as well as
-++         * every time the EGL context is lost, this method is a convenient place to put
-++         * code to create resources that need to be created when the rendering
-++         * starts, and that need to be recreated when the EGL context is lost.
-++         * Textures are an example of a resource that you might want to create
-++         * here.
-++         * <p>
-++         * Note that when the EGL context is lost, all OpenGL resources associated
-++         * with that context will be automatically deleted. You do not need to call
-++         * the corresponding "glDelete" methods such as glDeleteTextures to
-++         * manually delete these lost resources.
-++         * <p>
-++         * @param gl the GL interface. Use <code>instanceof</code> to
-++         * test if the interface supports GL11 or higher interfaces.
-++         * @param config the EGLConfig of the created surface. Can be used
-++         * to create matching pbuffers.
-++         */
-++        void onSurfaceCreated(GL10 gl, EGLConfig config);
-++
-++        /**
-++         * Called when the surface changed size.
-++         * <p>
-++         * Called after the surface is created and whenever
-++         * the OpenGL ES surface size changes.
-++         * <p>
-++         * Typically you will set your viewport here. If your camera
-++         * is fixed then you could also set your projection matrix here:
-++         * <pre class="prettyprint">
-++         * void onSurfaceChanged(GL10 gl, int width, int height) {
-++         *     gl.glViewport(0, 0, width, height);
-++         *     // for a fixed camera, set the projection too
-++         *     float ratio = (float) width / height;
-++         *     gl.glMatrixMode(GL10.GL_PROJECTION);
-++         *     gl.glLoadIdentity();
-++         *     gl.glFrustumf(-ratio, ratio, -1, 1, 1, 10);
-++         * }
-++         * </pre>
-++         * @param gl the GL interface. Use <code>instanceof</code> to
-++         * test if the interface supports GL11 or higher interfaces.
-++         * @param width
-++         * @param height
-++         */
-++        void onSurfaceChanged(GL10 gl, int width, int height);
-++
-++        /**
-++         * Called to draw the current frame.
-++         * <p>
-++         * This method is responsible for drawing the current frame.
-++         * <p>
-++         * The implementation of this method typically looks like this:
-++         * <pre class="prettyprint">
-++         * void onDrawFrame(GL10 gl) {
-++         *     gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
-++         *     //... other gl calls to render the scene ...
-++         * }
-++         * </pre>
-++         * @param gl the GL interface. Use <code>instanceof</code> to
-++         * test if the interface supports GL11 or higher interfaces.
-++         */
-++        void onDrawFrame(GL10 gl);
-++    }
-++
-++    /**
-++     * An interface for customizing the eglCreateContext and eglDestroyContext calls.
-++     * <p>
-++     * This interface must be implemented by clients wishing to call
-++     * {@link GLSurfaceView#setEGLContextFactory(EGLContextFactory)}
-++     */
-++    public interface EGLContextFactory {
-++        EGLContext createContext(EGL10 egl, EGLDisplay display, EGLConfig eglConfig);
-++        void destroyContext(EGL10 egl, EGLDisplay display, EGLContext context);
-++    }
-++
-++    private class DefaultContextFactory implements EGLContextFactory {
-++        private int EGL_CONTEXT_CLIENT_VERSION = 0x3098;
-++
-++        public EGLContext createContext(EGL10 egl, EGLDisplay display, EGLConfig config) {
-++            int[] attrib_list = {EGL_CONTEXT_CLIENT_VERSION, mEGLContextClientVersion,
-++                    EGL10.EGL_NONE };
-++
-++            return egl.eglCreateContext(display, config, EGL10.EGL_NO_CONTEXT,
-++                    mEGLContextClientVersion != 0 ? attrib_list : null);
-++        }
-++
-++        public void destroyContext(EGL10 egl, EGLDisplay display,
-++                EGLContext context) {
-++            if (!egl.eglDestroyContext(display, context)) {
-++                Log.e("DefaultContextFactory", "display:" + display + " context: " + context);
-++                if (LOG_THREADS) {
-++                    Log.i("DefaultContextFactory", "tid=" + Thread.currentThread().getId());
-++                }
-++                EglHelper.throwEglException("eglDestroyContex", egl.eglGetError());
-++            }
-++        }
-++    }
-++
-++    /**
-++     * An interface for customizing the eglCreateWindowSurface and eglDestroySurface calls.
-++     * <p>
-++     * This interface must be implemented by clients wishing to call
-++     * {@link GLSurfaceView#setEGLWindowSurfaceFactory(EGLWindowSurfaceFactory)}
-++     */
-++    public interface EGLWindowSurfaceFactory {
-++        /**
-++         *  @return null if the surface cannot be constructed.
-++         */
-++        EGLSurface createWindowSurface(EGL10 egl, EGLDisplay display, EGLConfig config,
-++                Object nativeWindow);
-++        void destroySurface(EGL10 egl, EGLDisplay display, EGLSurface surface);
-++    }
-++
-++    private static class DefaultWindowSurfaceFactory implements EGLWindowSurfaceFactory {
-++
-++        public EGLSurface createWindowSurface(EGL10 egl, EGLDisplay display,
-++                EGLConfig config, Object nativeWindow) {
-++            EGLSurface result = null;
-++            try {
-++                result = egl.eglCreateWindowSurface(display, config, nativeWindow, null);
-++            } catch (IllegalArgumentException e) {
-++                // This exception indicates that the surface flinger surface
-++                // is not valid. This can happen if the surface flinger surface has
-++                // been torn down, but the application has not yet been
-++                // notified via SurfaceHolder.Callback.surfaceDestroyed.
-++                // In theory the application should be notified first,
-++                // but in practice sometimes it is not. See b/4588890
-++                Log.e(TAG, "eglCreateWindowSurface", e);
-++            }
-++            return result;
-++        }
-++
-++        public void destroySurface(EGL10 egl, EGLDisplay display,
-++                EGLSurface surface) {
-++            egl.eglDestroySurface(display, surface);
-++        }
-++    }
-++
-++    /**
-++     * An interface for choosing an EGLConfig configuration from a list of
-++     * potential configurations.
-++     * <p>
-++     * This interface must be implemented by clients wishing to call
-++     * {@link GLSurfaceView#setEGLConfigChooser(EGLConfigChooser)}
-++     */
-++    public interface EGLConfigChooser {
-++        /**
-++         * Choose a configuration from the list. Implementors typically
-++         * implement this method by calling
-++         * {@link EGL10#eglChooseConfig} and iterating through the results. Please consult the
-++         * EGL specification available from The Khronos Group to learn how to call eglChooseConfig.
-++         * @param egl the EGL10 for the current display.
-++         * @param display the current display.
-++         * @return the chosen configuration.
-++         */
-++        EGLConfig chooseConfig(EGL10 egl, EGLDisplay display);
-++    }
-++
-++    private abstract class BaseConfigChooser
-++            implements EGLConfigChooser {
-++        public BaseConfigChooser(int[] configSpec) {
-++            mConfigSpec = filterConfigSpec(configSpec);
-++        }
-++
-++        public EGLConfig chooseConfig(EGL10 egl, EGLDisplay display) {
-++            int[] num_config = new int[1];
-++            if (!egl.eglChooseConfig(display, mConfigSpec, null, 0,
-++                    num_config)) {
-++                throw new IllegalArgumentException("eglChooseConfig failed");
-++            }
-++
-++            int numConfigs = num_config[0];
-++
-++            if (numConfigs <= 0) {
-++                throw new IllegalArgumentException(
-++                        "No configs match configSpec");
-++            }
-++
-++            EGLConfig[] configs = new EGLConfig[numConfigs];
-++            if (!egl.eglChooseConfig(display, mConfigSpec, configs, numConfigs,
-++                    num_config)) {
-++                throw new IllegalArgumentException("eglChooseConfig#2 failed");
-++            }
-++            EGLConfig config = chooseConfig(egl, display, configs);
-++            if (config == null) {
-++                throw new IllegalArgumentException("No config chosen");
-++            }
-++            return config;
-++        }
-++
-++        abstract EGLConfig chooseConfig(EGL10 egl, EGLDisplay display,
-++                EGLConfig[] configs);
-++
-++        protected int[] mConfigSpec;
-++
-++        private int[] filterConfigSpec(int[] configSpec) {
-++            if (mEGLContextClientVersion != 2 && mEGLContextClientVersion != 3) {
-++                return configSpec;
-++            }
-++            /* We know none of the subclasses define EGL_RENDERABLE_TYPE.
-++             * And we know the configSpec is well formed.
-++             */
-++            int len = configSpec.length;
-++            int[] newConfigSpec = new int[len + 2];
-++            System.arraycopy(configSpec, 0, newConfigSpec, 0, len-1);
-++            newConfigSpec[len-1] = EGL10.EGL_RENDERABLE_TYPE;
-++            if (mEGLContextClientVersion == 2) {
-++                newConfigSpec[len] = EGL14.EGL_OPENGL_ES2_BIT;  /* EGL_OPENGL_ES2_BIT */
-++            } else {
-++                newConfigSpec[len] = EGLExt.EGL_OPENGL_ES3_BIT_KHR; /* EGL_OPENGL_ES3_BIT_KHR */
-++            }
-++            newConfigSpec[len+1] = EGL10.EGL_NONE;
-++            return newConfigSpec;
-++        }
-++    }
-++
-++    /**
-++     * Choose a configuration with exactly the specified r,g,b,a sizes,
-++     * and at least the specified depth and stencil sizes.
-++     */
-++    private class ComponentSizeChooser extends BaseConfigChooser {
-++        public ComponentSizeChooser(int redSize, int greenSize, int blueSize,
-++                int alphaSize, int depthSize, int stencilSize) {
-++            super(new int[] {
-++                    EGL10.EGL_RED_SIZE, redSize,
-++                    EGL10.EGL_GREEN_SIZE, greenSize,
-++                    EGL10.EGL_BLUE_SIZE, blueSize,
-++                    EGL10.EGL_ALPHA_SIZE, alphaSize,
-++                    EGL10.EGL_DEPTH_SIZE, depthSize,
-++                    EGL10.EGL_STENCIL_SIZE, stencilSize,
-++                    EGL10.EGL_NONE});
-++            mValue = new int[1];
-++            mRedSize = redSize;
-++            mGreenSize = greenSize;
-++            mBlueSize = blueSize;
-++            mAlphaSize = alphaSize;
-++            mDepthSize = depthSize;
-++            mStencilSize = stencilSize;
-++       }
-++
-++        @Override
-++        public EGLConfig chooseConfig(EGL10 egl, EGLDisplay display,
-++                EGLConfig[] configs) {
-++            for (EGLConfig config : configs) {
-++                int d = findConfigAttrib(egl, display, config,
-++                        EGL10.EGL_DEPTH_SIZE, 0);
-++                int s = findConfigAttrib(egl, display, config,
-++                        EGL10.EGL_STENCIL_SIZE, 0);
-++                if ((d >= mDepthSize) && (s >= mStencilSize)) {
-++                    int r = findConfigAttrib(egl, display, config,
-++                            EGL10.EGL_RED_SIZE, 0);
-++                    int g = findConfigAttrib(egl, display, config,
-++                             EGL10.EGL_GREEN_SIZE, 0);
-++                    int b = findConfigAttrib(egl, display, config,
-++                              EGL10.EGL_BLUE_SIZE, 0);
-++                    int a = findConfigAttrib(egl, display, config,
-++                            EGL10.EGL_ALPHA_SIZE, 0);
-++                    if ((r == mRedSize) && (g == mGreenSize)
-++                            && (b == mBlueSize) && (a == mAlphaSize)) {
-++                        return config;
-++                    }
-++                }
-++            }
-++            return null;
-++        }
-++
-++        private int findConfigAttrib(EGL10 egl, EGLDisplay display,
-++                EGLConfig config, int attribute, int defaultValue) {
-++
-++            if (egl.eglGetConfigAttrib(display, config, attribute, mValue)) {
-++                return mValue[0];
-++            }
-++            return defaultValue;
-++        }
-++
-++        private int[] mValue;
-++        // Subclasses can adjust these values:
-++        protected int mRedSize;
-++        protected int mGreenSize;
-++        protected int mBlueSize;
-++        protected int mAlphaSize;
-++        protected int mDepthSize;
-++        protected int mStencilSize;
-++        }
-++
-++    /**
-++     * This class will choose a RGB_888 surface with
-++     * or without a depth buffer.
-++     *
-++     */
-++    private class SimpleEGLConfigChooser extends ComponentSizeChooser {
-++        public SimpleEGLConfigChooser(boolean withDepthBuffer) {
-++            super(8, 8, 8, 0, withDepthBuffer ? 16 : 0, 0);
-++        }
-++    }
-++
-++    /**
-++     * An EGL helper class.
-++     */
-++
-++    private static class EglHelper {
-++        public EglHelper(WeakReference<GLSurfaceView> glSurfaceViewWeakRef) {
-++            mGLSurfaceViewWeakRef = glSurfaceViewWeakRef;
-++        }
-++
-++        /**
-++         * Initialize EGL for a given configuration spec.
-++         * @param configSpec
-++         */
-++        public void start() {
-++            if (LOG_EGL) {
-++                Log.w("EglHelper", "start() tid=" + Thread.currentThread().getId());
-++            }
-++            /*
-++             * Get an EGL instance
-++             */
-++            mEgl = (EGL10) EGLContext.getEGL();
-++
-++            /*
-++             * Get to the default display.
-++             */
-++            mEglDisplay = mEgl.eglGetDisplay(EGL10.EGL_DEFAULT_DISPLAY);
-++
-++            if (mEglDisplay == EGL10.EGL_NO_DISPLAY) {
-++                throw new RuntimeException("eglGetDisplay failed");
-++            }
-++
-++            /*
-++             * We can now initialize EGL for that display
-++             */
-++            int[] version = new int[2];
-++            if(!mEgl.eglInitialize(mEglDisplay, version)) {
-++                throw new RuntimeException("eglInitialize failed");
-++            }
-++            GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-++            if (view == null) {
-++                mEglConfig = null;
-++                mEglContext = null;
-++            } else {
-++                mEglConfig = view.mEGLConfigChooser.chooseConfig(mEgl, mEglDisplay);
-++
-++                /*
-++                * Create an EGL context. We want to do this as rarely as we can, because an
-++                * EGL context is a somewhat heavy object.
-++                */
-++                mEglContext = view.mEGLContextFactory.createContext(mEgl, mEglDisplay, mEglConfig);
-++            }
-++            if (mEglContext == null || mEglContext == EGL10.EGL_NO_CONTEXT) {
-++                mEglContext = null;
-++                throwEglException("createContext");
-++            }
-++            if (LOG_EGL) {
-++                Log.w("EglHelper", "createContext " + mEglContext + " tid=" + Thread.currentThread().getId());
-++            }
-++
-++            mEglSurface = null;
-++        }
-++
-++        /**
-++         * Create an egl surface for the current SurfaceHolder surface. If a surface
-++         * already exists, destroy it before creating the new surface.
-++         *
-++         * @return true if the surface was created successfully.
-++         */
-++        public boolean createSurface() {
-++            if (LOG_EGL) {
-++                Log.w("EglHelper", "createSurface()  tid=" + Thread.currentThread().getId());
-++            }
-++            /*
-++             * Check preconditions.
-++             */
-++            if (mEgl == null) {
-++                throw new RuntimeException("egl not initialized");
-++            }
-++            if (mEglDisplay == null) {
-++                throw new RuntimeException("eglDisplay not initialized");
-++            }
-++            if (mEglConfig == null) {
-++                throw new RuntimeException("mEglConfig not initialized");
-++            }
-++
-++            /*
-++             *  The window size has changed, so we need to create a new
-++             *  surface.
-++             */
-++            destroySurfaceImp();
-++
-++            /*
-++             * Create an EGL surface we can render into.
-++             */
-++            GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-++            if (view != null) {
-++                mEglSurface = view.mEGLWindowSurfaceFactory.createWindowSurface(mEgl,
-++                        mEglDisplay, mEglConfig, view.getHolder());
-++            } else {
-++                mEglSurface = null;
-++            }
-++
-++            if (mEglSurface == null || mEglSurface == EGL10.EGL_NO_SURFACE) {
-++                int error = mEgl.eglGetError();
-++                if (error == EGL10.EGL_BAD_NATIVE_WINDOW) {
-++                    Log.e("EglHelper", "createWindowSurface returned EGL_BAD_NATIVE_WINDOW.");
-++                }
-++                return false;
-++            }
-++
-++            /*
-++             * Before we can issue GL commands, we need to make sure
-++             * the context is current and bound to a surface.
-++             */
-++            if (!mEgl.eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface, mEglContext)) {
-++                /*
-++                 * Could not make the context current, probably because the underlying
-++                 * SurfaceView surface has been destroyed.
-++                 */
-++                logEglErrorAsWarning("EGLHelper", "eglMakeCurrent", mEgl.eglGetError());
-++                return false;
-++            }
-++
-++            return true;
-++        }
-++
-++        /**
-++         * Create a GL object for the current EGL context.
-++         * @return
-++         */
-++        GL createGL() {
-++
-++            GL gl = mEglContext.getGL();
-++            GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-++            if (view != null) {
-++                if (view.mGLWrapper != null) {
-++                    gl = view.mGLWrapper.wrap(gl);
-++                }
-++
-++                if ((view.mDebugFlags & (DEBUG_CHECK_GL_ERROR | DEBUG_LOG_GL_CALLS)) != 0) {
-++                    int configFlags = 0;
-++                    Writer log = null;
-++                    if ((view.mDebugFlags & DEBUG_CHECK_GL_ERROR) != 0) {
-++                        configFlags |= GLDebugHelper.CONFIG_CHECK_GL_ERROR;
-++                    }
-++                    if ((view.mDebugFlags & DEBUG_LOG_GL_CALLS) != 0) {
-++                        log = new LogWriter();
-++                    }
-++                    gl = GLDebugHelper.wrap(gl, configFlags, log);
-++                }
-++            }
-++            return gl;
-++        }
-++
-++        /**
-++         * Display the current render surface.
-++         * @return the EGL error code from eglSwapBuffers.
-++         */
-++        public int swap() {
-++            if (! mEgl.eglSwapBuffers(mEglDisplay, mEglSurface)) {
-++                return mEgl.eglGetError();
-++            }
-++            return EGL10.EGL_SUCCESS;
-++        }
-++
-++        public void destroySurface() {
-++            if (LOG_EGL) {
-++                Log.w("EglHelper", "destroySurface()  tid=" + Thread.currentThread().getId());
-++            }
-++            destroySurfaceImp();
-++        }
-++
-++        private void destroySurfaceImp() {
-++            if (mEglSurface != null && mEglSurface != EGL10.EGL_NO_SURFACE) {
-++                mEgl.eglMakeCurrent(mEglDisplay, EGL10.EGL_NO_SURFACE,
-++                        EGL10.EGL_NO_SURFACE,
-++                        EGL10.EGL_NO_CONTEXT);
-++                GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-++                if (view != null) {
-++                    view.mEGLWindowSurfaceFactory.destroySurface(mEgl, mEglDisplay, mEglSurface);
-++                }
-++                mEglSurface = null;
-++            }
-++        }
-++
-++        public void finish() {
-++            if (LOG_EGL) {
-++                Log.w("EglHelper", "finish() tid=" + Thread.currentThread().getId());
-++            }
-++            if (mEglContext != null) {
-++                GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-++                if (view != null) {
-++                    view.mEGLContextFactory.destroyContext(mEgl, mEglDisplay, mEglContext);
-++                }
-++                mEglContext = null;
-++            }
-++            if (mEglDisplay != null) {
-++                mEgl.eglTerminate(mEglDisplay);
-++                mEglDisplay = null;
-++            }
-++        }
-++
-++        private void throwEglException(String function) {
-++            throwEglException(function, mEgl.eglGetError());
-++        }
-++
-++        public static void throwEglException(String function, int error) {
-++            String message = formatEglError(function, error);
-++            if (LOG_THREADS) {
-++                Log.e("EglHelper", "throwEglException tid=" + Thread.currentThread().getId() + " "
-++                        + message);
-++            }
-++            throw new RuntimeException(message);
-++        }
-++
-++        public static void logEglErrorAsWarning(String tag, String function, int error) {
-++            Log.w(tag, formatEglError(function, error));
-++        }
-++
-++        public static String formatEglError(String function, int error) {
-++            return function + " failed: " + EGLLogWrapper.getErrorString(error);
-++        }
-++
-++        private WeakReference<GLSurfaceView> mGLSurfaceViewWeakRef;
-++        EGL10 mEgl;
-++        EGLDisplay mEglDisplay;
-++        EGLSurface mEglSurface;
-++        EGLConfig mEglConfig;
-++        EGLContext mEglContext;
-++
-++    }
-++
-++    /**
-++     * A generic GL Thread. Takes care of initializing EGL and GL. Delegates
-++     * to a Renderer instance to do the actual drawing. Can be configured to
-++     * render continuously or on request.
-++     *
-++     * All potentially blocking synchronization is done through the
-++     * sGLThreadManager object. This avoids multiple-lock ordering issues.
-++     *
-++     */
-++    static class GLThread extends Thread {
-++        GLThread(WeakReference<GLSurfaceView> glSurfaceViewWeakRef) {
-++            super();
-++            mWidth = 0;
-++            mHeight = 0;
-++            mRequestRender = true;
-++            mRenderMode = RENDERMODE_CONTINUOUSLY;
-++            mWantRenderNotification = false;
-++            mGLSurfaceViewWeakRef = glSurfaceViewWeakRef;
-++        }
-++
-++        @Override
-++        public void run() {
-++            setName("GLThread " + getId());
-++            if (LOG_THREADS) {
-++                Log.i("GLThread", "starting tid=" + getId());
-++            }
-++
-++            try {
-++                guardedRun();
-++            } catch (InterruptedException e) {
-++                // fall thru and exit normally
-++            } finally {
-++                sGLThreadManager.threadExiting(this);
-++            }
-++        }
-++
-++        /*
-++         * This private method should only be called inside a
-++         * synchronized(sGLThreadManager) block.
-++         */
-++        private void stopEglSurfaceLocked() {
-++            if (mHaveEglSurface) {
-++                mHaveEglSurface = false;
-++                mEglHelper.destroySurface();
-++            }
-++        }
-++
-++        /*
-++         * This private method should only be called inside a
-++         * synchronized(sGLThreadManager) block.
-++         */
-++        private void stopEglContextLocked() {
-++            if (mHaveEglContext) {
-++                mEglHelper.finish();
-++                mHaveEglContext = false;
-++                sGLThreadManager.releaseEglContextLocked(this);
-++            }
-++        }
-++        private void guardedRun() throws InterruptedException {
-++            mEglHelper = new EglHelper(mGLSurfaceViewWeakRef);
-++            mHaveEglContext = false;
-++            mHaveEglSurface = false;
-++            mWantRenderNotification = false;
-++
-++            try {
-++                GL10 gl = null;
-++                boolean createEglContext = false;
-++                boolean createEglSurface = false;
-++                boolean createGlInterface = false;
-++                boolean lostEglContext = false;
-++                boolean sizeChanged = false;
-++                boolean wantRenderNotification = false;
-++                boolean doRenderNotification = false;
-++                boolean askedToReleaseEglContext = false;
-++                int w = 0;
-++                int h = 0;
-++                Runnable event = null;
-++
-++                while (true) {
-++                    synchronized (sGLThreadManager) {
-++                        while (true) {
-++                            if (mShouldExit) {
-++                                return;
-++                            }
-++
-++                            if (! mEventQueue.isEmpty()) {
-++                                event = mEventQueue.remove(0);
-++                                break;
-++                            }
-++
-++                            // Update the pause state.
-++                            boolean pausing = false;
-++                            if (mPaused != mRequestPaused) {
-++                                pausing = mRequestPaused;
-++                                mPaused = mRequestPaused;
-++                                sGLThreadManager.notifyAll();
-++                                if (LOG_PAUSE_RESUME) {
-++                                    Log.i("GLThread", "mPaused is now " + mPaused + " tid=" + getId());
-++                                }
-++                            }
-++
-++                            // Do we need to give up the EGL context?
-++                            if (mShouldReleaseEglContext) {
-++                                if (LOG_SURFACE) {
-++                                    Log.i("GLThread", "releasing EGL context because asked to tid=" + getId());
-++                                }
-++                                stopEglSurfaceLocked();
-++                                stopEglContextLocked();
-++                                mShouldReleaseEglContext = false;
-++                                askedToReleaseEglContext = true;
-++                            }
-++
-++                            // Have we lost the EGL context?
-++                            if (lostEglContext) {
-++                                stopEglSurfaceLocked();
-++                                stopEglContextLocked();
-++                                lostEglContext = false;
-++                            }
-++
-++                            // When pausing, release the EGL surface:
-++                            if (pausing && mHaveEglSurface) {
-++                                if (LOG_SURFACE) {
-++                                    Log.i("GLThread", "releasing EGL surface because paused tid=" + getId());
-++                                }
-++                                stopEglSurfaceLocked();
-++                            }
-++
-++                            // When pausing, optionally release the EGL Context:
-++                            if (pausing && mHaveEglContext) {
-++                                GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-++                                boolean preserveEglContextOnPause = view == null ?
-++                                        false : view.mPreserveEGLContextOnPause;
-++                                if (!preserveEglContextOnPause) {
-++                                    stopEglContextLocked();
-++                                    if (LOG_SURFACE) {
-++                                        Log.i("GLThread", "releasing EGL context because paused tid=" + getId());
-++                                    }
-++                                }
-++                            }
-++
-++                            // Have we lost the SurfaceView surface?
-++                            if ((! mHasSurface) && (! mWaitingForSurface)) {
-++                                if (LOG_SURFACE) {
-++                                    Log.i("GLThread", "noticed surfaceView surface lost tid=" + getId());
-++                                }
-++                                if (mHaveEglSurface) {
-++                                    stopEglSurfaceLocked();
-++                                }
-++                                mWaitingForSurface = true;
-++                                mSurfaceIsBad = false;
-++                                sGLThreadManager.notifyAll();
-++                            }
-++
-++                            // Have we acquired the surface view surface?
-++                            if (mHasSurface && mWaitingForSurface) {
-++                                if (LOG_SURFACE) {
-++                                    Log.i("GLThread", "noticed surfaceView surface acquired tid=" + getId());
-++                                }
-++                                mWaitingForSurface = false;
-++                                sGLThreadManager.notifyAll();
-++                            }
-++
-++                            if (doRenderNotification) {
-++                                if (LOG_SURFACE) {
-++                                    Log.i("GLThread", "sending render notification tid=" + getId());
-++                                }
-++                                mWantRenderNotification = false;
-++                                doRenderNotification = false;
-++                                mRenderComplete = true;
-++                                sGLThreadManager.notifyAll();
-++                            }
-++
-++                            // Ready to draw?
-++                            if (readyToDraw()) {
-++
-++                                // If we don't have an EGL context, try to acquire one.
-++                                if (! mHaveEglContext) {
-++                                    if (askedToReleaseEglContext) {
-++                                        askedToReleaseEglContext = false;
-++                                    } else {
-++                                        try {
-++                                            mEglHelper.start();
-++                                        } catch (RuntimeException t) {
-++                                            sGLThreadManager.releaseEglContextLocked(this);
-++                                            throw t;
-++                                        }
-++                                        mHaveEglContext = true;
-++                                        createEglContext = true;
-++
-++                                        sGLThreadManager.notifyAll();
-++                                    }
-++                                }
-++
-++                                if (mHaveEglContext && !mHaveEglSurface) {
-++                                    mHaveEglSurface = true;
-++                                    createEglSurface = true;
-++                                    createGlInterface = true;
-++                                    sizeChanged = true;
-++                                }
-++
-++                                if (mHaveEglSurface) {
-++                                    if (mSizeChanged) {
-++                                        sizeChanged = true;
-++                                        w = mWidth;
-++                                        h = mHeight;
-++                                        mWantRenderNotification = true;
-++                                        if (LOG_SURFACE) {
-++                                            Log.i("GLThread",
-++                                                    "noticing that we want render notification tid="
-++                                                    + getId());
-++                                        }
-++
-++                                        // Destroy and recreate the EGL surface.
-++                                        createEglSurface = true;
-++
-++                                        mSizeChanged = false;
-++                                    }
-++                                    mRequestRender = false;
-++                                    sGLThreadManager.notifyAll();
-++                                    if (mWantRenderNotification) {
-++                                        wantRenderNotification = true;
-++                                    }
-++                                    break;
-++                                }
-++                            }
-++
-++                            // By design, this is the only place in a GLThread thread where we wait().
-++                            if (LOG_THREADS) {
-++                                Log.i("GLThread", "waiting tid=" + getId()
-++                                    + " mHaveEglContext: " + mHaveEglContext
-++                                    + " mHaveEglSurface: " + mHaveEglSurface
-++                                    + " mFinishedCreatingEglSurface: " + mFinishedCreatingEglSurface
-++                                    + " mPaused: " + mPaused
-++                                    + " mHasSurface: " + mHasSurface
-++                                    + " mSurfaceIsBad: " + mSurfaceIsBad
-++                                    + " mWaitingForSurface: " + mWaitingForSurface
-++                                    + " mWidth: " + mWidth
-++                                    + " mHeight: " + mHeight
-++                                    + " mRequestRender: " + mRequestRender
-++                                    + " mRenderMode: " + mRenderMode);
-++                            }
-++                            sGLThreadManager.wait();
-++                        }
-++                    } // end of synchronized(sGLThreadManager)
-++
-++                    if (event != null) {
-++                        event.run();
-++                        event = null;
-++                        continue;
-++                    }
-++
-++                    if (createEglSurface) {
-++                        if (LOG_SURFACE) {
-++                            Log.w("GLThread", "egl createSurface");
-++                        }
-++                        if (mEglHelper.createSurface()) {
-++                            synchronized(sGLThreadManager) {
-++                                mFinishedCreatingEglSurface = true;
-++                                sGLThreadManager.notifyAll();
-++                            }
-++                        } else {
-++                            synchronized(sGLThreadManager) {
-++                                mFinishedCreatingEglSurface = true;
-++                                mSurfaceIsBad = true;
-++                                sGLThreadManager.notifyAll();
-++                            }
-++                            continue;
-++                        }
-++                        createEglSurface = false;
-++                    }
-++
-++                    if (createGlInterface) {
-++                        gl = (GL10) mEglHelper.createGL();
-++
-++                        createGlInterface = false;
-++                    }
-++
-++                    if (createEglContext) {
-++                        if (LOG_RENDERER) {
-++                            Log.w("GLThread", "onSurfaceCreated");
-++                        }
-++                        GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-++                        if (view != null) {
-++                            try {
-++                                Trace.traceBegin(Trace.TRACE_TAG_VIEW, "onSurfaceCreated");
-++                                view.mRenderer.onSurfaceCreated(gl, mEglHelper.mEglConfig);
-++                            } finally {
-++                                Trace.traceEnd(Trace.TRACE_TAG_VIEW);
-++                            }
-++                        }
-++                        createEglContext = false;
-++                    }
-++
-++                    if (sizeChanged) {
-++                        if (LOG_RENDERER) {
-++                            Log.w("GLThread", "onSurfaceChanged(" + w + ", " + h + ")");
-++                        }
-++                        GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-++                        if (view != null) {
-++                            try {
-++                                Trace.traceBegin(Trace.TRACE_TAG_VIEW, "onSurfaceChanged");
-++                                view.mRenderer.onSurfaceChanged(gl, w, h);
-++                            } finally {
-++                                Trace.traceEnd(Trace.TRACE_TAG_VIEW);
-++                            }
-++                        }
-++                        sizeChanged = false;
-++                    }
-++
-++                    if (LOG_RENDERER_DRAW_FRAME) {
-++                        Log.w("GLThread", "onDrawFrame tid=" + getId());
-++                    }
-++                    {
-++                        GLSurfaceView view = mGLSurfaceViewWeakRef.get();
-++                        if (view != null) {
-++                            try {
-++                                Trace.traceBegin(Trace.TRACE_TAG_VIEW, "onDrawFrame");
-++                                view.mRenderer.onDrawFrame(gl);
-++                            } finally {
-++                                Trace.traceEnd(Trace.TRACE_TAG_VIEW);
-++                            }
-++                        }
-++                    }
-++                    int swapError = mEglHelper.swap();
-++                    switch (swapError) {
-++                        case EGL10.EGL_SUCCESS:
-++                            break;
-++                        case EGL11.EGL_CONTEXT_LOST:
-++                            if (LOG_SURFACE) {
-++                                Log.i("GLThread", "egl context lost tid=" + getId());
-++                            }
-++                            lostEglContext = true;
-++                            break;
-++                        default:
-++                            // Other errors typically mean that the current surface is bad,
-++                            // probably because the SurfaceView surface has been destroyed,
-++                            // but we haven't been notified yet.
-++                            // Log the error to help developers understand why rendering stopped.
-++                            EglHelper.logEglErrorAsWarning("GLThread", "eglSwapBuffers", swapError);
-++
-++                            synchronized(sGLThreadManager) {
-++                                mSurfaceIsBad = true;
-++                                sGLThreadManager.notifyAll();
-++                            }
-++                            break;
-++                    }
-++
-++                    if (wantRenderNotification) {
-++                        doRenderNotification = true;
-++                        wantRenderNotification = false;
-++                    }
-++                }
-++
-++            } finally {
-++                /*
-++                 * clean-up everything...
-++                 */
-++                synchronized (sGLThreadManager) {
-++                    stopEglSurfaceLocked();
-++                    stopEglContextLocked();
-++                }
-++            }
-++        }
-++
-++        public boolean ableToDraw() {
-++            return mHaveEglContext && mHaveEglSurface && readyToDraw();
-++        }
-++
-++        private boolean readyToDraw() {
-++            return (!mPaused) && mHasSurface && (!mSurfaceIsBad)
-++                && (mWidth > 0) && (mHeight > 0)
-++                && (mRequestRender || (mRenderMode == RENDERMODE_CONTINUOUSLY));
-++        }
-++
-++        public void setRenderMode(int renderMode) {
-++            if ( !((RENDERMODE_WHEN_DIRTY <= renderMode) && (renderMode <= RENDERMODE_CONTINUOUSLY)) ) {
-++                throw new IllegalArgumentException("renderMode");
-++            }
-++            synchronized(sGLThreadManager) {
-++                mRenderMode = renderMode;
-++                sGLThreadManager.notifyAll();
-++            }
-++        }
-++
-++        public int getRenderMode() {
-++            synchronized(sGLThreadManager) {
-++                return mRenderMode;
-++            }
-++        }
-++
-++        public void requestRender() {
-++            synchronized(sGLThreadManager) {
-++                mRequestRender = true;
-++                sGLThreadManager.notifyAll();
-++            }
-++        }
-++
-++        public void requestRenderAndWait() {
-++            synchronized(sGLThreadManager) {
-++                // If we are already on the GL thread, this means a client callback
-++                // has caused reentrancy, for example via updating the SurfaceView parameters.
-++                // We will return to the client rendering code, so here we don't need to
-++                // do anything.
-++                if (Thread.currentThread() == this) {
-++                    return;
-++                }
-++
-++                mWantRenderNotification = true;
-++                mRequestRender = true;
-++                mRenderComplete = false;
-++
-++                sGLThreadManager.notifyAll();
-++
-++                while (!mExited && !mPaused && !mRenderComplete && ableToDraw()) {
-++                    try {
-++                        sGLThreadManager.wait();
-++                    } catch (InterruptedException ex) {
-++                        Thread.currentThread().interrupt();
-++                    }
-++                }
-++
-++            }
-++        }
-++
-++        public void surfaceCreated() {
-++            synchronized(sGLThreadManager) {
-++                if (LOG_THREADS) {
-++                    Log.i("GLThread", "surfaceCreated tid=" + getId());
-++                }
-++                mHasSurface = true;
-++                mFinishedCreatingEglSurface = false;
-++                sGLThreadManager.notifyAll();
-++                while (mWaitingForSurface
-++                       && !mFinishedCreatingEglSurface
-++                       && !mExited) {
-++                    try {
-++                        sGLThreadManager.wait();
-++                    } catch (InterruptedException e) {
-++                        Thread.currentThread().interrupt();
-++                    }
-++                }
-++            }
-++        }
-++
-++        public void surfaceDestroyed() {
-++            synchronized(sGLThreadManager) {
-++                if (LOG_THREADS) {
-++                    Log.i("GLThread", "surfaceDestroyed tid=" + getId());
-++                }
-++                mHasSurface = false;
-++                sGLThreadManager.notifyAll();
-++                while((!mWaitingForSurface) && (!mExited)) {
-++                    try {
-++                        sGLThreadManager.wait();
-++                    } catch (InterruptedException e) {
-++                        Thread.currentThread().interrupt();
-++                    }
-++                }
-++            }
-++        }
-++
-++        public void onPause() {
-++            synchronized (sGLThreadManager) {
-++                if (LOG_PAUSE_RESUME) {
-++                    Log.i("GLThread", "onPause tid=" + getId());
-++                }
-++                mRequestPaused = true;
-++                sGLThreadManager.notifyAll();
-++                while ((! mExited) && (! mPaused)) {
-++                    if (LOG_PAUSE_RESUME) {
-++                        Log.i("Main thread", "onPause waiting for mPaused.");
-++                    }
-++                    try {
-++                        sGLThreadManager.wait();
-++                    } catch (InterruptedException ex) {
-++                        Thread.currentThread().interrupt();
-++                    }
-++                }
-++            }
-++        }
-++
-++        public void onResume() {
-++            synchronized (sGLThreadManager) {
-++                if (LOG_PAUSE_RESUME) {
-++                    Log.i("GLThread", "onResume tid=" + getId());
-++                }
-++                mRequestPaused = false;
-++                mRequestRender = true;
-++                mRenderComplete = false;
-++                sGLThreadManager.notifyAll();
-++                while ((! mExited) && mPaused && (!mRenderComplete)) {
-++                    if (LOG_PAUSE_RESUME) {
-++                        Log.i("Main thread", "onResume waiting for !mPaused.");
-++                    }
-++                    try {
-++                        sGLThreadManager.wait();
-++                    } catch (InterruptedException ex) {
-++                        Thread.currentThread().interrupt();
-++                    }
-++                }
-++            }
-++        }
-++
-++        public void onWindowResize(int w, int h) {
-++            synchronized (sGLThreadManager) {
-++                mWidth = w;
-++                mHeight = h;
-++                mSizeChanged = true;
-++                mRequestRender = true;
-++                mRenderComplete = false;
-++
-++                // If we are already on the GL thread, this means a client callback
-++                // has caused reentrancy, for example via updating the SurfaceView parameters.
-++                // We need to process the size change eventually though and update our EGLSurface.
-++                // So we set the parameters and return so they can be processed on our
-++                // next iteration.
-++                if (Thread.currentThread() == this) {
-++                    return;
-++                }
-++
-++                sGLThreadManager.notifyAll();
-++
-++                // Wait for thread to react to resize and render a frame
-++                while (! mExited && !mPaused && !mRenderComplete
-++                        && ableToDraw()) {
-++                    if (LOG_SURFACE) {
-++                        Log.i("Main thread", "onWindowResize waiting for render complete from tid=" + getId());
-++                    }
-++                    try {
-++                        sGLThreadManager.wait();
-++                    } catch (InterruptedException ex) {
-++                        Thread.currentThread().interrupt();
-++                    }
-++                }
-++            }
-++        }
-++
-++        public void requestExitAndWait() {
-++            // don't call this from GLThread thread or it is a guaranteed
-++            // deadlock!
-++            synchronized(sGLThreadManager) {
-++                mShouldExit = true;
-++                sGLThreadManager.notifyAll();
-++                while (! mExited) {
-++                    try {
-++                        sGLThreadManager.wait();
-++                    } catch (InterruptedException ex) {
-++                        Thread.currentThread().interrupt();
-++                    }
-++                }
-++            }
-++        }
-++
-++        public void requestReleaseEglContextLocked() {
-++            mShouldReleaseEglContext = true;
-++            sGLThreadManager.notifyAll();
-++        }
-++
-++        /**
-++         * Queue an "event" to be run on the GL rendering thread.
-++         * @param r the runnable to be run on the GL rendering thread.
-++         */
-++        public void queueEvent(Runnable r) {
-++            if (r == null) {
-++                throw new IllegalArgumentException("r must not be null");
-++            }
-++            synchronized(sGLThreadManager) {
-++                mEventQueue.add(r);
-++                sGLThreadManager.notifyAll();
-++            }
-++        }
-++
-++        // Once the thread is started, all accesses to the following member
-++        // variables are protected by the sGLThreadManager monitor
-++        private boolean mShouldExit;
-++        private boolean mExited;
-++        private boolean mRequestPaused;
-++        private boolean mPaused;
-++        private boolean mHasSurface;
-++        private boolean mSurfaceIsBad;
-++        private boolean mWaitingForSurface;
-++        private boolean mHaveEglContext;
-++        private boolean mHaveEglSurface;
-++        private boolean mFinishedCreatingEglSurface;
-++        private boolean mShouldReleaseEglContext;
-++        private int mWidth;
-++        private int mHeight;
-++        private int mRenderMode;
-++        private boolean mRequestRender;
-++        private boolean mWantRenderNotification;
-++        private boolean mRenderComplete;
-++        private ArrayList<Runnable> mEventQueue = new ArrayList<Runnable>();
-++        private boolean mSizeChanged = true;
-++
-++        // End of member variables protected by the sGLThreadManager monitor.
-++
-++        private EglHelper mEglHelper;
-++
-++        /**
-++         * Set once at thread construction time, nulled out when the parent view is garbage
-++         * called. This weak reference allows the GLSurfaceView to be garbage collected while
-++         * the GLThread is still alive.
-++         */
-++        private WeakReference<GLSurfaceView> mGLSurfaceViewWeakRef;
-++
-++    }
-++
-++    static class LogWriter extends Writer {
-++
-++        @Override public void close() {
-++            flushBuilder();
-++        }
-++
-++        @Override public void flush() {
-++            flushBuilder();
-++        }
-++
-++        @Override public void write(char[] buf, int offset, int count) {
-++            for(int i = 0; i < count; i++) {
-++                char c = buf[offset + i];
-++                if ( c == '\n') {
-++                    flushBuilder();
-++                }
-++                else {
-++                    mBuilder.append(c);
-++                }
-++            }
-++        }
-++
-++        private void flushBuilder() {
-++            if (mBuilder.length() > 0) {
-++                Log.v("GLSurfaceView", mBuilder.toString());
-++                mBuilder.delete(0, mBuilder.length());
-++            }
-++        }
-++
-++        private StringBuilder mBuilder = new StringBuilder();
-++    }
-++
-++
-++    private void checkRenderThreadState() {
-++        if (mGLThread != null) {
-++            throw new IllegalStateException(
-++                    "setRenderer has already been called for this instance.");
-++        }
-++    }
-++
-++    private static class GLThreadManager {
-++        private static String TAG = "GLThreadManager";
-++
-++        public synchronized void threadExiting(GLThread thread) {
-++            if (LOG_THREADS) {
-++                Log.i("GLThread", "exiting tid=" +  thread.getId());
-++            }
-++            thread.mExited = true;
-++            notifyAll();
-++        }
-++
-++        /*
-++         * Releases the EGL context. Requires that we are already in the
-++         * sGLThreadManager monitor when this is called.
-++         */
-++        public void releaseEglContextLocked(GLThread thread) {
-++            notifyAll();
-++        }
-++    }
-++
-++    private static final GLThreadManager sGLThreadManager = new GLThreadManager();
-++
-++    private final WeakReference<GLSurfaceView> mThisWeakRef =
-++            new WeakReference<GLSurfaceView>(this);
-++    private GLThread mGLThread;
-++    private Renderer mRenderer;
-++    private boolean mDetached;
-++    private EGLConfigChooser mEGLConfigChooser;
-++    private EGLContextFactory mEGLContextFactory;
-++    private EGLWindowSurfaceFactory mEGLWindowSurfaceFactory;
-++    private GLWrapper mGLWrapper;
-++    private int mDebugFlags;
-++    private int mEGLContextClientVersion;
-++    private boolean mPreserveEGLContextOnPause;
-++}
diff -Naur frameworksRaw/base/opengl/java/android/opengl/GLSurfaceView.java.rej frameworksModified/base/opengl/java/android/opengl/GLSurfaceView.java.rej
--- frameworksRaw/base/opengl/java/android/opengl/GLSurfaceView.java.rej	2017-07-06 15:34:16.022010952 +0530
+++ frameworksModified/base/opengl/java/android/opengl/GLSurfaceView.java.rej	1970-01-01 05:30:00.000000000 +0530
@@ -1,14 +0,0 @@
---- base/opengl/java/android/opengl/GLSurfaceView.java	2017-07-06 09:54:16.855708333 +0530
-+++ base/opengl/java/android/opengl/GLSurfaceView.java	2017-07-06 13:50:03.643301736 +0530
-@@ -992,10 +992,7 @@
-      */
-     private class SimpleEGLConfigChooser extends ComponentSizeChooser {
-         public SimpleEGLConfigChooser(boolean withDepthBuffer) {
--	    //default
--            //super(8, 8, 8, 0, withDepthBuffer ? 16 : 0, 0);
--	    //rpi patch
--	    super(8, 8, 8, 8, withDepthBuffer ? 24 : 0, 0);
-+            super(8, 8, 8, 0, withDepthBuffer ? 16 : 0, 0);
-         }
-     }
- 
diff -Naur frameworksRaw/base/opengl/java/android/opengl/GLSurfaceView.java.rej.orig frameworksModified/base/opengl/java/android/opengl/GLSurfaceView.java.rej.orig
--- frameworksRaw/base/opengl/java/android/opengl/GLSurfaceView.java.rej.orig	2017-07-06 15:34:16.022010952 +0530
+++ frameworksModified/base/opengl/java/android/opengl/GLSurfaceView.java.rej.orig	1970-01-01 05:30:00.000000000 +0530
@@ -1,14 +0,0 @@
---- base/opengl/java/android/opengl/GLSurfaceView.java	2017-07-06 09:54:16.855708333 +0530
-+++ base/opengl/java/android/opengl/GLSurfaceView.java	2017-07-06 13:50:03.643301736 +0530
-@@ -992,10 +992,7 @@
-      */
-     private class SimpleEGLConfigChooser extends ComponentSizeChooser {
-         public SimpleEGLConfigChooser(boolean withDepthBuffer) {
--	    //default
--            //super(8, 8, 8, 0, withDepthBuffer ? 16 : 0, 0);
--	    //rpi patch
--	    super(8, 8, 8, 8, withDepthBuffer ? 24 : 0, 0);
-+            super(8, 8, 8, 0, withDepthBuffer ? 16 : 0, 0);
-         }
-     }
- 
diff -Naur frameworksRaw/base/opengl/java/android/opengl/GLSurfaceView.java.rej.orig.orig frameworksModified/base/opengl/java/android/opengl/GLSurfaceView.java.rej.orig.orig
--- frameworksRaw/base/opengl/java/android/opengl/GLSurfaceView.java.rej.orig.orig	2017-07-06 15:34:16.042012638 +0530
+++ frameworksModified/base/opengl/java/android/opengl/GLSurfaceView.java.rej.orig.orig	1970-01-01 05:30:00.000000000 +0530
@@ -1,14 +0,0 @@
---- base/opengl/java/android/opengl/GLSurfaceView.java	2017-07-06 09:54:16.855708333 +0530
-+++ base/opengl/java/android/opengl/GLSurfaceView.java	2017-07-06 13:50:03.643301736 +0530
-@@ -992,10 +992,7 @@
-      */
-     private class SimpleEGLConfigChooser extends ComponentSizeChooser {
-         public SimpleEGLConfigChooser(boolean withDepthBuffer) {
--	    //default
--            //super(8, 8, 8, 0, withDepthBuffer ? 16 : 0, 0);
--	    //rpi patch
--	    super(8, 8, 8, 8, withDepthBuffer ? 24 : 0, 0);
-+            super(8, 8, 8, 0, withDepthBuffer ? 16 : 0, 0);
-         }
-     }
- 
diff -Naur frameworksRaw/base/opengl/java/android/opengl/GLSurfaceView.java.rej.orig.rej frameworksModified/base/opengl/java/android/opengl/GLSurfaceView.java.rej.orig.rej
--- frameworksRaw/base/opengl/java/android/opengl/GLSurfaceView.java.rej.orig.rej	2017-07-06 15:34:16.006009602 +0530
+++ frameworksModified/base/opengl/java/android/opengl/GLSurfaceView.java.rej.orig.rej	1970-01-01 05:30:00.000000000 +0530
@@ -1,17 +0,0 @@
---- base/opengl/java/android/opengl/GLSurfaceView.java.rej.orig	1970-01-01 05:30:00.000000000 +0530
-+++ base/opengl/java/android/opengl/GLSurfaceView.java.rej.orig	2017-07-06 13:50:03.699303553 +0530
-@@ -0,0 +1,14 @@
-+--- base/opengl/java/android/opengl/GLSurfaceView.java	2017-07-04 12:24:27.923090645 +0530
-++++ base/opengl/java/android/opengl/GLSurfaceView.java	2017-07-05 17:28:13.550388061 +0530
-+@@ -992,10 +992,7 @@
-+      */
-+     private class SimpleEGLConfigChooser extends ComponentSizeChooser {
-+         public SimpleEGLConfigChooser(boolean withDepthBuffer) {
-+-	    //default
-+-            //super(8, 8, 8, 0, withDepthBuffer ? 16 : 0, 0);
-+-	    //rpi patch
-+-	    super(8, 8, 8, 8, withDepthBuffer ? 24 : 0, 0);
-++            super(8, 8, 8, 0, withDepthBuffer ? 16 : 0, 0);
-+         }
-+     }
-+ 
diff -Naur frameworksRaw/base/opengl/java/android/opengl/GLSurfaceView.java.rej.rej frameworksModified/base/opengl/java/android/opengl/GLSurfaceView.java.rej.rej
--- frameworksRaw/base/opengl/java/android/opengl/GLSurfaceView.java.rej.rej	2017-07-06 15:34:16.042012638 +0530
+++ frameworksModified/base/opengl/java/android/opengl/GLSurfaceView.java.rej.rej	1970-01-01 05:30:00.000000000 +0530
@@ -1,17 +0,0 @@
---- base/opengl/java/android/opengl/GLSurfaceView.java.rej	1970-01-01 05:30:00.000000000 +0530
-+++ base/opengl/java/android/opengl/GLSurfaceView.java.rej	2017-07-06 13:50:03.699303553 +0530
-@@ -0,0 +1,14 @@
-+--- base/opengl/java/android/opengl/GLSurfaceView.java	2017-07-04 12:24:27.923090645 +0530
-++++ base/opengl/java/android/opengl/GLSurfaceView.java	2017-07-05 17:28:13.550388061 +0530
-+@@ -992,10 +992,7 @@
-+      */
-+     private class SimpleEGLConfigChooser extends ComponentSizeChooser {
-+         public SimpleEGLConfigChooser(boolean withDepthBuffer) {
-+-	    //default
-+-            //super(8, 8, 8, 0, withDepthBuffer ? 16 : 0, 0);
-+-	    //rpi patch
-+-	    super(8, 8, 8, 8, withDepthBuffer ? 24 : 0, 0);
-++            super(8, 8, 8, 0, withDepthBuffer ? 16 : 0, 0);
-+         }
-+     }
-+ 
diff -Naur frameworksRaw/base/opengl/java/android/opengl/GLSurfaceView.java.rej.rej.orig frameworksModified/base/opengl/java/android/opengl/GLSurfaceView.java.rej.rej.orig
--- frameworksRaw/base/opengl/java/android/opengl/GLSurfaceView.java.rej.rej.orig	2017-07-06 15:34:16.050013316 +0530
+++ frameworksModified/base/opengl/java/android/opengl/GLSurfaceView.java.rej.rej.orig	1970-01-01 05:30:00.000000000 +0530
@@ -1,17 +0,0 @@
---- base/opengl/java/android/opengl/GLSurfaceView.java.rej	1970-01-01 05:30:00.000000000 +0530
-+++ base/opengl/java/android/opengl/GLSurfaceView.java.rej	2017-07-06 13:50:03.699303553 +0530
-@@ -0,0 +1,14 @@
-+--- base/opengl/java/android/opengl/GLSurfaceView.java	2017-07-04 12:24:27.923090645 +0530
-++++ base/opengl/java/android/opengl/GLSurfaceView.java	2017-07-05 17:28:13.550388061 +0530
-+@@ -992,10 +992,7 @@
-+      */
-+     private class SimpleEGLConfigChooser extends ComponentSizeChooser {
-+         public SimpleEGLConfigChooser(boolean withDepthBuffer) {
-+-	    //default
-+-            //super(8, 8, 8, 0, withDepthBuffer ? 16 : 0, 0);
-+-	    //rpi patch
-+-	    super(8, 8, 8, 8, withDepthBuffer ? 24 : 0, 0);
-++            super(8, 8, 8, 0, withDepthBuffer ? 16 : 0, 0);
-+         }
-+     }
-+ 
diff -Naur frameworksRaw/base/opengl/java/android/opengl/GLSurfaceView.java.rej.rej.rej frameworksModified/base/opengl/java/android/opengl/GLSurfaceView.java.rej.rej.rej
--- frameworksRaw/base/opengl/java/android/opengl/GLSurfaceView.java.rej.rej.rej	2017-07-06 15:34:16.050013316 +0530
+++ frameworksModified/base/opengl/java/android/opengl/GLSurfaceView.java.rej.rej.rej	1970-01-01 05:30:00.000000000 +0530
@@ -1,20 +0,0 @@
---- base/opengl/java/android/opengl/GLSurfaceView.java.rej.rej	1970-01-01 05:30:00.000000000 +0530
-+++ base/opengl/java/android/opengl/GLSurfaceView.java.rej.rej	2017-07-06 13:50:03.699303553 +0530
-@@ -0,0 +1,17 @@
-+--- base/opengl/java/android/opengl/GLSurfaceView.java.rej	1970-01-01 05:30:00.000000000 +0530
-++++ base/opengl/java/android/opengl/GLSurfaceView.java.rej	2017-07-05 18:25:26.212564099 +0530
-+@@ -0,0 +1,14 @@
-++--- frameworks/base/opengl/java/android/opengl/GLSurfaceView.java	2017-07-04 12:24:27.923090645 +0530
-+++++ frameworks/base/opengl/java/android/opengl/GLSurfaceView.java	2017-07-05 17:28:13.550388061 +0530
-++@@ -992,10 +992,7 @@
-++      */
-++     private class SimpleEGLConfigChooser extends ComponentSizeChooser {
-++         public SimpleEGLConfigChooser(boolean withDepthBuffer) {
-++-	    //default
-++-            //super(8, 8, 8, 0, withDepthBuffer ? 16 : 0, 0);
-++-	    //rpi patch
-++-	    super(8, 8, 8, 8, withDepthBuffer ? 24 : 0, 0);
-+++            super(8, 8, 8, 0, withDepthBuffer ? 16 : 0, 0);
-++         }
-++     }
-++ 
diff -Naur frameworksRaw/base/opengl/java/android/README.rej frameworksModified/base/opengl/java/android/README.rej
--- frameworksRaw/base/opengl/java/android/README.rej	2017-07-06 15:34:16.162022760 +0530
+++ frameworksModified/base/opengl/java/android/README.rej	1970-01-01 05:30:00.000000000 +0530
@@ -1,4 +0,0 @@
---- base/opengl/java/android/README	2017-07-06 09:54:16.795705851 +0530
-+++ base/opengl/java/android/README	1970-01-01 05:30:00.000000000 +0530
-@@ -1 +0,0 @@
--#patch for hal_pixel_formet
diff -Naur frameworksRaw/base/opengl/java/android/README.rej.orig frameworksModified/base/opengl/java/android/README.rej.orig
--- frameworksRaw/base/opengl/java/android/README.rej.orig	2017-07-06 15:34:16.162022760 +0530
+++ frameworksModified/base/opengl/java/android/README.rej.orig	1970-01-01 05:30:00.000000000 +0530
@@ -1,4 +0,0 @@
---- base/opengl/java/android/README	2017-07-06 09:54:16.795705851 +0530
-+++ base/opengl/java/android/README	1970-01-01 05:30:00.000000000 +0530
-@@ -1 +0,0 @@
--#patch for hal_pixel_formet
diff -Naur frameworksRaw/base/opengl/java/android/README.rej.orig.orig frameworksModified/base/opengl/java/android/README.rej.orig.orig
--- frameworksRaw/base/opengl/java/android/README.rej.orig.orig	2017-07-06 15:34:16.162022760 +0530
+++ frameworksModified/base/opengl/java/android/README.rej.orig.orig	1970-01-01 05:30:00.000000000 +0530
@@ -1,4 +0,0 @@
---- base/opengl/java/android/README	2017-07-06 09:54:16.795705851 +0530
-+++ base/opengl/java/android/README	1970-01-01 05:30:00.000000000 +0530
-@@ -1 +0,0 @@
--#patch for hal_pixel_formet
diff -Naur frameworksRaw/base/opengl/java/android/README.rej.orig.rej frameworksModified/base/opengl/java/android/README.rej.orig.rej
--- frameworksRaw/base/opengl/java/android/README.rej.orig.rej	2017-07-06 15:34:16.154022086 +0530
+++ frameworksModified/base/opengl/java/android/README.rej.orig.rej	1970-01-01 05:30:00.000000000 +0530
@@ -1,7 +0,0 @@
---- base/opengl/java/android/README.rej.orig	1970-01-01 05:30:00.000000000 +0530
-+++ base/opengl/java/android/README.rej.orig	2017-07-06 13:50:03.859308746 +0530
-@@ -0,0 +1,4 @@
-+--- base/opengl/java/android/README	2017-07-04 12:24:27.919090515 +0530
-++++ base/opengl/java/android/README	1970-01-01 05:30:00.000000000 +0530
-+@@ -1 +0,0 @@
-+-#patch for hal_pixel_formet
diff -Naur frameworksRaw/base/opengl/java/android/README.rej.rej frameworksModified/base/opengl/java/android/README.rej.rej
--- frameworksRaw/base/opengl/java/android/README.rej.rej	2017-07-06 15:34:16.158022426 +0530
+++ frameworksModified/base/opengl/java/android/README.rej.rej	1970-01-01 05:30:00.000000000 +0530
@@ -1,7 +0,0 @@
---- base/opengl/java/android/README.rej	1970-01-01 05:30:00.000000000 +0530
-+++ base/opengl/java/android/README.rej	2017-07-06 13:50:03.859308746 +0530
-@@ -0,0 +1,4 @@
-+--- base/opengl/java/android/README	2017-07-04 12:24:27.919090515 +0530
-++++ base/opengl/java/android/README	1970-01-01 05:30:00.000000000 +0530
-+@@ -1 +0,0 @@
-+-#patch for hal_pixel_formet
diff -Naur frameworksRaw/base/opengl/java/android/README.rej.rej.orig frameworksModified/base/opengl/java/android/README.rej.rej.orig
--- frameworksRaw/base/opengl/java/android/README.rej.rej.orig	2017-07-06 15:34:16.162022760 +0530
+++ frameworksModified/base/opengl/java/android/README.rej.rej.orig	1970-01-01 05:30:00.000000000 +0530
@@ -1,7 +0,0 @@
---- base/opengl/java/android/README.rej	1970-01-01 05:30:00.000000000 +0530
-+++ base/opengl/java/android/README.rej	2017-07-06 13:50:03.859308746 +0530
-@@ -0,0 +1,4 @@
-+--- base/opengl/java/android/README	2017-07-04 12:24:27.919090515 +0530
-++++ base/opengl/java/android/README	1970-01-01 05:30:00.000000000 +0530
-+@@ -1 +0,0 @@
-+-#patch for hal_pixel_formet
diff -Naur frameworksRaw/base/opengl/java/android/README.rej.rej.rej frameworksModified/base/opengl/java/android/README.rej.rej.rej
--- frameworksRaw/base/opengl/java/android/README.rej.rej.rej	2017-07-06 15:34:16.162022760 +0530
+++ frameworksModified/base/opengl/java/android/README.rej.rej.rej	1970-01-01 05:30:00.000000000 +0530
@@ -1,10 +0,0 @@
---- base/opengl/java/android/README.rej.rej	1970-01-01 05:30:00.000000000 +0530
-+++ base/opengl/java/android/README.rej.rej	2017-07-06 13:50:03.859308746 +0530
-@@ -0,0 +1,7 @@
-+--- base/opengl/java/android/README.rej	1970-01-01 05:30:00.000000000 +0530
-++++ base/opengl/java/android/README.rej	2017-07-05 18:25:26.212564099 +0530
-+@@ -0,0 +1,4 @@
-++--- frameworks/base/opengl/java/android/README	2017-07-04 12:24:27.919090515 +0530
-+++++ frameworks/base/opengl/java/android/README	1970-01-01 05:30:00.000000000 +0530
-++@@ -1 +0,0 @@
-++-#patch for hal_pixel_formet
diff -Naur frameworksRaw/native/opengl/libs/EGL/eglApi.cpp frameworksModified/native/opengl/libs/EGL/eglApi.cpp
--- frameworksRaw/native/opengl/libs/EGL/eglApi.cpp	2017-07-06 15:34:21.142441857 +0530
+++ frameworksModified/native/opengl/libs/EGL/eglApi.cpp	2017-07-06 15:32:49.355191427 +0530
@@ -496,7 +496,10 @@
         cnx->egl.eglGetConfigAttrib(iDpy, config, EGL_ALPHA_SIZE, &a);
         if (a > 0) {
             // alpha-channel requested, there's really only one suitable format
-            format = HAL_PIXEL_FORMAT_RGBA_8888;
+	    //default
+            //format = HAL_PIXEL_FORMAT_RGBA_8888;
+	    // RPI patch
+	    format = HAL_PIXEL_FORMAT_BGRA_8888;
         } else {
             EGLint r, g, b;
             r = g = b = 0;
@@ -1860,7 +1863,10 @@
     // Validate format.
     if (red_size == 8 && green_size == 8 && blue_size == 8) {
         if (alpha_size == 8) {
-            format = HAL_PIXEL_FORMAT_RGBA_8888;
+	    //default
+            //format = HAL_PIXEL_FORMAT_RGBA_8888;
+	    //rpi patch
+	    format = HAL_PIXEL_FORMAT_BGRA_8888;
         } else {
             format = HAL_PIXEL_FORMAT_RGB_888;
         }
diff -Naur frameworksRaw/native/opengl/libs/EGL/eglApi.cpp.orig frameworksModified/native/opengl/libs/EGL/eglApi.cpp.orig
--- frameworksRaw/native/opengl/libs/EGL/eglApi.cpp.orig	2017-07-06 15:34:21.250450915 +0530
+++ frameworksModified/native/opengl/libs/EGL/eglApi.cpp.orig	1970-01-01 05:30:00.000000000 +0530
@@ -1,2117 +0,0 @@
-/*
- ** Copyright 2007, The Android Open Source Project
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-#define ATRACE_TAG ATRACE_TAG_GRAPHICS
-
-#include <dlfcn.h>
-#include <ctype.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include <hardware/gralloc.h>
-#include <system/window.h>
-
-#include <EGL/egl.h>
-#include <EGL/eglext.h>
-
-#include <cutils/log.h>
-#include <cutils/atomic.h>
-#include <cutils/compiler.h>
-#include <cutils/properties.h>
-#include <cutils/memory.h>
-
-#include <gui/ISurfaceComposer.h>
-
-#include <ui/GraphicBuffer.h>
-
-#include <utils/KeyedVector.h>
-#include <utils/SortedVector.h>
-#include <utils/String8.h>
-#include <utils/Trace.h>
-
-#include "binder/Binder.h"
-#include "binder/Parcel.h"
-#include "binder/IServiceManager.h"
-
-#include "../egl_impl.h"
-#include "../hooks.h"
-
-#include "egl_display.h"
-#include "egl_object.h"
-#include "egl_tls.h"
-#include "egldefs.h"
-
-using namespace android;
-
-// This extension has not been ratified yet, so can't be shipped.
-// Implementation is incomplete and untested.
-#define ENABLE_EGL_KHR_GL_COLORSPACE 0
-
-#define ENABLE_EGL_ANDROID_GET_FRAME_TIMESTAMPS 0
-
-// ----------------------------------------------------------------------------
-
-namespace android {
-
-struct extention_map_t {
-    const char* name;
-    __eglMustCastToProperFunctionPointerType address;
-};
-
-/*
- * This is the list of EGL extensions exposed to applications.
- *
- * Some of them (gBuiltinExtensionString) are implemented entirely in this EGL
- * wrapper and are always available.
- *
- * The rest (gExtensionString) depend on support in the EGL driver, and are
- * only available if the driver supports them. However, some of these must be
- * supported because they are used by the Android system itself; these are
- * listed as mandatory below and are required by the CDD. The system *assumes*
- * the mandatory extensions are present and may not function properly if some
- * are missing.
- *
- * NOTE: Both strings MUST have a single space as the last character.
- */
-extern char const * const gBuiltinExtensionString =
-        "EGL_KHR_get_all_proc_addresses "
-        "EGL_ANDROID_presentation_time "
-        "EGL_KHR_swap_buffers_with_damage "
-        "EGL_ANDROID_create_native_client_buffer "
-        "EGL_ANDROID_front_buffer_auto_refresh "
-#if ENABLE_EGL_ANDROID_GET_FRAME_TIMESTAMPS
-        "EGL_ANDROID_get_frame_timestamps "
-#endif
-        ;
-extern char const * const gExtensionString  =
-        "EGL_KHR_image "                        // mandatory
-        "EGL_KHR_image_base "                   // mandatory
-        "EGL_KHR_image_pixmap "
-        "EGL_KHR_lock_surface "
-#if (ENABLE_EGL_KHR_GL_COLORSPACE != 0)
-        "EGL_KHR_gl_colorspace "
-#endif
-        "EGL_KHR_gl_texture_2D_image "
-        "EGL_KHR_gl_texture_3D_image "
-        "EGL_KHR_gl_texture_cubemap_image "
-        "EGL_KHR_gl_renderbuffer_image "
-        "EGL_KHR_reusable_sync "
-        "EGL_KHR_fence_sync "
-        "EGL_KHR_create_context "
-        "EGL_KHR_config_attribs "
-        "EGL_KHR_surfaceless_context "
-        "EGL_KHR_stream "
-        "EGL_KHR_stream_fifo "
-        "EGL_KHR_stream_producer_eglsurface "
-        "EGL_KHR_stream_consumer_gltexture "
-        "EGL_KHR_stream_cross_process_fd "
-        "EGL_EXT_create_context_robustness "
-        "EGL_NV_system_time "
-        "EGL_ANDROID_image_native_buffer "      // mandatory
-        "EGL_KHR_wait_sync "                    // strongly recommended
-        "EGL_ANDROID_recordable "               // mandatory
-        "EGL_KHR_partial_update "               // strongly recommended
-        "EGL_EXT_buffer_age "                   // strongly recommended with partial_update
-        "EGL_KHR_create_context_no_error "
-        "EGL_KHR_mutable_render_buffer "
-        "EGL_EXT_yuv_surface "
-        "EGL_EXT_protected_content "
-        ;
-
-// extensions not exposed to applications but used by the ANDROID system
-//      "EGL_ANDROID_blob_cache "               // strongly recommended
-//      "EGL_IMG_hibernate_process "            // optional
-//      "EGL_ANDROID_native_fence_sync "        // strongly recommended
-//      "EGL_ANDROID_framebuffer_target "       // mandatory for HWC 1.1
-//      "EGL_ANDROID_image_crop "               // optional
-
-/*
- * EGL Extensions entry-points exposed to 3rd party applications
- * (keep in sync with gExtensionString above)
- *
- */
-static const extention_map_t sExtensionMap[] = {
-    // EGL_KHR_lock_surface
-    { "eglLockSurfaceKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglLockSurfaceKHR },
-    { "eglUnlockSurfaceKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglUnlockSurfaceKHR },
-
-    // EGL_KHR_image, EGL_KHR_image_base
-    { "eglCreateImageKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglCreateImageKHR },
-    { "eglDestroyImageKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglDestroyImageKHR },
-
-    // EGL_KHR_reusable_sync, EGL_KHR_fence_sync
-    { "eglCreateSyncKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglCreateSyncKHR },
-    { "eglDestroySyncKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglDestroySyncKHR },
-    { "eglClientWaitSyncKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglClientWaitSyncKHR },
-    { "eglSignalSyncKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglSignalSyncKHR },
-    { "eglGetSyncAttribKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglGetSyncAttribKHR },
-
-    // EGL_NV_system_time
-    { "eglGetSystemTimeFrequencyNV",
-            (__eglMustCastToProperFunctionPointerType)&eglGetSystemTimeFrequencyNV },
-    { "eglGetSystemTimeNV",
-            (__eglMustCastToProperFunctionPointerType)&eglGetSystemTimeNV },
-
-    // EGL_KHR_wait_sync
-    { "eglWaitSyncKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglWaitSyncKHR },
-
-    // EGL_ANDROID_presentation_time
-    { "eglPresentationTimeANDROID",
-            (__eglMustCastToProperFunctionPointerType)&eglPresentationTimeANDROID },
-
-    // EGL_KHR_swap_buffers_with_damage
-    { "eglSwapBuffersWithDamageKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglSwapBuffersWithDamageKHR },
-
-    // EGL_ANDROID_native_client_buffer
-    { "eglCreateNativeClientBufferANDROID",
-            (__eglMustCastToProperFunctionPointerType)&eglCreateNativeClientBufferANDROID },
-
-    // EGL_KHR_partial_update
-    { "eglSetDamageRegionKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglSetDamageRegionKHR },
-
-    { "eglCreateStreamKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglCreateStreamKHR },
-    { "eglDestroyStreamKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglDestroyStreamKHR },
-    { "eglStreamAttribKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglStreamAttribKHR },
-    { "eglQueryStreamKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglQueryStreamKHR },
-    { "eglQueryStreamu64KHR",
-            (__eglMustCastToProperFunctionPointerType)&eglQueryStreamu64KHR },
-    { "eglQueryStreamTimeKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglQueryStreamTimeKHR },
-    { "eglCreateStreamProducerSurfaceKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglCreateStreamProducerSurfaceKHR },
-    { "eglStreamConsumerGLTextureExternalKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglStreamConsumerGLTextureExternalKHR },
-    { "eglStreamConsumerAcquireKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglStreamConsumerAcquireKHR },
-    { "eglStreamConsumerReleaseKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglStreamConsumerReleaseKHR },
-    { "eglGetStreamFileDescriptorKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglGetStreamFileDescriptorKHR },
-    { "eglCreateStreamFromFileDescriptorKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglCreateStreamFromFileDescriptorKHR },
-
-    // EGL_ANDROID_get_frame_timestamps
-    { "eglGetFrameTimestampsANDROID",
-            (__eglMustCastToProperFunctionPointerType)&eglGetFrameTimestampsANDROID },
-    { "eglQueryTimestampSupportedANDROID",
-            (__eglMustCastToProperFunctionPointerType)&eglQueryTimestampSupportedANDROID },
-};
-
-/*
- * These extensions entry-points should not be exposed to applications.
- * They're used internally by the Android EGL layer.
- */
-#define FILTER_EXTENSIONS(procname) \
-        (!strcmp((procname), "eglSetBlobCacheFuncsANDROID") ||    \
-         !strcmp((procname), "eglHibernateProcessIMG")      ||    \
-         !strcmp((procname), "eglAwakenProcessIMG")         ||    \
-         !strcmp((procname), "eglDupNativeFenceFDANDROID"))
-
-
-
-// accesses protected by sExtensionMapMutex
-static DefaultKeyedVector<String8, __eglMustCastToProperFunctionPointerType> sGLExtentionMap;
-static int sGLExtentionSlot = 0;
-static pthread_mutex_t sExtensionMapMutex = PTHREAD_MUTEX_INITIALIZER;
-
-static void(*findProcAddress(const char* name,
-        const extention_map_t* map, size_t n))() {
-    for (uint32_t i=0 ; i<n ; i++) {
-        if (!strcmp(name, map[i].name)) {
-            return map[i].address;
-        }
-    }
-    return NULL;
-}
-
-// ----------------------------------------------------------------------------
-
-extern void setGLHooksThreadSpecific(gl_hooks_t const *value);
-extern EGLBoolean egl_init_drivers();
-extern const __eglMustCastToProperFunctionPointerType gExtensionForwarders[MAX_NUMBER_OF_GL_EXTENSIONS];
-extern gl_hooks_t gHooksTrace;
-
-} // namespace android;
-
-
-// ----------------------------------------------------------------------------
-
-static inline void clearError() { egl_tls_t::clearError(); }
-static inline EGLContext getContext() { return egl_tls_t::getContext(); }
-
-// ----------------------------------------------------------------------------
-
-EGLDisplay eglGetDisplay(EGLNativeDisplayType display)
-{
-    ATRACE_CALL();
-    clearError();
-
-    uintptr_t index = reinterpret_cast<uintptr_t>(display);
-    if (index >= NUM_DISPLAYS) {
-        return setError(EGL_BAD_PARAMETER, EGL_NO_DISPLAY);
-    }
-
-    if (egl_init_drivers() == EGL_FALSE) {
-        return setError(EGL_BAD_PARAMETER, EGL_NO_DISPLAY);
-    }
-
-    EGLDisplay dpy = egl_display_t::getFromNativeDisplay(display);
-    return dpy;
-}
-
-// ----------------------------------------------------------------------------
-// Initialization
-// ----------------------------------------------------------------------------
-
-EGLBoolean eglInitialize(EGLDisplay dpy, EGLint *major, EGLint *minor)
-{
-    clearError();
-
-    egl_display_ptr dp = get_display(dpy);
-    if (!dp) return setError(EGL_BAD_DISPLAY, EGL_FALSE);
-
-    EGLBoolean res = dp->initialize(major, minor);
-
-    return res;
-}
-
-EGLBoolean eglTerminate(EGLDisplay dpy)
-{
-    // NOTE: don't unload the drivers b/c some APIs can be called
-    // after eglTerminate() has been called. eglTerminate() only
-    // terminates an EGLDisplay, not a EGL itself.
-
-    clearError();
-
-    egl_display_ptr dp = get_display(dpy);
-    if (!dp) return setError(EGL_BAD_DISPLAY, EGL_FALSE);
-
-    EGLBoolean res = dp->terminate();
-
-    return res;
-}
-
-// ----------------------------------------------------------------------------
-// configuration
-// ----------------------------------------------------------------------------
-
-EGLBoolean eglGetConfigs(   EGLDisplay dpy,
-                            EGLConfig *configs,
-                            EGLint config_size, EGLint *num_config)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    if (num_config==0) {
-        return setError(EGL_BAD_PARAMETER, EGL_FALSE);
-    }
-
-    EGLBoolean res = EGL_FALSE;
-    *num_config = 0;
-
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso) {
-        res = cnx->egl.eglGetConfigs(
-                dp->disp.dpy, configs, config_size, num_config);
-    }
-
-    return res;
-}
-
-EGLBoolean eglChooseConfig( EGLDisplay dpy, const EGLint *attrib_list,
-                            EGLConfig *configs, EGLint config_size,
-                            EGLint *num_config)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    if (num_config==0) {
-        return setError(EGL_BAD_PARAMETER, EGL_FALSE);
-    }
-
-    EGLBoolean res = EGL_FALSE;
-    *num_config = 0;
-
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso) {
-        if (attrib_list) {
-            char value[PROPERTY_VALUE_MAX];
-            property_get("debug.egl.force_msaa", value, "false");
-
-            if (!strcmp(value, "true")) {
-                size_t attribCount = 0;
-                EGLint attrib = attrib_list[0];
-
-                // Only enable MSAA if the context is OpenGL ES 2.0 and
-                // if no caveat is requested
-                const EGLint *attribRendererable = NULL;
-                const EGLint *attribCaveat = NULL;
-
-                // Count the number of attributes and look for
-                // EGL_RENDERABLE_TYPE and EGL_CONFIG_CAVEAT
-                while (attrib != EGL_NONE) {
-                    attrib = attrib_list[attribCount];
-                    switch (attrib) {
-                        case EGL_RENDERABLE_TYPE:
-                            attribRendererable = &attrib_list[attribCount];
-                            break;
-                        case EGL_CONFIG_CAVEAT:
-                            attribCaveat = &attrib_list[attribCount];
-                            break;
-                    }
-                    attribCount++;
-                }
-
-                if (attribRendererable && attribRendererable[1] == EGL_OPENGL_ES2_BIT &&
-                        (!attribCaveat || attribCaveat[1] != EGL_NONE)) {
-
-                    // Insert 2 extra attributes to force-enable MSAA 4x
-                    EGLint aaAttribs[attribCount + 4];
-                    aaAttribs[0] = EGL_SAMPLE_BUFFERS;
-                    aaAttribs[1] = 1;
-                    aaAttribs[2] = EGL_SAMPLES;
-                    aaAttribs[3] = 4;
-
-                    memcpy(&aaAttribs[4], attrib_list, attribCount * sizeof(EGLint));
-
-                    EGLint numConfigAA;
-                    EGLBoolean resAA = cnx->egl.eglChooseConfig(
-                            dp->disp.dpy, aaAttribs, configs, config_size, &numConfigAA);
-
-                    if (resAA == EGL_TRUE && numConfigAA > 0) {
-                        ALOGD("Enabling MSAA 4x");
-                        *num_config = numConfigAA;
-                        return resAA;
-                    }
-                }
-            }
-        }
-
-        res = cnx->egl.eglChooseConfig(
-                dp->disp.dpy, attrib_list, configs, config_size, num_config);
-    }
-    return res;
-}
-
-EGLBoolean eglGetConfigAttrib(EGLDisplay dpy, EGLConfig config,
-        EGLint attribute, EGLint *value)
-{
-    clearError();
-
-    egl_connection_t* cnx = NULL;
-    const egl_display_ptr dp = validate_display_connection(dpy, cnx);
-    if (!dp) return EGL_FALSE;
-
-    return cnx->egl.eglGetConfigAttrib(
-            dp->disp.dpy, config, attribute, value);
-}
-
-// ----------------------------------------------------------------------------
-// surfaces
-// ----------------------------------------------------------------------------
-
-// The EGL_KHR_gl_colorspace spec hasn't been ratified yet, so these haven't
-// been added to the Khronos egl.h.
-#define EGL_GL_COLORSPACE_KHR           EGL_VG_COLORSPACE
-#define EGL_GL_COLORSPACE_SRGB_KHR      EGL_VG_COLORSPACE_sRGB
-#define EGL_GL_COLORSPACE_LINEAR_KHR    EGL_VG_COLORSPACE_LINEAR
-
-// Turn linear formats into corresponding sRGB formats when colorspace is
-// EGL_GL_COLORSPACE_SRGB_KHR, or turn sRGB formats into corresponding linear
-// formats when colorspace is EGL_GL_COLORSPACE_LINEAR_KHR. In any cases where
-// the modification isn't possible, the original dataSpace is returned.
-static android_dataspace modifyBufferDataspace( android_dataspace dataSpace,
-                                                EGLint colorspace) {
-    if (colorspace == EGL_GL_COLORSPACE_LINEAR_KHR) {
-        return HAL_DATASPACE_SRGB_LINEAR;
-    } else if (colorspace == EGL_GL_COLORSPACE_SRGB_KHR) {
-        return HAL_DATASPACE_SRGB;
-    }
-    return dataSpace;
-}
-
-EGLSurface eglCreateWindowSurface(  EGLDisplay dpy, EGLConfig config,
-                                    NativeWindowType window,
-                                    const EGLint *attrib_list)
-{
-    clearError();
-
-    egl_connection_t* cnx = NULL;
-    egl_display_ptr dp = validate_display_connection(dpy, cnx);
-    if (dp) {
-        EGLDisplay iDpy = dp->disp.dpy;
-
-        int result = native_window_api_connect(window, NATIVE_WINDOW_API_EGL);
-        if (result != OK) {
-            ALOGE("eglCreateWindowSurface: native_window_api_connect (win=%p) "
-                    "failed (%#x) (already connected to another API?)",
-                    window, result);
-            return setError(EGL_BAD_ALLOC, EGL_NO_SURFACE);
-        }
-
-        // Set the native window's buffers format to match what this config requests.
-        // Whether to use sRGB gamma is not part of the EGLconfig, but is part
-        // of our native format. So if sRGB gamma is requested, we have to
-        // modify the EGLconfig's format before setting the native window's
-        // format.
-
-        // by default, just pick RGBA_8888
-        EGLint format = HAL_PIXEL_FORMAT_RGBA_8888;
-        android_dataspace dataSpace = HAL_DATASPACE_UNKNOWN;
-
-        EGLint a = 0;
-        cnx->egl.eglGetConfigAttrib(iDpy, config, EGL_ALPHA_SIZE, &a);
-        if (a > 0) {
-            // alpha-channel requested, there's really only one suitable format
-            format = HAL_PIXEL_FORMAT_RGBA_8888;
-        } else {
-            EGLint r, g, b;
-            r = g = b = 0;
-            cnx->egl.eglGetConfigAttrib(iDpy, config, EGL_RED_SIZE,   &r);
-            cnx->egl.eglGetConfigAttrib(iDpy, config, EGL_GREEN_SIZE, &g);
-            cnx->egl.eglGetConfigAttrib(iDpy, config, EGL_BLUE_SIZE,  &b);
-            EGLint colorDepth = r + g + b;
-            if (colorDepth <= 16) {
-                format = HAL_PIXEL_FORMAT_RGB_565;
-            } else {
-                format = HAL_PIXEL_FORMAT_RGBX_8888;
-            }
-        }
-
-        // now select a corresponding sRGB format if needed
-        if (attrib_list && dp->haveExtension("EGL_KHR_gl_colorspace")) {
-            for (const EGLint* attr = attrib_list; *attr != EGL_NONE; attr += 2) {
-                if (*attr == EGL_GL_COLORSPACE_KHR) {
-                    if (ENABLE_EGL_KHR_GL_COLORSPACE) {
-                        dataSpace = modifyBufferDataspace(dataSpace, *(attr+1));
-                    } else {
-                        // Normally we'd pass through unhandled attributes to
-                        // the driver. But in case the driver implements this
-                        // extension but we're disabling it, we want to prevent
-                        // it getting through -- support will be broken without
-                        // our help.
-                        ALOGE("sRGB window surfaces not supported");
-                        return setError(EGL_BAD_ATTRIBUTE, EGL_NO_SURFACE);
-                    }
-                }
-            }
-        }
-
-        if (format != 0) {
-            int err = native_window_set_buffers_format(window, format);
-            if (err != 0) {
-                ALOGE("error setting native window pixel format: %s (%d)",
-                        strerror(-err), err);
-                native_window_api_disconnect(window, NATIVE_WINDOW_API_EGL);
-                return setError(EGL_BAD_NATIVE_WINDOW, EGL_NO_SURFACE);
-            }
-        }
-
-        if (dataSpace != 0) {
-            int err = native_window_set_buffers_data_space(window, dataSpace);
-            if (err != 0) {
-                ALOGE("error setting native window pixel dataSpace: %s (%d)",
-                        strerror(-err), err);
-                native_window_api_disconnect(window, NATIVE_WINDOW_API_EGL);
-                return setError(EGL_BAD_NATIVE_WINDOW, EGL_NO_SURFACE);
-            }
-        }
-
-        // the EGL spec requires that a new EGLSurface default to swap interval
-        // 1, so explicitly set that on the window here.
-        ANativeWindow* anw = reinterpret_cast<ANativeWindow*>(window);
-        anw->setSwapInterval(anw, 1);
-
-        EGLSurface surface = cnx->egl.eglCreateWindowSurface(
-                iDpy, config, window, attrib_list);
-        if (surface != EGL_NO_SURFACE) {
-            egl_surface_t* s = new egl_surface_t(dp.get(), config, window,
-                    surface, cnx);
-            return s;
-        }
-
-        // EGLSurface creation failed
-        native_window_set_buffers_format(window, 0);
-        native_window_api_disconnect(window, NATIVE_WINDOW_API_EGL);
-    }
-    return EGL_NO_SURFACE;
-}
-
-EGLSurface eglCreatePixmapSurface(  EGLDisplay dpy, EGLConfig config,
-                                    NativePixmapType pixmap,
-                                    const EGLint *attrib_list)
-{
-    clearError();
-
-    egl_connection_t* cnx = NULL;
-    egl_display_ptr dp = validate_display_connection(dpy, cnx);
-    if (dp) {
-        EGLSurface surface = cnx->egl.eglCreatePixmapSurface(
-                dp->disp.dpy, config, pixmap, attrib_list);
-        if (surface != EGL_NO_SURFACE) {
-            egl_surface_t* s = new egl_surface_t(dp.get(), config, NULL,
-                    surface, cnx);
-            return s;
-        }
-    }
-    return EGL_NO_SURFACE;
-}
-
-EGLSurface eglCreatePbufferSurface( EGLDisplay dpy, EGLConfig config,
-                                    const EGLint *attrib_list)
-{
-    clearError();
-
-    egl_connection_t* cnx = NULL;
-    egl_display_ptr dp = validate_display_connection(dpy, cnx);
-    if (dp) {
-        EGLSurface surface = cnx->egl.eglCreatePbufferSurface(
-                dp->disp.dpy, config, attrib_list);
-        if (surface != EGL_NO_SURFACE) {
-            egl_surface_t* s = new egl_surface_t(dp.get(), config, NULL,
-                    surface, cnx);
-            return s;
-        }
-    }
-    return EGL_NO_SURFACE;
-}
-
-EGLBoolean eglDestroySurface(EGLDisplay dpy, EGLSurface surface)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    SurfaceRef _s(dp.get(), surface);
-    if (!_s.get())
-        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-
-    egl_surface_t * const s = get_surface(surface);
-    EGLBoolean result = s->cnx->egl.eglDestroySurface(dp->disp.dpy, s->surface);
-    if (result == EGL_TRUE) {
-        _s.terminate();
-    }
-    return result;
-}
-
-EGLBoolean eglQuerySurface( EGLDisplay dpy, EGLSurface surface,
-                            EGLint attribute, EGLint *value)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    SurfaceRef _s(dp.get(), surface);
-    if (!_s.get())
-        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-
-    egl_surface_t const * const s = get_surface(surface);
-    return s->cnx->egl.eglQuerySurface(
-            dp->disp.dpy, s->surface, attribute, value);
-}
-
-void EGLAPI eglBeginFrame(EGLDisplay dpy, EGLSurface surface) {
-    ATRACE_CALL();
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) {
-        return;
-    }
-
-    SurfaceRef _s(dp.get(), surface);
-    if (!_s.get()) {
-        setError(EGL_BAD_SURFACE, EGL_FALSE);
-        return;
-    }
-}
-
-// ----------------------------------------------------------------------------
-// Contexts
-// ----------------------------------------------------------------------------
-
-EGLContext eglCreateContext(EGLDisplay dpy, EGLConfig config,
-                            EGLContext share_list, const EGLint *attrib_list)
-{
-    clearError();
-
-    egl_connection_t* cnx = NULL;
-    const egl_display_ptr dp = validate_display_connection(dpy, cnx);
-    if (dp) {
-        if (share_list != EGL_NO_CONTEXT) {
-            if (!ContextRef(dp.get(), share_list).get()) {
-                return setError(EGL_BAD_CONTEXT, EGL_NO_CONTEXT);
-            }
-            egl_context_t* const c = get_context(share_list);
-            share_list = c->context;
-        }
-        EGLContext context = cnx->egl.eglCreateContext(
-                dp->disp.dpy, config, share_list, attrib_list);
-        if (context != EGL_NO_CONTEXT) {
-            // figure out if it's a GLESv1 or GLESv2
-            int version = 0;
-            if (attrib_list) {
-                while (*attrib_list != EGL_NONE) {
-                    GLint attr = *attrib_list++;
-                    GLint value = *attrib_list++;
-                    if (attr == EGL_CONTEXT_CLIENT_VERSION) {
-                        if (value == 1) {
-                            version = egl_connection_t::GLESv1_INDEX;
-                        } else if (value == 2 || value == 3) {
-                            version = egl_connection_t::GLESv2_INDEX;
-                        }
-                    }
-                };
-            }
-            egl_context_t* c = new egl_context_t(dpy, context, config, cnx,
-                    version);
-            return c;
-        }
-    }
-    return EGL_NO_CONTEXT;
-}
-
-EGLBoolean eglDestroyContext(EGLDisplay dpy, EGLContext ctx)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp)
-        return EGL_FALSE;
-
-    ContextRef _c(dp.get(), ctx);
-    if (!_c.get())
-        return setError(EGL_BAD_CONTEXT, EGL_FALSE);
-
-    egl_context_t * const c = get_context(ctx);
-    EGLBoolean result = c->cnx->egl.eglDestroyContext(dp->disp.dpy, c->context);
-    if (result == EGL_TRUE) {
-        _c.terminate();
-    }
-    return result;
-}
-
-EGLBoolean eglMakeCurrent(  EGLDisplay dpy, EGLSurface draw,
-                            EGLSurface read, EGLContext ctx)
-{
-    clearError();
-
-    egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return setError(EGL_BAD_DISPLAY, EGL_FALSE);
-
-    // If ctx is not EGL_NO_CONTEXT, read is not EGL_NO_SURFACE, or draw is not
-    // EGL_NO_SURFACE, then an EGL_NOT_INITIALIZED error is generated if dpy is
-    // a valid but uninitialized display.
-    if ( (ctx != EGL_NO_CONTEXT) || (read != EGL_NO_SURFACE) ||
-         (draw != EGL_NO_SURFACE) ) {
-        if (!dp->isReady()) return setError(EGL_NOT_INITIALIZED, EGL_FALSE);
-    }
-
-    // get a reference to the object passed in
-    ContextRef _c(dp.get(), ctx);
-    SurfaceRef _d(dp.get(), draw);
-    SurfaceRef _r(dp.get(), read);
-
-    // validate the context (if not EGL_NO_CONTEXT)
-    if ((ctx != EGL_NO_CONTEXT) && !_c.get()) {
-        // EGL_NO_CONTEXT is valid
-        return setError(EGL_BAD_CONTEXT, EGL_FALSE);
-    }
-
-    // these are the underlying implementation's object
-    EGLContext impl_ctx  = EGL_NO_CONTEXT;
-    EGLSurface impl_draw = EGL_NO_SURFACE;
-    EGLSurface impl_read = EGL_NO_SURFACE;
-
-    // these are our objects structs passed in
-    egl_context_t       * c = NULL;
-    egl_surface_t const * d = NULL;
-    egl_surface_t const * r = NULL;
-
-    // these are the current objects structs
-    egl_context_t * cur_c = get_context(getContext());
-
-    if (ctx != EGL_NO_CONTEXT) {
-        c = get_context(ctx);
-        impl_ctx = c->context;
-    } else {
-        // no context given, use the implementation of the current context
-        if (draw != EGL_NO_SURFACE || read != EGL_NO_SURFACE) {
-            // calling eglMakeCurrent( ..., !=0, !=0, EGL_NO_CONTEXT);
-            return setError(EGL_BAD_MATCH, EGL_FALSE);
-        }
-        if (cur_c == NULL) {
-            // no current context
-            // not an error, there is just no current context.
-            return EGL_TRUE;
-        }
-    }
-
-    // retrieve the underlying implementation's draw EGLSurface
-    if (draw != EGL_NO_SURFACE) {
-        if (!_d.get()) return setError(EGL_BAD_SURFACE, EGL_FALSE);
-        d = get_surface(draw);
-        impl_draw = d->surface;
-    }
-
-    // retrieve the underlying implementation's read EGLSurface
-    if (read != EGL_NO_SURFACE) {
-        if (!_r.get()) return setError(EGL_BAD_SURFACE, EGL_FALSE);
-        r = get_surface(read);
-        impl_read = r->surface;
-    }
-
-
-    EGLBoolean result = dp->makeCurrent(c, cur_c,
-            draw, read, ctx,
-            impl_draw, impl_read, impl_ctx);
-
-    if (result == EGL_TRUE) {
-        if (c) {
-            setGLHooksThreadSpecific(c->cnx->hooks[c->version]);
-            egl_tls_t::setContext(ctx);
-            _c.acquire();
-            _r.acquire();
-            _d.acquire();
-        } else {
-            setGLHooksThreadSpecific(&gHooksNoContext);
-            egl_tls_t::setContext(EGL_NO_CONTEXT);
-        }
-    } else {
-        // this will ALOGE the error
-        egl_connection_t* const cnx = &gEGLImpl;
-        result = setError(cnx->egl.eglGetError(), EGL_FALSE);
-    }
-    return result;
-}
-
-
-EGLBoolean eglQueryContext( EGLDisplay dpy, EGLContext ctx,
-                            EGLint attribute, EGLint *value)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    ContextRef _c(dp.get(), ctx);
-    if (!_c.get()) return setError(EGL_BAD_CONTEXT, EGL_FALSE);
-
-    egl_context_t * const c = get_context(ctx);
-    return c->cnx->egl.eglQueryContext(
-            dp->disp.dpy, c->context, attribute, value);
-
-}
-
-EGLContext eglGetCurrentContext(void)
-{
-    // could be called before eglInitialize(), but we wouldn't have a context
-    // then, and this function would correctly return EGL_NO_CONTEXT.
-
-    clearError();
-
-    EGLContext ctx = getContext();
-    return ctx;
-}
-
-EGLSurface eglGetCurrentSurface(EGLint readdraw)
-{
-    // could be called before eglInitialize(), but we wouldn't have a context
-    // then, and this function would correctly return EGL_NO_SURFACE.
-
-    clearError();
-
-    EGLContext ctx = getContext();
-    if (ctx) {
-        egl_context_t const * const c = get_context(ctx);
-        if (!c) return setError(EGL_BAD_CONTEXT, EGL_NO_SURFACE);
-        switch (readdraw) {
-            case EGL_READ: return c->read;
-            case EGL_DRAW: return c->draw;
-            default: return setError(EGL_BAD_PARAMETER, EGL_NO_SURFACE);
-        }
-    }
-    return EGL_NO_SURFACE;
-}
-
-EGLDisplay eglGetCurrentDisplay(void)
-{
-    // could be called before eglInitialize(), but we wouldn't have a context
-    // then, and this function would correctly return EGL_NO_DISPLAY.
-
-    clearError();
-
-    EGLContext ctx = getContext();
-    if (ctx) {
-        egl_context_t const * const c = get_context(ctx);
-        if (!c) return setError(EGL_BAD_CONTEXT, EGL_NO_SURFACE);
-        return c->dpy;
-    }
-    return EGL_NO_DISPLAY;
-}
-
-EGLBoolean eglWaitGL(void)
-{
-    clearError();
-
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (!cnx->dso)
-        return setError(EGL_BAD_CONTEXT, EGL_FALSE);
-
-    return cnx->egl.eglWaitGL();
-}
-
-EGLBoolean eglWaitNative(EGLint engine)
-{
-    clearError();
-
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (!cnx->dso)
-        return setError(EGL_BAD_CONTEXT, EGL_FALSE);
-
-    return cnx->egl.eglWaitNative(engine);
-}
-
-EGLint eglGetError(void)
-{
-    EGLint err = EGL_SUCCESS;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso) {
-        err = cnx->egl.eglGetError();
-    }
-    if (err == EGL_SUCCESS) {
-        err = egl_tls_t::getError();
-    }
-    return err;
-}
-
-static __eglMustCastToProperFunctionPointerType findBuiltinWrapper(
-        const char* procname) {
-    const egl_connection_t* cnx = &gEGLImpl;
-    void* proc = NULL;
-
-    proc = dlsym(cnx->libEgl, procname);
-    if (proc) return (__eglMustCastToProperFunctionPointerType)proc;
-
-    proc = dlsym(cnx->libGles2, procname);
-    if (proc) return (__eglMustCastToProperFunctionPointerType)proc;
-
-    proc = dlsym(cnx->libGles1, procname);
-    if (proc) return (__eglMustCastToProperFunctionPointerType)proc;
-
-    return NULL;
-}
-
-__eglMustCastToProperFunctionPointerType eglGetProcAddress(const char *procname)
-{
-    // eglGetProcAddress() could be the very first function called
-    // in which case we must make sure we've initialized ourselves, this
-    // happens the first time egl_get_display() is called.
-
-    clearError();
-
-    if (egl_init_drivers() == EGL_FALSE) {
-        setError(EGL_BAD_PARAMETER, NULL);
-        return  NULL;
-    }
-
-    if (FILTER_EXTENSIONS(procname)) {
-        return NULL;
-    }
-
-    __eglMustCastToProperFunctionPointerType addr;
-    addr = findProcAddress(procname, sExtensionMap, NELEM(sExtensionMap));
-    if (addr) return addr;
-
-    addr = findBuiltinWrapper(procname);
-    if (addr) return addr;
-
-    // this protects accesses to sGLExtentionMap and sGLExtentionSlot
-    pthread_mutex_lock(&sExtensionMapMutex);
-
-        /*
-         * Since eglGetProcAddress() is not associated to anything, it needs
-         * to return a function pointer that "works" regardless of what
-         * the current context is.
-         *
-         * For this reason, we return a "forwarder", a small stub that takes
-         * care of calling the function associated with the context
-         * currently bound.
-         *
-         * We first look for extensions we've already resolved, if we're seeing
-         * this extension for the first time, we go through all our
-         * implementations and call eglGetProcAddress() and record the
-         * result in the appropriate implementation hooks and return the
-         * address of the forwarder corresponding to that hook set.
-         *
-         */
-
-        const String8 name(procname);
-        addr = sGLExtentionMap.valueFor(name);
-        const int slot = sGLExtentionSlot;
-
-        ALOGE_IF(slot >= MAX_NUMBER_OF_GL_EXTENSIONS,
-                "no more slots for eglGetProcAddress(\"%s\")",
-                procname);
-
-        if (!addr && (slot < MAX_NUMBER_OF_GL_EXTENSIONS)) {
-            bool found = false;
-
-            egl_connection_t* const cnx = &gEGLImpl;
-            if (cnx->dso && cnx->egl.eglGetProcAddress) {
-                // Extensions are independent of the bound context
-                addr =
-                cnx->hooks[egl_connection_t::GLESv1_INDEX]->ext.extensions[slot] =
-                cnx->hooks[egl_connection_t::GLESv2_INDEX]->ext.extensions[slot] =
-                        cnx->egl.eglGetProcAddress(procname);
-                if (addr) found = true;
-            }
-
-            if (found) {
-                addr = gExtensionForwarders[slot];
-                sGLExtentionMap.add(name, addr);
-                sGLExtentionSlot++;
-            }
-        }
-
-    pthread_mutex_unlock(&sExtensionMapMutex);
-    return addr;
-}
-
-class FrameCompletionThread : public Thread {
-public:
-
-    static void queueSync(EGLSyncKHR sync) {
-        static sp<FrameCompletionThread> thread(new FrameCompletionThread);
-        static bool running = false;
-        if (!running) {
-            thread->run("GPUFrameCompletion");
-            running = true;
-        }
-        {
-            Mutex::Autolock lock(thread->mMutex);
-            ScopedTrace st(ATRACE_TAG, String8::format("kicked off frame %d",
-                    thread->mFramesQueued).string());
-            thread->mQueue.push_back(sync);
-            thread->mCondition.signal();
-            thread->mFramesQueued++;
-            ATRACE_INT("GPU Frames Outstanding", thread->mQueue.size());
-        }
-    }
-
-private:
-    FrameCompletionThread() : mFramesQueued(0), mFramesCompleted(0) {}
-
-    virtual bool threadLoop() {
-        EGLSyncKHR sync;
-        uint32_t frameNum;
-        {
-            Mutex::Autolock lock(mMutex);
-            while (mQueue.isEmpty()) {
-                mCondition.wait(mMutex);
-            }
-            sync = mQueue[0];
-            frameNum = mFramesCompleted;
-        }
-        EGLDisplay dpy = eglGetDisplay(EGL_DEFAULT_DISPLAY);
-        {
-            ScopedTrace st(ATRACE_TAG, String8::format("waiting for frame %d",
-                    frameNum).string());
-            EGLint result = eglClientWaitSyncKHR(dpy, sync, 0, EGL_FOREVER_KHR);
-            if (result == EGL_FALSE) {
-                ALOGE("FrameCompletion: error waiting for fence: %#x", eglGetError());
-            } else if (result == EGL_TIMEOUT_EXPIRED_KHR) {
-                ALOGE("FrameCompletion: timeout waiting for fence");
-            }
-            eglDestroySyncKHR(dpy, sync);
-        }
-        {
-            Mutex::Autolock lock(mMutex);
-            mQueue.removeAt(0);
-            mFramesCompleted++;
-            ATRACE_INT("GPU Frames Outstanding", mQueue.size());
-        }
-        return true;
-    }
-
-    uint32_t mFramesQueued;
-    uint32_t mFramesCompleted;
-    Vector<EGLSyncKHR> mQueue;
-    Condition mCondition;
-    Mutex mMutex;
-};
-
-EGLBoolean eglSwapBuffersWithDamageKHR(EGLDisplay dpy, EGLSurface draw,
-        EGLint *rects, EGLint n_rects)
-{
-    ATRACE_CALL();
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    SurfaceRef _s(dp.get(), draw);
-    if (!_s.get())
-        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-
-    egl_surface_t const * const s = get_surface(draw);
-
-    if (CC_UNLIKELY(dp->traceGpuCompletion)) {
-        EGLSyncKHR sync = eglCreateSyncKHR(dpy, EGL_SYNC_FENCE_KHR, NULL);
-        if (sync != EGL_NO_SYNC_KHR) {
-            FrameCompletionThread::queueSync(sync);
-        }
-    }
-
-    if (CC_UNLIKELY(dp->finishOnSwap)) {
-        uint32_t pixel;
-        egl_context_t * const c = get_context( egl_tls_t::getContext() );
-        if (c) {
-            // glReadPixels() ensures that the frame is complete
-            s->cnx->hooks[c->version]->gl.glReadPixels(0,0,1,1,
-                    GL_RGBA,GL_UNSIGNED_BYTE,&pixel);
-        }
-    }
-
-    if (n_rects == 0) {
-        return s->cnx->egl.eglSwapBuffers(dp->disp.dpy, s->surface);
-    }
-
-    Vector<android_native_rect_t> androidRects;
-    for (int r = 0; r < n_rects; ++r) {
-        int offset = r * 4;
-        int x = rects[offset];
-        int y = rects[offset + 1];
-        int width = rects[offset + 2];
-        int height = rects[offset + 3];
-        android_native_rect_t androidRect;
-        androidRect.left = x;
-        androidRect.top = y + height;
-        androidRect.right = x + width;
-        androidRect.bottom = y;
-        androidRects.push_back(androidRect);
-    }
-    native_window_set_surface_damage(s->win.get(), androidRects.array(),
-            androidRects.size());
-
-    if (s->cnx->egl.eglSwapBuffersWithDamageKHR) {
-        return s->cnx->egl.eglSwapBuffersWithDamageKHR(dp->disp.dpy, s->surface,
-                rects, n_rects);
-    } else {
-        return s->cnx->egl.eglSwapBuffers(dp->disp.dpy, s->surface);
-    }
-}
-
-EGLBoolean eglSwapBuffers(EGLDisplay dpy, EGLSurface surface)
-{
-    return eglSwapBuffersWithDamageKHR(dpy, surface, NULL, 0);
-}
-
-EGLBoolean eglCopyBuffers(  EGLDisplay dpy, EGLSurface surface,
-                            NativePixmapType target)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    SurfaceRef _s(dp.get(), surface);
-    if (!_s.get())
-        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-
-    egl_surface_t const * const s = get_surface(surface);
-    return s->cnx->egl.eglCopyBuffers(dp->disp.dpy, s->surface, target);
-}
-
-const char* eglQueryString(EGLDisplay dpy, EGLint name)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return (const char *) NULL;
-
-    switch (name) {
-        case EGL_VENDOR:
-            return dp->getVendorString();
-        case EGL_VERSION:
-            return dp->getVersionString();
-        case EGL_EXTENSIONS:
-            return dp->getExtensionString();
-        case EGL_CLIENT_APIS:
-            return dp->getClientApiString();
-    }
-    return setError(EGL_BAD_PARAMETER, (const char *)0);
-}
-
-EGLAPI const char* eglQueryStringImplementationANDROID(EGLDisplay dpy, EGLint name)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return (const char *) NULL;
-
-    switch (name) {
-        case EGL_VENDOR:
-            return dp->disp.queryString.vendor;
-        case EGL_VERSION:
-            return dp->disp.queryString.version;
-        case EGL_EXTENSIONS:
-            return dp->disp.queryString.extensions;
-        case EGL_CLIENT_APIS:
-            return dp->disp.queryString.clientApi;
-    }
-    return setError(EGL_BAD_PARAMETER, (const char *)0);
-}
-
-// ----------------------------------------------------------------------------
-// EGL 1.1
-// ----------------------------------------------------------------------------
-
-EGLBoolean eglSurfaceAttrib(
-        EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint value)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    SurfaceRef _s(dp.get(), surface);
-    if (!_s.get())
-        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-
-    egl_surface_t * const s = get_surface(surface);
-
-    if (attribute == EGL_FRONT_BUFFER_AUTO_REFRESH_ANDROID) {
-        int err = native_window_set_auto_refresh(s->win.get(),
-            value ? true : false);
-        return (err == NO_ERROR) ? EGL_TRUE :
-            setError(EGL_BAD_SURFACE, EGL_FALSE);
-    }
-
-#if ENABLE_EGL_ANDROID_GET_FRAME_TIMESTAMPS
-    if (attribute == EGL_TIMESTAMPS_ANDROID) {
-        s->enableTimestamps = value;
-        return EGL_TRUE;
-    }
-#endif
-
-    if (s->cnx->egl.eglSurfaceAttrib) {
-        return s->cnx->egl.eglSurfaceAttrib(
-                dp->disp.dpy, s->surface, attribute, value);
-    }
-    return setError(EGL_BAD_SURFACE, EGL_FALSE);
-}
-
-EGLBoolean eglBindTexImage(
-        EGLDisplay dpy, EGLSurface surface, EGLint buffer)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    SurfaceRef _s(dp.get(), surface);
-    if (!_s.get())
-        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-
-    egl_surface_t const * const s = get_surface(surface);
-    if (s->cnx->egl.eglBindTexImage) {
-        return s->cnx->egl.eglBindTexImage(
-                dp->disp.dpy, s->surface, buffer);
-    }
-    return setError(EGL_BAD_SURFACE, EGL_FALSE);
-}
-
-EGLBoolean eglReleaseTexImage(
-        EGLDisplay dpy, EGLSurface surface, EGLint buffer)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    SurfaceRef _s(dp.get(), surface);
-    if (!_s.get())
-        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-
-    egl_surface_t const * const s = get_surface(surface);
-    if (s->cnx->egl.eglReleaseTexImage) {
-        return s->cnx->egl.eglReleaseTexImage(
-                dp->disp.dpy, s->surface, buffer);
-    }
-    return setError(EGL_BAD_SURFACE, EGL_FALSE);
-}
-
-EGLBoolean eglSwapInterval(EGLDisplay dpy, EGLint interval)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    EGLBoolean res = EGL_TRUE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglSwapInterval) {
-        res = cnx->egl.eglSwapInterval(dp->disp.dpy, interval);
-    }
-
-    return res;
-}
-
-
-// ----------------------------------------------------------------------------
-// EGL 1.2
-// ----------------------------------------------------------------------------
-
-EGLBoolean eglWaitClient(void)
-{
-    clearError();
-
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (!cnx->dso)
-        return setError(EGL_BAD_CONTEXT, EGL_FALSE);
-
-    EGLBoolean res;
-    if (cnx->egl.eglWaitClient) {
-        res = cnx->egl.eglWaitClient();
-    } else {
-        res = cnx->egl.eglWaitGL();
-    }
-    return res;
-}
-
-EGLBoolean eglBindAPI(EGLenum api)
-{
-    clearError();
-
-    if (egl_init_drivers() == EGL_FALSE) {
-        return setError(EGL_BAD_PARAMETER, EGL_FALSE);
-    }
-
-    // bind this API on all EGLs
-    EGLBoolean res = EGL_TRUE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglBindAPI) {
-        res = cnx->egl.eglBindAPI(api);
-    }
-    return res;
-}
-
-EGLenum eglQueryAPI(void)
-{
-    clearError();
-
-    if (egl_init_drivers() == EGL_FALSE) {
-        return setError(EGL_BAD_PARAMETER, EGL_FALSE);
-    }
-
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglQueryAPI) {
-        return cnx->egl.eglQueryAPI();
-    }
-
-    // or, it can only be OpenGL ES
-    return EGL_OPENGL_ES_API;
-}
-
-EGLBoolean eglReleaseThread(void)
-{
-    clearError();
-
-    // If there is context bound to the thread, release it
-    egl_display_t::loseCurrent(get_context(getContext()));
-
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglReleaseThread) {
-        cnx->egl.eglReleaseThread();
-    }
-    egl_tls_t::clearTLS();
-    return EGL_TRUE;
-}
-
-EGLSurface eglCreatePbufferFromClientBuffer(
-          EGLDisplay dpy, EGLenum buftype, EGLClientBuffer buffer,
-          EGLConfig config, const EGLint *attrib_list)
-{
-    clearError();
-
-    egl_connection_t* cnx = NULL;
-    const egl_display_ptr dp = validate_display_connection(dpy, cnx);
-    if (!dp) return EGL_FALSE;
-    if (cnx->egl.eglCreatePbufferFromClientBuffer) {
-        return cnx->egl.eglCreatePbufferFromClientBuffer(
-                dp->disp.dpy, buftype, buffer, config, attrib_list);
-    }
-    return setError(EGL_BAD_CONFIG, EGL_NO_SURFACE);
-}
-
-// ----------------------------------------------------------------------------
-// EGL_EGLEXT_VERSION 3
-// ----------------------------------------------------------------------------
-
-EGLBoolean eglLockSurfaceKHR(EGLDisplay dpy, EGLSurface surface,
-        const EGLint *attrib_list)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    SurfaceRef _s(dp.get(), surface);
-    if (!_s.get())
-        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-
-    egl_surface_t const * const s = get_surface(surface);
-    if (s->cnx->egl.eglLockSurfaceKHR) {
-        return s->cnx->egl.eglLockSurfaceKHR(
-                dp->disp.dpy, s->surface, attrib_list);
-    }
-    return setError(EGL_BAD_DISPLAY, EGL_FALSE);
-}
-
-EGLBoolean eglUnlockSurfaceKHR(EGLDisplay dpy, EGLSurface surface)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    SurfaceRef _s(dp.get(), surface);
-    if (!_s.get())
-        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-
-    egl_surface_t const * const s = get_surface(surface);
-    if (s->cnx->egl.eglUnlockSurfaceKHR) {
-        return s->cnx->egl.eglUnlockSurfaceKHR(dp->disp.dpy, s->surface);
-    }
-    return setError(EGL_BAD_DISPLAY, EGL_FALSE);
-}
-
-EGLImageKHR eglCreateImageKHR(EGLDisplay dpy, EGLContext ctx, EGLenum target,
-        EGLClientBuffer buffer, const EGLint *attrib_list)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_NO_IMAGE_KHR;
-
-    ContextRef _c(dp.get(), ctx);
-    egl_context_t * const c = _c.get();
-
-    EGLImageKHR result = EGL_NO_IMAGE_KHR;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglCreateImageKHR) {
-        result = cnx->egl.eglCreateImageKHR(
-                dp->disp.dpy,
-                c ? c->context : EGL_NO_CONTEXT,
-                target, buffer, attrib_list);
-    }
-    return result;
-}
-
-EGLBoolean eglDestroyImageKHR(EGLDisplay dpy, EGLImageKHR img)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    EGLBoolean result = EGL_FALSE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglDestroyImageKHR) {
-        result = cnx->egl.eglDestroyImageKHR(dp->disp.dpy, img);
-    }
-    return result;
-}
-
-// ----------------------------------------------------------------------------
-// EGL_EGLEXT_VERSION 5
-// ----------------------------------------------------------------------------
-
-
-EGLSyncKHR eglCreateSyncKHR(EGLDisplay dpy, EGLenum type, const EGLint *attrib_list)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_NO_SYNC_KHR;
-
-    EGLSyncKHR result = EGL_NO_SYNC_KHR;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglCreateSyncKHR) {
-        result = cnx->egl.eglCreateSyncKHR(dp->disp.dpy, type, attrib_list);
-    }
-    return result;
-}
-
-EGLBoolean eglDestroySyncKHR(EGLDisplay dpy, EGLSyncKHR sync)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    EGLBoolean result = EGL_FALSE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglDestroySyncKHR) {
-        result = cnx->egl.eglDestroySyncKHR(dp->disp.dpy, sync);
-    }
-    return result;
-}
-
-EGLBoolean eglSignalSyncKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLenum mode) {
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    EGLBoolean result = EGL_FALSE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglSignalSyncKHR) {
-        result = cnx->egl.eglSignalSyncKHR(
-                dp->disp.dpy, sync, mode);
-    }
-    return result;
-}
-
-EGLint eglClientWaitSyncKHR(EGLDisplay dpy, EGLSyncKHR sync,
-        EGLint flags, EGLTimeKHR timeout)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    EGLBoolean result = EGL_FALSE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglClientWaitSyncKHR) {
-        result = cnx->egl.eglClientWaitSyncKHR(
-                dp->disp.dpy, sync, flags, timeout);
-    }
-    return result;
-}
-
-EGLBoolean eglGetSyncAttribKHR(EGLDisplay dpy, EGLSyncKHR sync,
-        EGLint attribute, EGLint *value)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    EGLBoolean result = EGL_FALSE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglGetSyncAttribKHR) {
-        result = cnx->egl.eglGetSyncAttribKHR(
-                dp->disp.dpy, sync, attribute, value);
-    }
-    return result;
-}
-
-EGLStreamKHR eglCreateStreamKHR(EGLDisplay dpy, const EGLint *attrib_list)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_NO_STREAM_KHR;
-
-    EGLStreamKHR result = EGL_NO_STREAM_KHR;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglCreateStreamKHR) {
-        result = cnx->egl.eglCreateStreamKHR(
-                dp->disp.dpy, attrib_list);
-    }
-    return result;
-}
-
-EGLBoolean eglDestroyStreamKHR(EGLDisplay dpy, EGLStreamKHR stream)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    EGLBoolean result = EGL_FALSE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglDestroyStreamKHR) {
-        result = cnx->egl.eglDestroyStreamKHR(
-                dp->disp.dpy, stream);
-    }
-    return result;
-}
-
-EGLBoolean eglStreamAttribKHR(EGLDisplay dpy, EGLStreamKHR stream,
-        EGLenum attribute, EGLint value)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    EGLBoolean result = EGL_FALSE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglStreamAttribKHR) {
-        result = cnx->egl.eglStreamAttribKHR(
-                dp->disp.dpy, stream, attribute, value);
-    }
-    return result;
-}
-
-EGLBoolean eglQueryStreamKHR(EGLDisplay dpy, EGLStreamKHR stream,
-        EGLenum attribute, EGLint *value)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    EGLBoolean result = EGL_FALSE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglQueryStreamKHR) {
-        result = cnx->egl.eglQueryStreamKHR(
-                dp->disp.dpy, stream, attribute, value);
-    }
-    return result;
-}
-
-EGLBoolean eglQueryStreamu64KHR(EGLDisplay dpy, EGLStreamKHR stream,
-        EGLenum attribute, EGLuint64KHR *value)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    EGLBoolean result = EGL_FALSE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglQueryStreamu64KHR) {
-        result = cnx->egl.eglQueryStreamu64KHR(
-                dp->disp.dpy, stream, attribute, value);
-    }
-    return result;
-}
-
-EGLBoolean eglQueryStreamTimeKHR(EGLDisplay dpy, EGLStreamKHR stream,
-        EGLenum attribute, EGLTimeKHR *value)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    EGLBoolean result = EGL_FALSE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglQueryStreamTimeKHR) {
-        result = cnx->egl.eglQueryStreamTimeKHR(
-                dp->disp.dpy, stream, attribute, value);
-    }
-    return result;
-}
-
-EGLSurface eglCreateStreamProducerSurfaceKHR(EGLDisplay dpy, EGLConfig config,
-        EGLStreamKHR stream, const EGLint *attrib_list)
-{
-    clearError();
-
-    egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_NO_SURFACE;
-
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglCreateStreamProducerSurfaceKHR) {
-        EGLSurface surface = cnx->egl.eglCreateStreamProducerSurfaceKHR(
-                dp->disp.dpy, config, stream, attrib_list);
-        if (surface != EGL_NO_SURFACE) {
-            egl_surface_t* s = new egl_surface_t(dp.get(), config, NULL,
-                    surface, cnx);
-            return s;
-        }
-    }
-    return EGL_NO_SURFACE;
-}
-
-EGLBoolean eglStreamConsumerGLTextureExternalKHR(EGLDisplay dpy,
-        EGLStreamKHR stream)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    EGLBoolean result = EGL_FALSE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglStreamConsumerGLTextureExternalKHR) {
-        result = cnx->egl.eglStreamConsumerGLTextureExternalKHR(
-                dp->disp.dpy, stream);
-    }
-    return result;
-}
-
-EGLBoolean eglStreamConsumerAcquireKHR(EGLDisplay dpy,
-        EGLStreamKHR stream)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    EGLBoolean result = EGL_FALSE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglStreamConsumerAcquireKHR) {
-        result = cnx->egl.eglStreamConsumerAcquireKHR(
-                dp->disp.dpy, stream);
-    }
-    return result;
-}
-
-EGLBoolean eglStreamConsumerReleaseKHR(EGLDisplay dpy,
-        EGLStreamKHR stream)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    EGLBoolean result = EGL_FALSE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglStreamConsumerReleaseKHR) {
-        result = cnx->egl.eglStreamConsumerReleaseKHR(
-                dp->disp.dpy, stream);
-    }
-    return result;
-}
-
-EGLNativeFileDescriptorKHR eglGetStreamFileDescriptorKHR(
-        EGLDisplay dpy, EGLStreamKHR stream)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_NO_FILE_DESCRIPTOR_KHR;
-
-    EGLNativeFileDescriptorKHR result = EGL_NO_FILE_DESCRIPTOR_KHR;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglGetStreamFileDescriptorKHR) {
-        result = cnx->egl.eglGetStreamFileDescriptorKHR(
-                dp->disp.dpy, stream);
-    }
-    return result;
-}
-
-EGLStreamKHR eglCreateStreamFromFileDescriptorKHR(
-        EGLDisplay dpy, EGLNativeFileDescriptorKHR file_descriptor)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_NO_STREAM_KHR;
-
-    EGLStreamKHR result = EGL_NO_STREAM_KHR;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglCreateStreamFromFileDescriptorKHR) {
-        result = cnx->egl.eglCreateStreamFromFileDescriptorKHR(
-                dp->disp.dpy, file_descriptor);
-    }
-    return result;
-}
-
-// ----------------------------------------------------------------------------
-// EGL_EGLEXT_VERSION 15
-// ----------------------------------------------------------------------------
-
-EGLint eglWaitSyncKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLint flags) {
-    clearError();
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-    EGLint result = EGL_FALSE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglWaitSyncKHR) {
-        result = cnx->egl.eglWaitSyncKHR(dp->disp.dpy, sync, flags);
-    }
-    return result;
-}
-
-// ----------------------------------------------------------------------------
-// ANDROID extensions
-// ----------------------------------------------------------------------------
-
-EGLint eglDupNativeFenceFDANDROID(EGLDisplay dpy, EGLSyncKHR sync)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_NO_NATIVE_FENCE_FD_ANDROID;
-
-    EGLint result = EGL_NO_NATIVE_FENCE_FD_ANDROID;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglDupNativeFenceFDANDROID) {
-        result = cnx->egl.eglDupNativeFenceFDANDROID(dp->disp.dpy, sync);
-    }
-    return result;
-}
-
-EGLBoolean eglPresentationTimeANDROID(EGLDisplay dpy, EGLSurface surface,
-        EGLnsecsANDROID time)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) {
-        return EGL_FALSE;
-    }
-
-    SurfaceRef _s(dp.get(), surface);
-    if (!_s.get()) {
-        setError(EGL_BAD_SURFACE, EGL_FALSE);
-        return EGL_FALSE;
-    }
-
-    egl_surface_t const * const s = get_surface(surface);
-    native_window_set_buffers_timestamp(s->win.get(), time);
-
-    return EGL_TRUE;
-}
-
-EGLClientBuffer eglCreateNativeClientBufferANDROID(const EGLint *attrib_list)
-{
-    clearError();
-
-    int usage = 0;
-    uint32_t width = 0;
-    uint32_t height = 0;
-    uint32_t format = 0;
-    uint32_t red_size = 0;
-    uint32_t green_size = 0;
-    uint32_t blue_size = 0;
-    uint32_t alpha_size = 0;
-
-#define GET_NONNEGATIVE_VALUE(case_name, target) \
-    case case_name: \
-        if (value >= 0) { \
-            target = value; \
-        } else { \
-            return setError(EGL_BAD_PARAMETER, (EGLClientBuffer)0); \
-        } \
-        break
-
-    if (attrib_list) {
-        while (*attrib_list != EGL_NONE) {
-            GLint attr = *attrib_list++;
-            GLint value = *attrib_list++;
-            switch (attr) {
-                GET_NONNEGATIVE_VALUE(EGL_WIDTH, width);
-                GET_NONNEGATIVE_VALUE(EGL_HEIGHT, height);
-                GET_NONNEGATIVE_VALUE(EGL_RED_SIZE, red_size);
-                GET_NONNEGATIVE_VALUE(EGL_GREEN_SIZE, green_size);
-                GET_NONNEGATIVE_VALUE(EGL_BLUE_SIZE, blue_size);
-                GET_NONNEGATIVE_VALUE(EGL_ALPHA_SIZE, alpha_size);
-                case EGL_NATIVE_BUFFER_USAGE_ANDROID:
-                    if (value & EGL_NATIVE_BUFFER_USAGE_PROTECTED_BIT_ANDROID) {
-                        usage |= GRALLOC_USAGE_PROTECTED;
-                    }
-                    if (value & EGL_NATIVE_BUFFER_USAGE_RENDERBUFFER_BIT_ANDROID) {
-                        usage |= GRALLOC_USAGE_HW_RENDER;
-                    }
-                    if (value & EGL_NATIVE_BUFFER_USAGE_TEXTURE_BIT_ANDROID) {
-                        usage |= GRALLOC_USAGE_HW_TEXTURE;
-                    }
-                    break;
-                default:
-                    return setError(EGL_BAD_PARAMETER, (EGLClientBuffer)0);
-            }
-        }
-    }
-#undef GET_NONNEGATIVE_VALUE
-
-    // Validate format.
-    if (red_size == 8 && green_size == 8 && blue_size == 8) {
-        if (alpha_size == 8) {
-            format = HAL_PIXEL_FORMAT_RGBA_8888;
-        } else {
-            format = HAL_PIXEL_FORMAT_RGB_888;
-        }
-    } else if (red_size == 5 && green_size == 6 && blue_size == 5 &&
-               alpha_size == 0) {
-        format = HAL_PIXEL_FORMAT_RGB_565;
-    } else {
-        ALOGE("Invalid native pixel format { r=%d, g=%d, b=%d, a=%d }",
-                red_size, green_size, blue_size, alpha_size);
-        return setError(EGL_BAD_PARAMETER, (EGLClientBuffer)0);
-    }
-
-#define CHECK_ERROR_CONDITION(message) \
-    if (err != NO_ERROR) { \
-        ALOGE(message); \
-        goto error_condition; \
-    }
-
-    // The holder is used to destroy the buffer if an error occurs.
-    GraphicBuffer* gBuffer = new GraphicBuffer();
-    sp<IServiceManager> sm = defaultServiceManager();
-    sp<IBinder> surfaceFlinger = sm->getService(String16("SurfaceFlinger"));
-    sp<IBinder> allocator;
-    Parcel sc_data, sc_reply, data, reply;
-    status_t err = NO_ERROR;
-    if (sm == NULL) {
-        ALOGE("Unable to connect to ServiceManager");
-        goto error_condition;
-    }
-
-    // Obtain an allocator.
-    if (surfaceFlinger == NULL) {
-        ALOGE("Unable to connect to SurfaceFlinger");
-        goto error_condition;
-    }
-    sc_data.writeInterfaceToken(String16("android.ui.ISurfaceComposer"));
-    err = surfaceFlinger->transact(
-            BnSurfaceComposer::CREATE_GRAPHIC_BUFFER_ALLOC, sc_data, &sc_reply);
-    CHECK_ERROR_CONDITION("Unable to obtain allocator from SurfaceFlinger");
-    allocator = sc_reply.readStrongBinder();
-
-    if (allocator == NULL) {
-        ALOGE("Unable to obtain an ISurfaceComposer");
-        goto error_condition;
-    }
-    data.writeInterfaceToken(String16("android.ui.IGraphicBufferAlloc"));
-    err = data.writeUint32(width);
-    CHECK_ERROR_CONDITION("Unable to write width");
-    err = data.writeUint32(height);
-    CHECK_ERROR_CONDITION("Unable to write height");
-    err = data.writeInt32(static_cast<int32_t>(format));
-    CHECK_ERROR_CONDITION("Unable to write format");
-    err = data.writeUint32(usage);
-    CHECK_ERROR_CONDITION("Unable to write usage");
-    err = data.writeUtf8AsUtf16(
-            std::string("[eglCreateNativeClientBufferANDROID pid ") +
-            std::to_string(getpid()) + ']');
-    CHECK_ERROR_CONDITION("Unable to write requestor name");
-    err = allocator->transact(IBinder::FIRST_CALL_TRANSACTION, data,
-            &reply);
-    CHECK_ERROR_CONDITION(
-            "Unable to request buffer allocation from surface composer");
-    err = reply.readInt32();
-    CHECK_ERROR_CONDITION("Unable to obtain buffer from surface composer");
-    err = reply.read(*gBuffer);
-    CHECK_ERROR_CONDITION("Unable to read buffer from surface composer");
-
-    err = gBuffer->initCheck();
-    if (err != NO_ERROR) {
-        ALOGE("Unable to create native buffer { w=%d, h=%d, f=%d, u=%#x }: %#x",
-                width, height, format, usage, err);
-        goto error_condition;
-    }
-    ALOGD("Created new native buffer %p { w=%d, h=%d, f=%d, u=%#x }",
-            gBuffer, width, height, format, usage);
-    return static_cast<EGLClientBuffer>(gBuffer->getNativeBuffer());
-
-#undef CHECK_ERROR_CONDITION
-
-error_condition:
-    // Delete the buffer.
-    sp<GraphicBuffer> holder(gBuffer);
-    return setError(EGL_BAD_ALLOC, (EGLClientBuffer)0);
-}
-
-// ----------------------------------------------------------------------------
-// NVIDIA extensions
-// ----------------------------------------------------------------------------
-EGLuint64NV eglGetSystemTimeFrequencyNV()
-{
-    clearError();
-
-    if (egl_init_drivers() == EGL_FALSE) {
-        return setError(EGL_BAD_PARAMETER, EGL_FALSE);
-    }
-
-    EGLuint64NV ret = 0;
-    egl_connection_t* const cnx = &gEGLImpl;
-
-    if (cnx->dso && cnx->egl.eglGetSystemTimeFrequencyNV) {
-        return cnx->egl.eglGetSystemTimeFrequencyNV();
-    }
-
-    return setErrorQuiet(EGL_BAD_DISPLAY, 0);
-}
-
-EGLuint64NV eglGetSystemTimeNV()
-{
-    clearError();
-
-    if (egl_init_drivers() == EGL_FALSE) {
-        return setError(EGL_BAD_PARAMETER, EGL_FALSE);
-    }
-
-    EGLuint64NV ret = 0;
-    egl_connection_t* const cnx = &gEGLImpl;
-
-    if (cnx->dso && cnx->egl.eglGetSystemTimeNV) {
-        return cnx->egl.eglGetSystemTimeNV();
-    }
-
-    return setErrorQuiet(EGL_BAD_DISPLAY, 0);
-}
-
-// ----------------------------------------------------------------------------
-// Partial update extension
-// ----------------------------------------------------------------------------
-EGLBoolean eglSetDamageRegionKHR(EGLDisplay dpy, EGLSurface surface,
-        EGLint *rects, EGLint n_rects)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) {
-        setError(EGL_BAD_DISPLAY, EGL_FALSE);
-        return EGL_FALSE;
-    }
-
-    SurfaceRef _s(dp.get(), surface);
-    if (!_s.get()) {
-        setError(EGL_BAD_SURFACE, EGL_FALSE);
-        return EGL_FALSE;
-    }
-
-    egl_surface_t const * const s = get_surface(surface);
-    if (s->cnx->egl.eglSetDamageRegionKHR) {
-        return s->cnx->egl.eglSetDamageRegionKHR(dp->disp.dpy, s->surface,
-                rects, n_rects);
-    }
-
-    return EGL_FALSE;
-}
-
-EGLBoolean eglGetFrameTimestampsANDROID(EGLDisplay dpy, EGLSurface surface,
-        EGLint framesAgo, EGLint numTimestamps, const EGLint *timestamps,
-        EGLnsecsANDROID *values)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) {
-        setError(EGL_BAD_DISPLAY, EGL_FALSE);
-        return EGL_FALSE;
-    }
-
-    SurfaceRef _s(dp.get(), surface);
-    if (!_s.get()) {
-        setError(EGL_BAD_SURFACE, EGL_FALSE);
-        return EGL_FALSE;
-    }
-
-    egl_surface_t const * const s = get_surface(surface);
-
-    if (!s->enableTimestamps) {
-        setError(EGL_BAD_SURFACE, EGL_FALSE);
-        return EGL_FALSE;
-    }
-
-    nsecs_t* postedTime = nullptr;
-    nsecs_t* acquireTime = nullptr;
-    nsecs_t* refreshStartTime = nullptr;
-    nsecs_t* GLCompositionDoneTime = nullptr;
-    nsecs_t* displayRetireTime = nullptr;
-    nsecs_t* releaseTime = nullptr;
-
-    for (int i = 0; i < numTimestamps; i++) {
-        switch (timestamps[i]) {
-            case EGL_QUEUE_TIME_ANDROID:
-                postedTime = &values[i];
-                break;
-            case EGL_RENDERING_COMPLETE_TIME_ANDROID:
-                acquireTime = &values[i];
-                break;
-            case EGL_COMPOSITION_START_TIME_ANDROID:
-                refreshStartTime = &values[i];
-                break;
-            case EGL_COMPOSITION_FINISHED_TIME_ANDROID:
-                GLCompositionDoneTime = &values[i];
-                break;
-            case EGL_DISPLAY_RETIRE_TIME_ANDROID:
-                displayRetireTime = &values[i];
-                break;
-            case EGL_READS_DONE_TIME_ANDROID:
-                releaseTime = &values[i];
-                break;
-            default:
-                setError(EGL_BAD_PARAMETER, EGL_FALSE);
-                return EGL_FALSE;
-        }
-    }
-
-    status_t ret = native_window_get_frame_timestamps(s->win.get(), framesAgo,
-            postedTime, acquireTime, refreshStartTime, GLCompositionDoneTime,
-            displayRetireTime, releaseTime);
-
-    if (ret != NO_ERROR) {
-        setError(EGL_BAD_ACCESS, EGL_FALSE);
-        return EGL_FALSE;
-    }
-
-    return EGL_TRUE;
-}
-
-EGLBoolean eglQueryTimestampSupportedANDROID(EGLDisplay dpy, EGLSurface surface,
-        EGLint timestamp)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) {
-        setError(EGL_BAD_DISPLAY, EGL_FALSE);
-        return EGL_FALSE;
-    }
-
-    SurfaceRef _s(dp.get(), surface);
-    if (!_s.get()) {
-        setError(EGL_BAD_SURFACE, EGL_FALSE);
-        return EGL_FALSE;
-    }
-
-    switch (timestamp) {
-#if ENABLE_EGL_ANDROID_GET_FRAME_TIMESTAMPS
-        case EGL_QUEUE_TIME_ANDROID:
-        case EGL_RENDERING_COMPLETE_TIME_ANDROID:
-        case EGL_COMPOSITION_START_TIME_ANDROID:
-        case EGL_COMPOSITION_FINISHED_TIME_ANDROID:
-        case EGL_DISPLAY_RETIRE_TIME_ANDROID:
-        case EGL_READS_DONE_TIME_ANDROID:
-            return EGL_TRUE;
-#endif
-        default:
-            return EGL_FALSE;
-    }
-}
diff -Naur frameworksRaw/native/opengl/libs/EGL/eglApi.cpp.orig.orig frameworksModified/native/opengl/libs/EGL/eglApi.cpp.orig.orig
--- frameworksRaw/native/opengl/libs/EGL/eglApi.cpp.orig.orig	2017-07-06 15:34:21.258451589 +0530
+++ frameworksModified/native/opengl/libs/EGL/eglApi.cpp.orig.orig	1970-01-01 05:30:00.000000000 +0530
@@ -1,2117 +0,0 @@
-/*
- ** Copyright 2007, The Android Open Source Project
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-#define ATRACE_TAG ATRACE_TAG_GRAPHICS
-
-#include <dlfcn.h>
-#include <ctype.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include <hardware/gralloc.h>
-#include <system/window.h>
-
-#include <EGL/egl.h>
-#include <EGL/eglext.h>
-
-#include <cutils/log.h>
-#include <cutils/atomic.h>
-#include <cutils/compiler.h>
-#include <cutils/properties.h>
-#include <cutils/memory.h>
-
-#include <gui/ISurfaceComposer.h>
-
-#include <ui/GraphicBuffer.h>
-
-#include <utils/KeyedVector.h>
-#include <utils/SortedVector.h>
-#include <utils/String8.h>
-#include <utils/Trace.h>
-
-#include "binder/Binder.h"
-#include "binder/Parcel.h"
-#include "binder/IServiceManager.h"
-
-#include "../egl_impl.h"
-#include "../hooks.h"
-
-#include "egl_display.h"
-#include "egl_object.h"
-#include "egl_tls.h"
-#include "egldefs.h"
-
-using namespace android;
-
-// This extension has not been ratified yet, so can't be shipped.
-// Implementation is incomplete and untested.
-#define ENABLE_EGL_KHR_GL_COLORSPACE 0
-
-#define ENABLE_EGL_ANDROID_GET_FRAME_TIMESTAMPS 0
-
-// ----------------------------------------------------------------------------
-
-namespace android {
-
-struct extention_map_t {
-    const char* name;
-    __eglMustCastToProperFunctionPointerType address;
-};
-
-/*
- * This is the list of EGL extensions exposed to applications.
- *
- * Some of them (gBuiltinExtensionString) are implemented entirely in this EGL
- * wrapper and are always available.
- *
- * The rest (gExtensionString) depend on support in the EGL driver, and are
- * only available if the driver supports them. However, some of these must be
- * supported because they are used by the Android system itself; these are
- * listed as mandatory below and are required by the CDD. The system *assumes*
- * the mandatory extensions are present and may not function properly if some
- * are missing.
- *
- * NOTE: Both strings MUST have a single space as the last character.
- */
-extern char const * const gBuiltinExtensionString =
-        "EGL_KHR_get_all_proc_addresses "
-        "EGL_ANDROID_presentation_time "
-        "EGL_KHR_swap_buffers_with_damage "
-        "EGL_ANDROID_create_native_client_buffer "
-        "EGL_ANDROID_front_buffer_auto_refresh "
-#if ENABLE_EGL_ANDROID_GET_FRAME_TIMESTAMPS
-        "EGL_ANDROID_get_frame_timestamps "
-#endif
-        ;
-extern char const * const gExtensionString  =
-        "EGL_KHR_image "                        // mandatory
-        "EGL_KHR_image_base "                   // mandatory
-        "EGL_KHR_image_pixmap "
-        "EGL_KHR_lock_surface "
-#if (ENABLE_EGL_KHR_GL_COLORSPACE != 0)
-        "EGL_KHR_gl_colorspace "
-#endif
-        "EGL_KHR_gl_texture_2D_image "
-        "EGL_KHR_gl_texture_3D_image "
-        "EGL_KHR_gl_texture_cubemap_image "
-        "EGL_KHR_gl_renderbuffer_image "
-        "EGL_KHR_reusable_sync "
-        "EGL_KHR_fence_sync "
-        "EGL_KHR_create_context "
-        "EGL_KHR_config_attribs "
-        "EGL_KHR_surfaceless_context "
-        "EGL_KHR_stream "
-        "EGL_KHR_stream_fifo "
-        "EGL_KHR_stream_producer_eglsurface "
-        "EGL_KHR_stream_consumer_gltexture "
-        "EGL_KHR_stream_cross_process_fd "
-        "EGL_EXT_create_context_robustness "
-        "EGL_NV_system_time "
-        "EGL_ANDROID_image_native_buffer "      // mandatory
-        "EGL_KHR_wait_sync "                    // strongly recommended
-        "EGL_ANDROID_recordable "               // mandatory
-        "EGL_KHR_partial_update "               // strongly recommended
-        "EGL_EXT_buffer_age "                   // strongly recommended with partial_update
-        "EGL_KHR_create_context_no_error "
-        "EGL_KHR_mutable_render_buffer "
-        "EGL_EXT_yuv_surface "
-        "EGL_EXT_protected_content "
-        ;
-
-// extensions not exposed to applications but used by the ANDROID system
-//      "EGL_ANDROID_blob_cache "               // strongly recommended
-//      "EGL_IMG_hibernate_process "            // optional
-//      "EGL_ANDROID_native_fence_sync "        // strongly recommended
-//      "EGL_ANDROID_framebuffer_target "       // mandatory for HWC 1.1
-//      "EGL_ANDROID_image_crop "               // optional
-
-/*
- * EGL Extensions entry-points exposed to 3rd party applications
- * (keep in sync with gExtensionString above)
- *
- */
-static const extention_map_t sExtensionMap[] = {
-    // EGL_KHR_lock_surface
-    { "eglLockSurfaceKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglLockSurfaceKHR },
-    { "eglUnlockSurfaceKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglUnlockSurfaceKHR },
-
-    // EGL_KHR_image, EGL_KHR_image_base
-    { "eglCreateImageKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglCreateImageKHR },
-    { "eglDestroyImageKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglDestroyImageKHR },
-
-    // EGL_KHR_reusable_sync, EGL_KHR_fence_sync
-    { "eglCreateSyncKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglCreateSyncKHR },
-    { "eglDestroySyncKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglDestroySyncKHR },
-    { "eglClientWaitSyncKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglClientWaitSyncKHR },
-    { "eglSignalSyncKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglSignalSyncKHR },
-    { "eglGetSyncAttribKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglGetSyncAttribKHR },
-
-    // EGL_NV_system_time
-    { "eglGetSystemTimeFrequencyNV",
-            (__eglMustCastToProperFunctionPointerType)&eglGetSystemTimeFrequencyNV },
-    { "eglGetSystemTimeNV",
-            (__eglMustCastToProperFunctionPointerType)&eglGetSystemTimeNV },
-
-    // EGL_KHR_wait_sync
-    { "eglWaitSyncKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglWaitSyncKHR },
-
-    // EGL_ANDROID_presentation_time
-    { "eglPresentationTimeANDROID",
-            (__eglMustCastToProperFunctionPointerType)&eglPresentationTimeANDROID },
-
-    // EGL_KHR_swap_buffers_with_damage
-    { "eglSwapBuffersWithDamageKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglSwapBuffersWithDamageKHR },
-
-    // EGL_ANDROID_native_client_buffer
-    { "eglCreateNativeClientBufferANDROID",
-            (__eglMustCastToProperFunctionPointerType)&eglCreateNativeClientBufferANDROID },
-
-    // EGL_KHR_partial_update
-    { "eglSetDamageRegionKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglSetDamageRegionKHR },
-
-    { "eglCreateStreamKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglCreateStreamKHR },
-    { "eglDestroyStreamKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglDestroyStreamKHR },
-    { "eglStreamAttribKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglStreamAttribKHR },
-    { "eglQueryStreamKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglQueryStreamKHR },
-    { "eglQueryStreamu64KHR",
-            (__eglMustCastToProperFunctionPointerType)&eglQueryStreamu64KHR },
-    { "eglQueryStreamTimeKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglQueryStreamTimeKHR },
-    { "eglCreateStreamProducerSurfaceKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglCreateStreamProducerSurfaceKHR },
-    { "eglStreamConsumerGLTextureExternalKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglStreamConsumerGLTextureExternalKHR },
-    { "eglStreamConsumerAcquireKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglStreamConsumerAcquireKHR },
-    { "eglStreamConsumerReleaseKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglStreamConsumerReleaseKHR },
-    { "eglGetStreamFileDescriptorKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglGetStreamFileDescriptorKHR },
-    { "eglCreateStreamFromFileDescriptorKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglCreateStreamFromFileDescriptorKHR },
-
-    // EGL_ANDROID_get_frame_timestamps
-    { "eglGetFrameTimestampsANDROID",
-            (__eglMustCastToProperFunctionPointerType)&eglGetFrameTimestampsANDROID },
-    { "eglQueryTimestampSupportedANDROID",
-            (__eglMustCastToProperFunctionPointerType)&eglQueryTimestampSupportedANDROID },
-};
-
-/*
- * These extensions entry-points should not be exposed to applications.
- * They're used internally by the Android EGL layer.
- */
-#define FILTER_EXTENSIONS(procname) \
-        (!strcmp((procname), "eglSetBlobCacheFuncsANDROID") ||    \
-         !strcmp((procname), "eglHibernateProcessIMG")      ||    \
-         !strcmp((procname), "eglAwakenProcessIMG")         ||    \
-         !strcmp((procname), "eglDupNativeFenceFDANDROID"))
-
-
-
-// accesses protected by sExtensionMapMutex
-static DefaultKeyedVector<String8, __eglMustCastToProperFunctionPointerType> sGLExtentionMap;
-static int sGLExtentionSlot = 0;
-static pthread_mutex_t sExtensionMapMutex = PTHREAD_MUTEX_INITIALIZER;
-
-static void(*findProcAddress(const char* name,
-        const extention_map_t* map, size_t n))() {
-    for (uint32_t i=0 ; i<n ; i++) {
-        if (!strcmp(name, map[i].name)) {
-            return map[i].address;
-        }
-    }
-    return NULL;
-}
-
-// ----------------------------------------------------------------------------
-
-extern void setGLHooksThreadSpecific(gl_hooks_t const *value);
-extern EGLBoolean egl_init_drivers();
-extern const __eglMustCastToProperFunctionPointerType gExtensionForwarders[MAX_NUMBER_OF_GL_EXTENSIONS];
-extern gl_hooks_t gHooksTrace;
-
-} // namespace android;
-
-
-// ----------------------------------------------------------------------------
-
-static inline void clearError() { egl_tls_t::clearError(); }
-static inline EGLContext getContext() { return egl_tls_t::getContext(); }
-
-// ----------------------------------------------------------------------------
-
-EGLDisplay eglGetDisplay(EGLNativeDisplayType display)
-{
-    ATRACE_CALL();
-    clearError();
-
-    uintptr_t index = reinterpret_cast<uintptr_t>(display);
-    if (index >= NUM_DISPLAYS) {
-        return setError(EGL_BAD_PARAMETER, EGL_NO_DISPLAY);
-    }
-
-    if (egl_init_drivers() == EGL_FALSE) {
-        return setError(EGL_BAD_PARAMETER, EGL_NO_DISPLAY);
-    }
-
-    EGLDisplay dpy = egl_display_t::getFromNativeDisplay(display);
-    return dpy;
-}
-
-// ----------------------------------------------------------------------------
-// Initialization
-// ----------------------------------------------------------------------------
-
-EGLBoolean eglInitialize(EGLDisplay dpy, EGLint *major, EGLint *minor)
-{
-    clearError();
-
-    egl_display_ptr dp = get_display(dpy);
-    if (!dp) return setError(EGL_BAD_DISPLAY, EGL_FALSE);
-
-    EGLBoolean res = dp->initialize(major, minor);
-
-    return res;
-}
-
-EGLBoolean eglTerminate(EGLDisplay dpy)
-{
-    // NOTE: don't unload the drivers b/c some APIs can be called
-    // after eglTerminate() has been called. eglTerminate() only
-    // terminates an EGLDisplay, not a EGL itself.
-
-    clearError();
-
-    egl_display_ptr dp = get_display(dpy);
-    if (!dp) return setError(EGL_BAD_DISPLAY, EGL_FALSE);
-
-    EGLBoolean res = dp->terminate();
-
-    return res;
-}
-
-// ----------------------------------------------------------------------------
-// configuration
-// ----------------------------------------------------------------------------
-
-EGLBoolean eglGetConfigs(   EGLDisplay dpy,
-                            EGLConfig *configs,
-                            EGLint config_size, EGLint *num_config)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    if (num_config==0) {
-        return setError(EGL_BAD_PARAMETER, EGL_FALSE);
-    }
-
-    EGLBoolean res = EGL_FALSE;
-    *num_config = 0;
-
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso) {
-        res = cnx->egl.eglGetConfigs(
-                dp->disp.dpy, configs, config_size, num_config);
-    }
-
-    return res;
-}
-
-EGLBoolean eglChooseConfig( EGLDisplay dpy, const EGLint *attrib_list,
-                            EGLConfig *configs, EGLint config_size,
-                            EGLint *num_config)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    if (num_config==0) {
-        return setError(EGL_BAD_PARAMETER, EGL_FALSE);
-    }
-
-    EGLBoolean res = EGL_FALSE;
-    *num_config = 0;
-
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso) {
-        if (attrib_list) {
-            char value[PROPERTY_VALUE_MAX];
-            property_get("debug.egl.force_msaa", value, "false");
-
-            if (!strcmp(value, "true")) {
-                size_t attribCount = 0;
-                EGLint attrib = attrib_list[0];
-
-                // Only enable MSAA if the context is OpenGL ES 2.0 and
-                // if no caveat is requested
-                const EGLint *attribRendererable = NULL;
-                const EGLint *attribCaveat = NULL;
-
-                // Count the number of attributes and look for
-                // EGL_RENDERABLE_TYPE and EGL_CONFIG_CAVEAT
-                while (attrib != EGL_NONE) {
-                    attrib = attrib_list[attribCount];
-                    switch (attrib) {
-                        case EGL_RENDERABLE_TYPE:
-                            attribRendererable = &attrib_list[attribCount];
-                            break;
-                        case EGL_CONFIG_CAVEAT:
-                            attribCaveat = &attrib_list[attribCount];
-                            break;
-                    }
-                    attribCount++;
-                }
-
-                if (attribRendererable && attribRendererable[1] == EGL_OPENGL_ES2_BIT &&
-                        (!attribCaveat || attribCaveat[1] != EGL_NONE)) {
-
-                    // Insert 2 extra attributes to force-enable MSAA 4x
-                    EGLint aaAttribs[attribCount + 4];
-                    aaAttribs[0] = EGL_SAMPLE_BUFFERS;
-                    aaAttribs[1] = 1;
-                    aaAttribs[2] = EGL_SAMPLES;
-                    aaAttribs[3] = 4;
-
-                    memcpy(&aaAttribs[4], attrib_list, attribCount * sizeof(EGLint));
-
-                    EGLint numConfigAA;
-                    EGLBoolean resAA = cnx->egl.eglChooseConfig(
-                            dp->disp.dpy, aaAttribs, configs, config_size, &numConfigAA);
-
-                    if (resAA == EGL_TRUE && numConfigAA > 0) {
-                        ALOGD("Enabling MSAA 4x");
-                        *num_config = numConfigAA;
-                        return resAA;
-                    }
-                }
-            }
-        }
-
-        res = cnx->egl.eglChooseConfig(
-                dp->disp.dpy, attrib_list, configs, config_size, num_config);
-    }
-    return res;
-}
-
-EGLBoolean eglGetConfigAttrib(EGLDisplay dpy, EGLConfig config,
-        EGLint attribute, EGLint *value)
-{
-    clearError();
-
-    egl_connection_t* cnx = NULL;
-    const egl_display_ptr dp = validate_display_connection(dpy, cnx);
-    if (!dp) return EGL_FALSE;
-
-    return cnx->egl.eglGetConfigAttrib(
-            dp->disp.dpy, config, attribute, value);
-}
-
-// ----------------------------------------------------------------------------
-// surfaces
-// ----------------------------------------------------------------------------
-
-// The EGL_KHR_gl_colorspace spec hasn't been ratified yet, so these haven't
-// been added to the Khronos egl.h.
-#define EGL_GL_COLORSPACE_KHR           EGL_VG_COLORSPACE
-#define EGL_GL_COLORSPACE_SRGB_KHR      EGL_VG_COLORSPACE_sRGB
-#define EGL_GL_COLORSPACE_LINEAR_KHR    EGL_VG_COLORSPACE_LINEAR
-
-// Turn linear formats into corresponding sRGB formats when colorspace is
-// EGL_GL_COLORSPACE_SRGB_KHR, or turn sRGB formats into corresponding linear
-// formats when colorspace is EGL_GL_COLORSPACE_LINEAR_KHR. In any cases where
-// the modification isn't possible, the original dataSpace is returned.
-static android_dataspace modifyBufferDataspace( android_dataspace dataSpace,
-                                                EGLint colorspace) {
-    if (colorspace == EGL_GL_COLORSPACE_LINEAR_KHR) {
-        return HAL_DATASPACE_SRGB_LINEAR;
-    } else if (colorspace == EGL_GL_COLORSPACE_SRGB_KHR) {
-        return HAL_DATASPACE_SRGB;
-    }
-    return dataSpace;
-}
-
-EGLSurface eglCreateWindowSurface(  EGLDisplay dpy, EGLConfig config,
-                                    NativeWindowType window,
-                                    const EGLint *attrib_list)
-{
-    clearError();
-
-    egl_connection_t* cnx = NULL;
-    egl_display_ptr dp = validate_display_connection(dpy, cnx);
-    if (dp) {
-        EGLDisplay iDpy = dp->disp.dpy;
-
-        int result = native_window_api_connect(window, NATIVE_WINDOW_API_EGL);
-        if (result != OK) {
-            ALOGE("eglCreateWindowSurface: native_window_api_connect (win=%p) "
-                    "failed (%#x) (already connected to another API?)",
-                    window, result);
-            return setError(EGL_BAD_ALLOC, EGL_NO_SURFACE);
-        }
-
-        // Set the native window's buffers format to match what this config requests.
-        // Whether to use sRGB gamma is not part of the EGLconfig, but is part
-        // of our native format. So if sRGB gamma is requested, we have to
-        // modify the EGLconfig's format before setting the native window's
-        // format.
-
-        // by default, just pick RGBA_8888
-        EGLint format = HAL_PIXEL_FORMAT_RGBA_8888;
-        android_dataspace dataSpace = HAL_DATASPACE_UNKNOWN;
-
-        EGLint a = 0;
-        cnx->egl.eglGetConfigAttrib(iDpy, config, EGL_ALPHA_SIZE, &a);
-        if (a > 0) {
-            // alpha-channel requested, there's really only one suitable format
-            format = HAL_PIXEL_FORMAT_RGBA_8888;
-        } else {
-            EGLint r, g, b;
-            r = g = b = 0;
-            cnx->egl.eglGetConfigAttrib(iDpy, config, EGL_RED_SIZE,   &r);
-            cnx->egl.eglGetConfigAttrib(iDpy, config, EGL_GREEN_SIZE, &g);
-            cnx->egl.eglGetConfigAttrib(iDpy, config, EGL_BLUE_SIZE,  &b);
-            EGLint colorDepth = r + g + b;
-            if (colorDepth <= 16) {
-                format = HAL_PIXEL_FORMAT_RGB_565;
-            } else {
-                format = HAL_PIXEL_FORMAT_RGBX_8888;
-            }
-        }
-
-        // now select a corresponding sRGB format if needed
-        if (attrib_list && dp->haveExtension("EGL_KHR_gl_colorspace")) {
-            for (const EGLint* attr = attrib_list; *attr != EGL_NONE; attr += 2) {
-                if (*attr == EGL_GL_COLORSPACE_KHR) {
-                    if (ENABLE_EGL_KHR_GL_COLORSPACE) {
-                        dataSpace = modifyBufferDataspace(dataSpace, *(attr+1));
-                    } else {
-                        // Normally we'd pass through unhandled attributes to
-                        // the driver. But in case the driver implements this
-                        // extension but we're disabling it, we want to prevent
-                        // it getting through -- support will be broken without
-                        // our help.
-                        ALOGE("sRGB window surfaces not supported");
-                        return setError(EGL_BAD_ATTRIBUTE, EGL_NO_SURFACE);
-                    }
-                }
-            }
-        }
-
-        if (format != 0) {
-            int err = native_window_set_buffers_format(window, format);
-            if (err != 0) {
-                ALOGE("error setting native window pixel format: %s (%d)",
-                        strerror(-err), err);
-                native_window_api_disconnect(window, NATIVE_WINDOW_API_EGL);
-                return setError(EGL_BAD_NATIVE_WINDOW, EGL_NO_SURFACE);
-            }
-        }
-
-        if (dataSpace != 0) {
-            int err = native_window_set_buffers_data_space(window, dataSpace);
-            if (err != 0) {
-                ALOGE("error setting native window pixel dataSpace: %s (%d)",
-                        strerror(-err), err);
-                native_window_api_disconnect(window, NATIVE_WINDOW_API_EGL);
-                return setError(EGL_BAD_NATIVE_WINDOW, EGL_NO_SURFACE);
-            }
-        }
-
-        // the EGL spec requires that a new EGLSurface default to swap interval
-        // 1, so explicitly set that on the window here.
-        ANativeWindow* anw = reinterpret_cast<ANativeWindow*>(window);
-        anw->setSwapInterval(anw, 1);
-
-        EGLSurface surface = cnx->egl.eglCreateWindowSurface(
-                iDpy, config, window, attrib_list);
-        if (surface != EGL_NO_SURFACE) {
-            egl_surface_t* s = new egl_surface_t(dp.get(), config, window,
-                    surface, cnx);
-            return s;
-        }
-
-        // EGLSurface creation failed
-        native_window_set_buffers_format(window, 0);
-        native_window_api_disconnect(window, NATIVE_WINDOW_API_EGL);
-    }
-    return EGL_NO_SURFACE;
-}
-
-EGLSurface eglCreatePixmapSurface(  EGLDisplay dpy, EGLConfig config,
-                                    NativePixmapType pixmap,
-                                    const EGLint *attrib_list)
-{
-    clearError();
-
-    egl_connection_t* cnx = NULL;
-    egl_display_ptr dp = validate_display_connection(dpy, cnx);
-    if (dp) {
-        EGLSurface surface = cnx->egl.eglCreatePixmapSurface(
-                dp->disp.dpy, config, pixmap, attrib_list);
-        if (surface != EGL_NO_SURFACE) {
-            egl_surface_t* s = new egl_surface_t(dp.get(), config, NULL,
-                    surface, cnx);
-            return s;
-        }
-    }
-    return EGL_NO_SURFACE;
-}
-
-EGLSurface eglCreatePbufferSurface( EGLDisplay dpy, EGLConfig config,
-                                    const EGLint *attrib_list)
-{
-    clearError();
-
-    egl_connection_t* cnx = NULL;
-    egl_display_ptr dp = validate_display_connection(dpy, cnx);
-    if (dp) {
-        EGLSurface surface = cnx->egl.eglCreatePbufferSurface(
-                dp->disp.dpy, config, attrib_list);
-        if (surface != EGL_NO_SURFACE) {
-            egl_surface_t* s = new egl_surface_t(dp.get(), config, NULL,
-                    surface, cnx);
-            return s;
-        }
-    }
-    return EGL_NO_SURFACE;
-}
-
-EGLBoolean eglDestroySurface(EGLDisplay dpy, EGLSurface surface)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    SurfaceRef _s(dp.get(), surface);
-    if (!_s.get())
-        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-
-    egl_surface_t * const s = get_surface(surface);
-    EGLBoolean result = s->cnx->egl.eglDestroySurface(dp->disp.dpy, s->surface);
-    if (result == EGL_TRUE) {
-        _s.terminate();
-    }
-    return result;
-}
-
-EGLBoolean eglQuerySurface( EGLDisplay dpy, EGLSurface surface,
-                            EGLint attribute, EGLint *value)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    SurfaceRef _s(dp.get(), surface);
-    if (!_s.get())
-        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-
-    egl_surface_t const * const s = get_surface(surface);
-    return s->cnx->egl.eglQuerySurface(
-            dp->disp.dpy, s->surface, attribute, value);
-}
-
-void EGLAPI eglBeginFrame(EGLDisplay dpy, EGLSurface surface) {
-    ATRACE_CALL();
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) {
-        return;
-    }
-
-    SurfaceRef _s(dp.get(), surface);
-    if (!_s.get()) {
-        setError(EGL_BAD_SURFACE, EGL_FALSE);
-        return;
-    }
-}
-
-// ----------------------------------------------------------------------------
-// Contexts
-// ----------------------------------------------------------------------------
-
-EGLContext eglCreateContext(EGLDisplay dpy, EGLConfig config,
-                            EGLContext share_list, const EGLint *attrib_list)
-{
-    clearError();
-
-    egl_connection_t* cnx = NULL;
-    const egl_display_ptr dp = validate_display_connection(dpy, cnx);
-    if (dp) {
-        if (share_list != EGL_NO_CONTEXT) {
-            if (!ContextRef(dp.get(), share_list).get()) {
-                return setError(EGL_BAD_CONTEXT, EGL_NO_CONTEXT);
-            }
-            egl_context_t* const c = get_context(share_list);
-            share_list = c->context;
-        }
-        EGLContext context = cnx->egl.eglCreateContext(
-                dp->disp.dpy, config, share_list, attrib_list);
-        if (context != EGL_NO_CONTEXT) {
-            // figure out if it's a GLESv1 or GLESv2
-            int version = 0;
-            if (attrib_list) {
-                while (*attrib_list != EGL_NONE) {
-                    GLint attr = *attrib_list++;
-                    GLint value = *attrib_list++;
-                    if (attr == EGL_CONTEXT_CLIENT_VERSION) {
-                        if (value == 1) {
-                            version = egl_connection_t::GLESv1_INDEX;
-                        } else if (value == 2 || value == 3) {
-                            version = egl_connection_t::GLESv2_INDEX;
-                        }
-                    }
-                };
-            }
-            egl_context_t* c = new egl_context_t(dpy, context, config, cnx,
-                    version);
-            return c;
-        }
-    }
-    return EGL_NO_CONTEXT;
-}
-
-EGLBoolean eglDestroyContext(EGLDisplay dpy, EGLContext ctx)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp)
-        return EGL_FALSE;
-
-    ContextRef _c(dp.get(), ctx);
-    if (!_c.get())
-        return setError(EGL_BAD_CONTEXT, EGL_FALSE);
-
-    egl_context_t * const c = get_context(ctx);
-    EGLBoolean result = c->cnx->egl.eglDestroyContext(dp->disp.dpy, c->context);
-    if (result == EGL_TRUE) {
-        _c.terminate();
-    }
-    return result;
-}
-
-EGLBoolean eglMakeCurrent(  EGLDisplay dpy, EGLSurface draw,
-                            EGLSurface read, EGLContext ctx)
-{
-    clearError();
-
-    egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return setError(EGL_BAD_DISPLAY, EGL_FALSE);
-
-    // If ctx is not EGL_NO_CONTEXT, read is not EGL_NO_SURFACE, or draw is not
-    // EGL_NO_SURFACE, then an EGL_NOT_INITIALIZED error is generated if dpy is
-    // a valid but uninitialized display.
-    if ( (ctx != EGL_NO_CONTEXT) || (read != EGL_NO_SURFACE) ||
-         (draw != EGL_NO_SURFACE) ) {
-        if (!dp->isReady()) return setError(EGL_NOT_INITIALIZED, EGL_FALSE);
-    }
-
-    // get a reference to the object passed in
-    ContextRef _c(dp.get(), ctx);
-    SurfaceRef _d(dp.get(), draw);
-    SurfaceRef _r(dp.get(), read);
-
-    // validate the context (if not EGL_NO_CONTEXT)
-    if ((ctx != EGL_NO_CONTEXT) && !_c.get()) {
-        // EGL_NO_CONTEXT is valid
-        return setError(EGL_BAD_CONTEXT, EGL_FALSE);
-    }
-
-    // these are the underlying implementation's object
-    EGLContext impl_ctx  = EGL_NO_CONTEXT;
-    EGLSurface impl_draw = EGL_NO_SURFACE;
-    EGLSurface impl_read = EGL_NO_SURFACE;
-
-    // these are our objects structs passed in
-    egl_context_t       * c = NULL;
-    egl_surface_t const * d = NULL;
-    egl_surface_t const * r = NULL;
-
-    // these are the current objects structs
-    egl_context_t * cur_c = get_context(getContext());
-
-    if (ctx != EGL_NO_CONTEXT) {
-        c = get_context(ctx);
-        impl_ctx = c->context;
-    } else {
-        // no context given, use the implementation of the current context
-        if (draw != EGL_NO_SURFACE || read != EGL_NO_SURFACE) {
-            // calling eglMakeCurrent( ..., !=0, !=0, EGL_NO_CONTEXT);
-            return setError(EGL_BAD_MATCH, EGL_FALSE);
-        }
-        if (cur_c == NULL) {
-            // no current context
-            // not an error, there is just no current context.
-            return EGL_TRUE;
-        }
-    }
-
-    // retrieve the underlying implementation's draw EGLSurface
-    if (draw != EGL_NO_SURFACE) {
-        if (!_d.get()) return setError(EGL_BAD_SURFACE, EGL_FALSE);
-        d = get_surface(draw);
-        impl_draw = d->surface;
-    }
-
-    // retrieve the underlying implementation's read EGLSurface
-    if (read != EGL_NO_SURFACE) {
-        if (!_r.get()) return setError(EGL_BAD_SURFACE, EGL_FALSE);
-        r = get_surface(read);
-        impl_read = r->surface;
-    }
-
-
-    EGLBoolean result = dp->makeCurrent(c, cur_c,
-            draw, read, ctx,
-            impl_draw, impl_read, impl_ctx);
-
-    if (result == EGL_TRUE) {
-        if (c) {
-            setGLHooksThreadSpecific(c->cnx->hooks[c->version]);
-            egl_tls_t::setContext(ctx);
-            _c.acquire();
-            _r.acquire();
-            _d.acquire();
-        } else {
-            setGLHooksThreadSpecific(&gHooksNoContext);
-            egl_tls_t::setContext(EGL_NO_CONTEXT);
-        }
-    } else {
-        // this will ALOGE the error
-        egl_connection_t* const cnx = &gEGLImpl;
-        result = setError(cnx->egl.eglGetError(), EGL_FALSE);
-    }
-    return result;
-}
-
-
-EGLBoolean eglQueryContext( EGLDisplay dpy, EGLContext ctx,
-                            EGLint attribute, EGLint *value)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    ContextRef _c(dp.get(), ctx);
-    if (!_c.get()) return setError(EGL_BAD_CONTEXT, EGL_FALSE);
-
-    egl_context_t * const c = get_context(ctx);
-    return c->cnx->egl.eglQueryContext(
-            dp->disp.dpy, c->context, attribute, value);
-
-}
-
-EGLContext eglGetCurrentContext(void)
-{
-    // could be called before eglInitialize(), but we wouldn't have a context
-    // then, and this function would correctly return EGL_NO_CONTEXT.
-
-    clearError();
-
-    EGLContext ctx = getContext();
-    return ctx;
-}
-
-EGLSurface eglGetCurrentSurface(EGLint readdraw)
-{
-    // could be called before eglInitialize(), but we wouldn't have a context
-    // then, and this function would correctly return EGL_NO_SURFACE.
-
-    clearError();
-
-    EGLContext ctx = getContext();
-    if (ctx) {
-        egl_context_t const * const c = get_context(ctx);
-        if (!c) return setError(EGL_BAD_CONTEXT, EGL_NO_SURFACE);
-        switch (readdraw) {
-            case EGL_READ: return c->read;
-            case EGL_DRAW: return c->draw;
-            default: return setError(EGL_BAD_PARAMETER, EGL_NO_SURFACE);
-        }
-    }
-    return EGL_NO_SURFACE;
-}
-
-EGLDisplay eglGetCurrentDisplay(void)
-{
-    // could be called before eglInitialize(), but we wouldn't have a context
-    // then, and this function would correctly return EGL_NO_DISPLAY.
-
-    clearError();
-
-    EGLContext ctx = getContext();
-    if (ctx) {
-        egl_context_t const * const c = get_context(ctx);
-        if (!c) return setError(EGL_BAD_CONTEXT, EGL_NO_SURFACE);
-        return c->dpy;
-    }
-    return EGL_NO_DISPLAY;
-}
-
-EGLBoolean eglWaitGL(void)
-{
-    clearError();
-
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (!cnx->dso)
-        return setError(EGL_BAD_CONTEXT, EGL_FALSE);
-
-    return cnx->egl.eglWaitGL();
-}
-
-EGLBoolean eglWaitNative(EGLint engine)
-{
-    clearError();
-
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (!cnx->dso)
-        return setError(EGL_BAD_CONTEXT, EGL_FALSE);
-
-    return cnx->egl.eglWaitNative(engine);
-}
-
-EGLint eglGetError(void)
-{
-    EGLint err = EGL_SUCCESS;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso) {
-        err = cnx->egl.eglGetError();
-    }
-    if (err == EGL_SUCCESS) {
-        err = egl_tls_t::getError();
-    }
-    return err;
-}
-
-static __eglMustCastToProperFunctionPointerType findBuiltinWrapper(
-        const char* procname) {
-    const egl_connection_t* cnx = &gEGLImpl;
-    void* proc = NULL;
-
-    proc = dlsym(cnx->libEgl, procname);
-    if (proc) return (__eglMustCastToProperFunctionPointerType)proc;
-
-    proc = dlsym(cnx->libGles2, procname);
-    if (proc) return (__eglMustCastToProperFunctionPointerType)proc;
-
-    proc = dlsym(cnx->libGles1, procname);
-    if (proc) return (__eglMustCastToProperFunctionPointerType)proc;
-
-    return NULL;
-}
-
-__eglMustCastToProperFunctionPointerType eglGetProcAddress(const char *procname)
-{
-    // eglGetProcAddress() could be the very first function called
-    // in which case we must make sure we've initialized ourselves, this
-    // happens the first time egl_get_display() is called.
-
-    clearError();
-
-    if (egl_init_drivers() == EGL_FALSE) {
-        setError(EGL_BAD_PARAMETER, NULL);
-        return  NULL;
-    }
-
-    if (FILTER_EXTENSIONS(procname)) {
-        return NULL;
-    }
-
-    __eglMustCastToProperFunctionPointerType addr;
-    addr = findProcAddress(procname, sExtensionMap, NELEM(sExtensionMap));
-    if (addr) return addr;
-
-    addr = findBuiltinWrapper(procname);
-    if (addr) return addr;
-
-    // this protects accesses to sGLExtentionMap and sGLExtentionSlot
-    pthread_mutex_lock(&sExtensionMapMutex);
-
-        /*
-         * Since eglGetProcAddress() is not associated to anything, it needs
-         * to return a function pointer that "works" regardless of what
-         * the current context is.
-         *
-         * For this reason, we return a "forwarder", a small stub that takes
-         * care of calling the function associated with the context
-         * currently bound.
-         *
-         * We first look for extensions we've already resolved, if we're seeing
-         * this extension for the first time, we go through all our
-         * implementations and call eglGetProcAddress() and record the
-         * result in the appropriate implementation hooks and return the
-         * address of the forwarder corresponding to that hook set.
-         *
-         */
-
-        const String8 name(procname);
-        addr = sGLExtentionMap.valueFor(name);
-        const int slot = sGLExtentionSlot;
-
-        ALOGE_IF(slot >= MAX_NUMBER_OF_GL_EXTENSIONS,
-                "no more slots for eglGetProcAddress(\"%s\")",
-                procname);
-
-        if (!addr && (slot < MAX_NUMBER_OF_GL_EXTENSIONS)) {
-            bool found = false;
-
-            egl_connection_t* const cnx = &gEGLImpl;
-            if (cnx->dso && cnx->egl.eglGetProcAddress) {
-                // Extensions are independent of the bound context
-                addr =
-                cnx->hooks[egl_connection_t::GLESv1_INDEX]->ext.extensions[slot] =
-                cnx->hooks[egl_connection_t::GLESv2_INDEX]->ext.extensions[slot] =
-                        cnx->egl.eglGetProcAddress(procname);
-                if (addr) found = true;
-            }
-
-            if (found) {
-                addr = gExtensionForwarders[slot];
-                sGLExtentionMap.add(name, addr);
-                sGLExtentionSlot++;
-            }
-        }
-
-    pthread_mutex_unlock(&sExtensionMapMutex);
-    return addr;
-}
-
-class FrameCompletionThread : public Thread {
-public:
-
-    static void queueSync(EGLSyncKHR sync) {
-        static sp<FrameCompletionThread> thread(new FrameCompletionThread);
-        static bool running = false;
-        if (!running) {
-            thread->run("GPUFrameCompletion");
-            running = true;
-        }
-        {
-            Mutex::Autolock lock(thread->mMutex);
-            ScopedTrace st(ATRACE_TAG, String8::format("kicked off frame %d",
-                    thread->mFramesQueued).string());
-            thread->mQueue.push_back(sync);
-            thread->mCondition.signal();
-            thread->mFramesQueued++;
-            ATRACE_INT("GPU Frames Outstanding", thread->mQueue.size());
-        }
-    }
-
-private:
-    FrameCompletionThread() : mFramesQueued(0), mFramesCompleted(0) {}
-
-    virtual bool threadLoop() {
-        EGLSyncKHR sync;
-        uint32_t frameNum;
-        {
-            Mutex::Autolock lock(mMutex);
-            while (mQueue.isEmpty()) {
-                mCondition.wait(mMutex);
-            }
-            sync = mQueue[0];
-            frameNum = mFramesCompleted;
-        }
-        EGLDisplay dpy = eglGetDisplay(EGL_DEFAULT_DISPLAY);
-        {
-            ScopedTrace st(ATRACE_TAG, String8::format("waiting for frame %d",
-                    frameNum).string());
-            EGLint result = eglClientWaitSyncKHR(dpy, sync, 0, EGL_FOREVER_KHR);
-            if (result == EGL_FALSE) {
-                ALOGE("FrameCompletion: error waiting for fence: %#x", eglGetError());
-            } else if (result == EGL_TIMEOUT_EXPIRED_KHR) {
-                ALOGE("FrameCompletion: timeout waiting for fence");
-            }
-            eglDestroySyncKHR(dpy, sync);
-        }
-        {
-            Mutex::Autolock lock(mMutex);
-            mQueue.removeAt(0);
-            mFramesCompleted++;
-            ATRACE_INT("GPU Frames Outstanding", mQueue.size());
-        }
-        return true;
-    }
-
-    uint32_t mFramesQueued;
-    uint32_t mFramesCompleted;
-    Vector<EGLSyncKHR> mQueue;
-    Condition mCondition;
-    Mutex mMutex;
-};
-
-EGLBoolean eglSwapBuffersWithDamageKHR(EGLDisplay dpy, EGLSurface draw,
-        EGLint *rects, EGLint n_rects)
-{
-    ATRACE_CALL();
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    SurfaceRef _s(dp.get(), draw);
-    if (!_s.get())
-        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-
-    egl_surface_t const * const s = get_surface(draw);
-
-    if (CC_UNLIKELY(dp->traceGpuCompletion)) {
-        EGLSyncKHR sync = eglCreateSyncKHR(dpy, EGL_SYNC_FENCE_KHR, NULL);
-        if (sync != EGL_NO_SYNC_KHR) {
-            FrameCompletionThread::queueSync(sync);
-        }
-    }
-
-    if (CC_UNLIKELY(dp->finishOnSwap)) {
-        uint32_t pixel;
-        egl_context_t * const c = get_context( egl_tls_t::getContext() );
-        if (c) {
-            // glReadPixels() ensures that the frame is complete
-            s->cnx->hooks[c->version]->gl.glReadPixels(0,0,1,1,
-                    GL_RGBA,GL_UNSIGNED_BYTE,&pixel);
-        }
-    }
-
-    if (n_rects == 0) {
-        return s->cnx->egl.eglSwapBuffers(dp->disp.dpy, s->surface);
-    }
-
-    Vector<android_native_rect_t> androidRects;
-    for (int r = 0; r < n_rects; ++r) {
-        int offset = r * 4;
-        int x = rects[offset];
-        int y = rects[offset + 1];
-        int width = rects[offset + 2];
-        int height = rects[offset + 3];
-        android_native_rect_t androidRect;
-        androidRect.left = x;
-        androidRect.top = y + height;
-        androidRect.right = x + width;
-        androidRect.bottom = y;
-        androidRects.push_back(androidRect);
-    }
-    native_window_set_surface_damage(s->win.get(), androidRects.array(),
-            androidRects.size());
-
-    if (s->cnx->egl.eglSwapBuffersWithDamageKHR) {
-        return s->cnx->egl.eglSwapBuffersWithDamageKHR(dp->disp.dpy, s->surface,
-                rects, n_rects);
-    } else {
-        return s->cnx->egl.eglSwapBuffers(dp->disp.dpy, s->surface);
-    }
-}
-
-EGLBoolean eglSwapBuffers(EGLDisplay dpy, EGLSurface surface)
-{
-    return eglSwapBuffersWithDamageKHR(dpy, surface, NULL, 0);
-}
-
-EGLBoolean eglCopyBuffers(  EGLDisplay dpy, EGLSurface surface,
-                            NativePixmapType target)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    SurfaceRef _s(dp.get(), surface);
-    if (!_s.get())
-        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-
-    egl_surface_t const * const s = get_surface(surface);
-    return s->cnx->egl.eglCopyBuffers(dp->disp.dpy, s->surface, target);
-}
-
-const char* eglQueryString(EGLDisplay dpy, EGLint name)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return (const char *) NULL;
-
-    switch (name) {
-        case EGL_VENDOR:
-            return dp->getVendorString();
-        case EGL_VERSION:
-            return dp->getVersionString();
-        case EGL_EXTENSIONS:
-            return dp->getExtensionString();
-        case EGL_CLIENT_APIS:
-            return dp->getClientApiString();
-    }
-    return setError(EGL_BAD_PARAMETER, (const char *)0);
-}
-
-EGLAPI const char* eglQueryStringImplementationANDROID(EGLDisplay dpy, EGLint name)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return (const char *) NULL;
-
-    switch (name) {
-        case EGL_VENDOR:
-            return dp->disp.queryString.vendor;
-        case EGL_VERSION:
-            return dp->disp.queryString.version;
-        case EGL_EXTENSIONS:
-            return dp->disp.queryString.extensions;
-        case EGL_CLIENT_APIS:
-            return dp->disp.queryString.clientApi;
-    }
-    return setError(EGL_BAD_PARAMETER, (const char *)0);
-}
-
-// ----------------------------------------------------------------------------
-// EGL 1.1
-// ----------------------------------------------------------------------------
-
-EGLBoolean eglSurfaceAttrib(
-        EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint value)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    SurfaceRef _s(dp.get(), surface);
-    if (!_s.get())
-        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-
-    egl_surface_t * const s = get_surface(surface);
-
-    if (attribute == EGL_FRONT_BUFFER_AUTO_REFRESH_ANDROID) {
-        int err = native_window_set_auto_refresh(s->win.get(),
-            value ? true : false);
-        return (err == NO_ERROR) ? EGL_TRUE :
-            setError(EGL_BAD_SURFACE, EGL_FALSE);
-    }
-
-#if ENABLE_EGL_ANDROID_GET_FRAME_TIMESTAMPS
-    if (attribute == EGL_TIMESTAMPS_ANDROID) {
-        s->enableTimestamps = value;
-        return EGL_TRUE;
-    }
-#endif
-
-    if (s->cnx->egl.eglSurfaceAttrib) {
-        return s->cnx->egl.eglSurfaceAttrib(
-                dp->disp.dpy, s->surface, attribute, value);
-    }
-    return setError(EGL_BAD_SURFACE, EGL_FALSE);
-}
-
-EGLBoolean eglBindTexImage(
-        EGLDisplay dpy, EGLSurface surface, EGLint buffer)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    SurfaceRef _s(dp.get(), surface);
-    if (!_s.get())
-        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-
-    egl_surface_t const * const s = get_surface(surface);
-    if (s->cnx->egl.eglBindTexImage) {
-        return s->cnx->egl.eglBindTexImage(
-                dp->disp.dpy, s->surface, buffer);
-    }
-    return setError(EGL_BAD_SURFACE, EGL_FALSE);
-}
-
-EGLBoolean eglReleaseTexImage(
-        EGLDisplay dpy, EGLSurface surface, EGLint buffer)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    SurfaceRef _s(dp.get(), surface);
-    if (!_s.get())
-        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-
-    egl_surface_t const * const s = get_surface(surface);
-    if (s->cnx->egl.eglReleaseTexImage) {
-        return s->cnx->egl.eglReleaseTexImage(
-                dp->disp.dpy, s->surface, buffer);
-    }
-    return setError(EGL_BAD_SURFACE, EGL_FALSE);
-}
-
-EGLBoolean eglSwapInterval(EGLDisplay dpy, EGLint interval)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    EGLBoolean res = EGL_TRUE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglSwapInterval) {
-        res = cnx->egl.eglSwapInterval(dp->disp.dpy, interval);
-    }
-
-    return res;
-}
-
-
-// ----------------------------------------------------------------------------
-// EGL 1.2
-// ----------------------------------------------------------------------------
-
-EGLBoolean eglWaitClient(void)
-{
-    clearError();
-
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (!cnx->dso)
-        return setError(EGL_BAD_CONTEXT, EGL_FALSE);
-
-    EGLBoolean res;
-    if (cnx->egl.eglWaitClient) {
-        res = cnx->egl.eglWaitClient();
-    } else {
-        res = cnx->egl.eglWaitGL();
-    }
-    return res;
-}
-
-EGLBoolean eglBindAPI(EGLenum api)
-{
-    clearError();
-
-    if (egl_init_drivers() == EGL_FALSE) {
-        return setError(EGL_BAD_PARAMETER, EGL_FALSE);
-    }
-
-    // bind this API on all EGLs
-    EGLBoolean res = EGL_TRUE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglBindAPI) {
-        res = cnx->egl.eglBindAPI(api);
-    }
-    return res;
-}
-
-EGLenum eglQueryAPI(void)
-{
-    clearError();
-
-    if (egl_init_drivers() == EGL_FALSE) {
-        return setError(EGL_BAD_PARAMETER, EGL_FALSE);
-    }
-
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglQueryAPI) {
-        return cnx->egl.eglQueryAPI();
-    }
-
-    // or, it can only be OpenGL ES
-    return EGL_OPENGL_ES_API;
-}
-
-EGLBoolean eglReleaseThread(void)
-{
-    clearError();
-
-    // If there is context bound to the thread, release it
-    egl_display_t::loseCurrent(get_context(getContext()));
-
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglReleaseThread) {
-        cnx->egl.eglReleaseThread();
-    }
-    egl_tls_t::clearTLS();
-    return EGL_TRUE;
-}
-
-EGLSurface eglCreatePbufferFromClientBuffer(
-          EGLDisplay dpy, EGLenum buftype, EGLClientBuffer buffer,
-          EGLConfig config, const EGLint *attrib_list)
-{
-    clearError();
-
-    egl_connection_t* cnx = NULL;
-    const egl_display_ptr dp = validate_display_connection(dpy, cnx);
-    if (!dp) return EGL_FALSE;
-    if (cnx->egl.eglCreatePbufferFromClientBuffer) {
-        return cnx->egl.eglCreatePbufferFromClientBuffer(
-                dp->disp.dpy, buftype, buffer, config, attrib_list);
-    }
-    return setError(EGL_BAD_CONFIG, EGL_NO_SURFACE);
-}
-
-// ----------------------------------------------------------------------------
-// EGL_EGLEXT_VERSION 3
-// ----------------------------------------------------------------------------
-
-EGLBoolean eglLockSurfaceKHR(EGLDisplay dpy, EGLSurface surface,
-        const EGLint *attrib_list)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    SurfaceRef _s(dp.get(), surface);
-    if (!_s.get())
-        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-
-    egl_surface_t const * const s = get_surface(surface);
-    if (s->cnx->egl.eglLockSurfaceKHR) {
-        return s->cnx->egl.eglLockSurfaceKHR(
-                dp->disp.dpy, s->surface, attrib_list);
-    }
-    return setError(EGL_BAD_DISPLAY, EGL_FALSE);
-}
-
-EGLBoolean eglUnlockSurfaceKHR(EGLDisplay dpy, EGLSurface surface)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    SurfaceRef _s(dp.get(), surface);
-    if (!_s.get())
-        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-
-    egl_surface_t const * const s = get_surface(surface);
-    if (s->cnx->egl.eglUnlockSurfaceKHR) {
-        return s->cnx->egl.eglUnlockSurfaceKHR(dp->disp.dpy, s->surface);
-    }
-    return setError(EGL_BAD_DISPLAY, EGL_FALSE);
-}
-
-EGLImageKHR eglCreateImageKHR(EGLDisplay dpy, EGLContext ctx, EGLenum target,
-        EGLClientBuffer buffer, const EGLint *attrib_list)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_NO_IMAGE_KHR;
-
-    ContextRef _c(dp.get(), ctx);
-    egl_context_t * const c = _c.get();
-
-    EGLImageKHR result = EGL_NO_IMAGE_KHR;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglCreateImageKHR) {
-        result = cnx->egl.eglCreateImageKHR(
-                dp->disp.dpy,
-                c ? c->context : EGL_NO_CONTEXT,
-                target, buffer, attrib_list);
-    }
-    return result;
-}
-
-EGLBoolean eglDestroyImageKHR(EGLDisplay dpy, EGLImageKHR img)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    EGLBoolean result = EGL_FALSE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglDestroyImageKHR) {
-        result = cnx->egl.eglDestroyImageKHR(dp->disp.dpy, img);
-    }
-    return result;
-}
-
-// ----------------------------------------------------------------------------
-// EGL_EGLEXT_VERSION 5
-// ----------------------------------------------------------------------------
-
-
-EGLSyncKHR eglCreateSyncKHR(EGLDisplay dpy, EGLenum type, const EGLint *attrib_list)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_NO_SYNC_KHR;
-
-    EGLSyncKHR result = EGL_NO_SYNC_KHR;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglCreateSyncKHR) {
-        result = cnx->egl.eglCreateSyncKHR(dp->disp.dpy, type, attrib_list);
-    }
-    return result;
-}
-
-EGLBoolean eglDestroySyncKHR(EGLDisplay dpy, EGLSyncKHR sync)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    EGLBoolean result = EGL_FALSE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglDestroySyncKHR) {
-        result = cnx->egl.eglDestroySyncKHR(dp->disp.dpy, sync);
-    }
-    return result;
-}
-
-EGLBoolean eglSignalSyncKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLenum mode) {
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    EGLBoolean result = EGL_FALSE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglSignalSyncKHR) {
-        result = cnx->egl.eglSignalSyncKHR(
-                dp->disp.dpy, sync, mode);
-    }
-    return result;
-}
-
-EGLint eglClientWaitSyncKHR(EGLDisplay dpy, EGLSyncKHR sync,
-        EGLint flags, EGLTimeKHR timeout)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    EGLBoolean result = EGL_FALSE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglClientWaitSyncKHR) {
-        result = cnx->egl.eglClientWaitSyncKHR(
-                dp->disp.dpy, sync, flags, timeout);
-    }
-    return result;
-}
-
-EGLBoolean eglGetSyncAttribKHR(EGLDisplay dpy, EGLSyncKHR sync,
-        EGLint attribute, EGLint *value)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    EGLBoolean result = EGL_FALSE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglGetSyncAttribKHR) {
-        result = cnx->egl.eglGetSyncAttribKHR(
-                dp->disp.dpy, sync, attribute, value);
-    }
-    return result;
-}
-
-EGLStreamKHR eglCreateStreamKHR(EGLDisplay dpy, const EGLint *attrib_list)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_NO_STREAM_KHR;
-
-    EGLStreamKHR result = EGL_NO_STREAM_KHR;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglCreateStreamKHR) {
-        result = cnx->egl.eglCreateStreamKHR(
-                dp->disp.dpy, attrib_list);
-    }
-    return result;
-}
-
-EGLBoolean eglDestroyStreamKHR(EGLDisplay dpy, EGLStreamKHR stream)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    EGLBoolean result = EGL_FALSE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglDestroyStreamKHR) {
-        result = cnx->egl.eglDestroyStreamKHR(
-                dp->disp.dpy, stream);
-    }
-    return result;
-}
-
-EGLBoolean eglStreamAttribKHR(EGLDisplay dpy, EGLStreamKHR stream,
-        EGLenum attribute, EGLint value)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    EGLBoolean result = EGL_FALSE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglStreamAttribKHR) {
-        result = cnx->egl.eglStreamAttribKHR(
-                dp->disp.dpy, stream, attribute, value);
-    }
-    return result;
-}
-
-EGLBoolean eglQueryStreamKHR(EGLDisplay dpy, EGLStreamKHR stream,
-        EGLenum attribute, EGLint *value)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    EGLBoolean result = EGL_FALSE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglQueryStreamKHR) {
-        result = cnx->egl.eglQueryStreamKHR(
-                dp->disp.dpy, stream, attribute, value);
-    }
-    return result;
-}
-
-EGLBoolean eglQueryStreamu64KHR(EGLDisplay dpy, EGLStreamKHR stream,
-        EGLenum attribute, EGLuint64KHR *value)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    EGLBoolean result = EGL_FALSE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglQueryStreamu64KHR) {
-        result = cnx->egl.eglQueryStreamu64KHR(
-                dp->disp.dpy, stream, attribute, value);
-    }
-    return result;
-}
-
-EGLBoolean eglQueryStreamTimeKHR(EGLDisplay dpy, EGLStreamKHR stream,
-        EGLenum attribute, EGLTimeKHR *value)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    EGLBoolean result = EGL_FALSE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglQueryStreamTimeKHR) {
-        result = cnx->egl.eglQueryStreamTimeKHR(
-                dp->disp.dpy, stream, attribute, value);
-    }
-    return result;
-}
-
-EGLSurface eglCreateStreamProducerSurfaceKHR(EGLDisplay dpy, EGLConfig config,
-        EGLStreamKHR stream, const EGLint *attrib_list)
-{
-    clearError();
-
-    egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_NO_SURFACE;
-
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglCreateStreamProducerSurfaceKHR) {
-        EGLSurface surface = cnx->egl.eglCreateStreamProducerSurfaceKHR(
-                dp->disp.dpy, config, stream, attrib_list);
-        if (surface != EGL_NO_SURFACE) {
-            egl_surface_t* s = new egl_surface_t(dp.get(), config, NULL,
-                    surface, cnx);
-            return s;
-        }
-    }
-    return EGL_NO_SURFACE;
-}
-
-EGLBoolean eglStreamConsumerGLTextureExternalKHR(EGLDisplay dpy,
-        EGLStreamKHR stream)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    EGLBoolean result = EGL_FALSE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglStreamConsumerGLTextureExternalKHR) {
-        result = cnx->egl.eglStreamConsumerGLTextureExternalKHR(
-                dp->disp.dpy, stream);
-    }
-    return result;
-}
-
-EGLBoolean eglStreamConsumerAcquireKHR(EGLDisplay dpy,
-        EGLStreamKHR stream)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    EGLBoolean result = EGL_FALSE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglStreamConsumerAcquireKHR) {
-        result = cnx->egl.eglStreamConsumerAcquireKHR(
-                dp->disp.dpy, stream);
-    }
-    return result;
-}
-
-EGLBoolean eglStreamConsumerReleaseKHR(EGLDisplay dpy,
-        EGLStreamKHR stream)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    EGLBoolean result = EGL_FALSE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglStreamConsumerReleaseKHR) {
-        result = cnx->egl.eglStreamConsumerReleaseKHR(
-                dp->disp.dpy, stream);
-    }
-    return result;
-}
-
-EGLNativeFileDescriptorKHR eglGetStreamFileDescriptorKHR(
-        EGLDisplay dpy, EGLStreamKHR stream)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_NO_FILE_DESCRIPTOR_KHR;
-
-    EGLNativeFileDescriptorKHR result = EGL_NO_FILE_DESCRIPTOR_KHR;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglGetStreamFileDescriptorKHR) {
-        result = cnx->egl.eglGetStreamFileDescriptorKHR(
-                dp->disp.dpy, stream);
-    }
-    return result;
-}
-
-EGLStreamKHR eglCreateStreamFromFileDescriptorKHR(
-        EGLDisplay dpy, EGLNativeFileDescriptorKHR file_descriptor)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_NO_STREAM_KHR;
-
-    EGLStreamKHR result = EGL_NO_STREAM_KHR;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglCreateStreamFromFileDescriptorKHR) {
-        result = cnx->egl.eglCreateStreamFromFileDescriptorKHR(
-                dp->disp.dpy, file_descriptor);
-    }
-    return result;
-}
-
-// ----------------------------------------------------------------------------
-// EGL_EGLEXT_VERSION 15
-// ----------------------------------------------------------------------------
-
-EGLint eglWaitSyncKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLint flags) {
-    clearError();
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-    EGLint result = EGL_FALSE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglWaitSyncKHR) {
-        result = cnx->egl.eglWaitSyncKHR(dp->disp.dpy, sync, flags);
-    }
-    return result;
-}
-
-// ----------------------------------------------------------------------------
-// ANDROID extensions
-// ----------------------------------------------------------------------------
-
-EGLint eglDupNativeFenceFDANDROID(EGLDisplay dpy, EGLSyncKHR sync)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_NO_NATIVE_FENCE_FD_ANDROID;
-
-    EGLint result = EGL_NO_NATIVE_FENCE_FD_ANDROID;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglDupNativeFenceFDANDROID) {
-        result = cnx->egl.eglDupNativeFenceFDANDROID(dp->disp.dpy, sync);
-    }
-    return result;
-}
-
-EGLBoolean eglPresentationTimeANDROID(EGLDisplay dpy, EGLSurface surface,
-        EGLnsecsANDROID time)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) {
-        return EGL_FALSE;
-    }
-
-    SurfaceRef _s(dp.get(), surface);
-    if (!_s.get()) {
-        setError(EGL_BAD_SURFACE, EGL_FALSE);
-        return EGL_FALSE;
-    }
-
-    egl_surface_t const * const s = get_surface(surface);
-    native_window_set_buffers_timestamp(s->win.get(), time);
-
-    return EGL_TRUE;
-}
-
-EGLClientBuffer eglCreateNativeClientBufferANDROID(const EGLint *attrib_list)
-{
-    clearError();
-
-    int usage = 0;
-    uint32_t width = 0;
-    uint32_t height = 0;
-    uint32_t format = 0;
-    uint32_t red_size = 0;
-    uint32_t green_size = 0;
-    uint32_t blue_size = 0;
-    uint32_t alpha_size = 0;
-
-#define GET_NONNEGATIVE_VALUE(case_name, target) \
-    case case_name: \
-        if (value >= 0) { \
-            target = value; \
-        } else { \
-            return setError(EGL_BAD_PARAMETER, (EGLClientBuffer)0); \
-        } \
-        break
-
-    if (attrib_list) {
-        while (*attrib_list != EGL_NONE) {
-            GLint attr = *attrib_list++;
-            GLint value = *attrib_list++;
-            switch (attr) {
-                GET_NONNEGATIVE_VALUE(EGL_WIDTH, width);
-                GET_NONNEGATIVE_VALUE(EGL_HEIGHT, height);
-                GET_NONNEGATIVE_VALUE(EGL_RED_SIZE, red_size);
-                GET_NONNEGATIVE_VALUE(EGL_GREEN_SIZE, green_size);
-                GET_NONNEGATIVE_VALUE(EGL_BLUE_SIZE, blue_size);
-                GET_NONNEGATIVE_VALUE(EGL_ALPHA_SIZE, alpha_size);
-                case EGL_NATIVE_BUFFER_USAGE_ANDROID:
-                    if (value & EGL_NATIVE_BUFFER_USAGE_PROTECTED_BIT_ANDROID) {
-                        usage |= GRALLOC_USAGE_PROTECTED;
-                    }
-                    if (value & EGL_NATIVE_BUFFER_USAGE_RENDERBUFFER_BIT_ANDROID) {
-                        usage |= GRALLOC_USAGE_HW_RENDER;
-                    }
-                    if (value & EGL_NATIVE_BUFFER_USAGE_TEXTURE_BIT_ANDROID) {
-                        usage |= GRALLOC_USAGE_HW_TEXTURE;
-                    }
-                    break;
-                default:
-                    return setError(EGL_BAD_PARAMETER, (EGLClientBuffer)0);
-            }
-        }
-    }
-#undef GET_NONNEGATIVE_VALUE
-
-    // Validate format.
-    if (red_size == 8 && green_size == 8 && blue_size == 8) {
-        if (alpha_size == 8) {
-            format = HAL_PIXEL_FORMAT_RGBA_8888;
-        } else {
-            format = HAL_PIXEL_FORMAT_RGB_888;
-        }
-    } else if (red_size == 5 && green_size == 6 && blue_size == 5 &&
-               alpha_size == 0) {
-        format = HAL_PIXEL_FORMAT_RGB_565;
-    } else {
-        ALOGE("Invalid native pixel format { r=%d, g=%d, b=%d, a=%d }",
-                red_size, green_size, blue_size, alpha_size);
-        return setError(EGL_BAD_PARAMETER, (EGLClientBuffer)0);
-    }
-
-#define CHECK_ERROR_CONDITION(message) \
-    if (err != NO_ERROR) { \
-        ALOGE(message); \
-        goto error_condition; \
-    }
-
-    // The holder is used to destroy the buffer if an error occurs.
-    GraphicBuffer* gBuffer = new GraphicBuffer();
-    sp<IServiceManager> sm = defaultServiceManager();
-    sp<IBinder> surfaceFlinger = sm->getService(String16("SurfaceFlinger"));
-    sp<IBinder> allocator;
-    Parcel sc_data, sc_reply, data, reply;
-    status_t err = NO_ERROR;
-    if (sm == NULL) {
-        ALOGE("Unable to connect to ServiceManager");
-        goto error_condition;
-    }
-
-    // Obtain an allocator.
-    if (surfaceFlinger == NULL) {
-        ALOGE("Unable to connect to SurfaceFlinger");
-        goto error_condition;
-    }
-    sc_data.writeInterfaceToken(String16("android.ui.ISurfaceComposer"));
-    err = surfaceFlinger->transact(
-            BnSurfaceComposer::CREATE_GRAPHIC_BUFFER_ALLOC, sc_data, &sc_reply);
-    CHECK_ERROR_CONDITION("Unable to obtain allocator from SurfaceFlinger");
-    allocator = sc_reply.readStrongBinder();
-
-    if (allocator == NULL) {
-        ALOGE("Unable to obtain an ISurfaceComposer");
-        goto error_condition;
-    }
-    data.writeInterfaceToken(String16("android.ui.IGraphicBufferAlloc"));
-    err = data.writeUint32(width);
-    CHECK_ERROR_CONDITION("Unable to write width");
-    err = data.writeUint32(height);
-    CHECK_ERROR_CONDITION("Unable to write height");
-    err = data.writeInt32(static_cast<int32_t>(format));
-    CHECK_ERROR_CONDITION("Unable to write format");
-    err = data.writeUint32(usage);
-    CHECK_ERROR_CONDITION("Unable to write usage");
-    err = data.writeUtf8AsUtf16(
-            std::string("[eglCreateNativeClientBufferANDROID pid ") +
-            std::to_string(getpid()) + ']');
-    CHECK_ERROR_CONDITION("Unable to write requestor name");
-    err = allocator->transact(IBinder::FIRST_CALL_TRANSACTION, data,
-            &reply);
-    CHECK_ERROR_CONDITION(
-            "Unable to request buffer allocation from surface composer");
-    err = reply.readInt32();
-    CHECK_ERROR_CONDITION("Unable to obtain buffer from surface composer");
-    err = reply.read(*gBuffer);
-    CHECK_ERROR_CONDITION("Unable to read buffer from surface composer");
-
-    err = gBuffer->initCheck();
-    if (err != NO_ERROR) {
-        ALOGE("Unable to create native buffer { w=%d, h=%d, f=%d, u=%#x }: %#x",
-                width, height, format, usage, err);
-        goto error_condition;
-    }
-    ALOGD("Created new native buffer %p { w=%d, h=%d, f=%d, u=%#x }",
-            gBuffer, width, height, format, usage);
-    return static_cast<EGLClientBuffer>(gBuffer->getNativeBuffer());
-
-#undef CHECK_ERROR_CONDITION
-
-error_condition:
-    // Delete the buffer.
-    sp<GraphicBuffer> holder(gBuffer);
-    return setError(EGL_BAD_ALLOC, (EGLClientBuffer)0);
-}
-
-// ----------------------------------------------------------------------------
-// NVIDIA extensions
-// ----------------------------------------------------------------------------
-EGLuint64NV eglGetSystemTimeFrequencyNV()
-{
-    clearError();
-
-    if (egl_init_drivers() == EGL_FALSE) {
-        return setError(EGL_BAD_PARAMETER, EGL_FALSE);
-    }
-
-    EGLuint64NV ret = 0;
-    egl_connection_t* const cnx = &gEGLImpl;
-
-    if (cnx->dso && cnx->egl.eglGetSystemTimeFrequencyNV) {
-        return cnx->egl.eglGetSystemTimeFrequencyNV();
-    }
-
-    return setErrorQuiet(EGL_BAD_DISPLAY, 0);
-}
-
-EGLuint64NV eglGetSystemTimeNV()
-{
-    clearError();
-
-    if (egl_init_drivers() == EGL_FALSE) {
-        return setError(EGL_BAD_PARAMETER, EGL_FALSE);
-    }
-
-    EGLuint64NV ret = 0;
-    egl_connection_t* const cnx = &gEGLImpl;
-
-    if (cnx->dso && cnx->egl.eglGetSystemTimeNV) {
-        return cnx->egl.eglGetSystemTimeNV();
-    }
-
-    return setErrorQuiet(EGL_BAD_DISPLAY, 0);
-}
-
-// ----------------------------------------------------------------------------
-// Partial update extension
-// ----------------------------------------------------------------------------
-EGLBoolean eglSetDamageRegionKHR(EGLDisplay dpy, EGLSurface surface,
-        EGLint *rects, EGLint n_rects)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) {
-        setError(EGL_BAD_DISPLAY, EGL_FALSE);
-        return EGL_FALSE;
-    }
-
-    SurfaceRef _s(dp.get(), surface);
-    if (!_s.get()) {
-        setError(EGL_BAD_SURFACE, EGL_FALSE);
-        return EGL_FALSE;
-    }
-
-    egl_surface_t const * const s = get_surface(surface);
-    if (s->cnx->egl.eglSetDamageRegionKHR) {
-        return s->cnx->egl.eglSetDamageRegionKHR(dp->disp.dpy, s->surface,
-                rects, n_rects);
-    }
-
-    return EGL_FALSE;
-}
-
-EGLBoolean eglGetFrameTimestampsANDROID(EGLDisplay dpy, EGLSurface surface,
-        EGLint framesAgo, EGLint numTimestamps, const EGLint *timestamps,
-        EGLnsecsANDROID *values)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) {
-        setError(EGL_BAD_DISPLAY, EGL_FALSE);
-        return EGL_FALSE;
-    }
-
-    SurfaceRef _s(dp.get(), surface);
-    if (!_s.get()) {
-        setError(EGL_BAD_SURFACE, EGL_FALSE);
-        return EGL_FALSE;
-    }
-
-    egl_surface_t const * const s = get_surface(surface);
-
-    if (!s->enableTimestamps) {
-        setError(EGL_BAD_SURFACE, EGL_FALSE);
-        return EGL_FALSE;
-    }
-
-    nsecs_t* postedTime = nullptr;
-    nsecs_t* acquireTime = nullptr;
-    nsecs_t* refreshStartTime = nullptr;
-    nsecs_t* GLCompositionDoneTime = nullptr;
-    nsecs_t* displayRetireTime = nullptr;
-    nsecs_t* releaseTime = nullptr;
-
-    for (int i = 0; i < numTimestamps; i++) {
-        switch (timestamps[i]) {
-            case EGL_QUEUE_TIME_ANDROID:
-                postedTime = &values[i];
-                break;
-            case EGL_RENDERING_COMPLETE_TIME_ANDROID:
-                acquireTime = &values[i];
-                break;
-            case EGL_COMPOSITION_START_TIME_ANDROID:
-                refreshStartTime = &values[i];
-                break;
-            case EGL_COMPOSITION_FINISHED_TIME_ANDROID:
-                GLCompositionDoneTime = &values[i];
-                break;
-            case EGL_DISPLAY_RETIRE_TIME_ANDROID:
-                displayRetireTime = &values[i];
-                break;
-            case EGL_READS_DONE_TIME_ANDROID:
-                releaseTime = &values[i];
-                break;
-            default:
-                setError(EGL_BAD_PARAMETER, EGL_FALSE);
-                return EGL_FALSE;
-        }
-    }
-
-    status_t ret = native_window_get_frame_timestamps(s->win.get(), framesAgo,
-            postedTime, acquireTime, refreshStartTime, GLCompositionDoneTime,
-            displayRetireTime, releaseTime);
-
-    if (ret != NO_ERROR) {
-        setError(EGL_BAD_ACCESS, EGL_FALSE);
-        return EGL_FALSE;
-    }
-
-    return EGL_TRUE;
-}
-
-EGLBoolean eglQueryTimestampSupportedANDROID(EGLDisplay dpy, EGLSurface surface,
-        EGLint timestamp)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) {
-        setError(EGL_BAD_DISPLAY, EGL_FALSE);
-        return EGL_FALSE;
-    }
-
-    SurfaceRef _s(dp.get(), surface);
-    if (!_s.get()) {
-        setError(EGL_BAD_SURFACE, EGL_FALSE);
-        return EGL_FALSE;
-    }
-
-    switch (timestamp) {
-#if ENABLE_EGL_ANDROID_GET_FRAME_TIMESTAMPS
-        case EGL_QUEUE_TIME_ANDROID:
-        case EGL_RENDERING_COMPLETE_TIME_ANDROID:
-        case EGL_COMPOSITION_START_TIME_ANDROID:
-        case EGL_COMPOSITION_FINISHED_TIME_ANDROID:
-        case EGL_DISPLAY_RETIRE_TIME_ANDROID:
-        case EGL_READS_DONE_TIME_ANDROID:
-            return EGL_TRUE;
-#endif
-        default:
-            return EGL_FALSE;
-    }
-}
diff -Naur frameworksRaw/native/opengl/libs/EGL/eglApi.cpp.orig.orig.orig frameworksModified/native/opengl/libs/EGL/eglApi.cpp.orig.orig.orig
--- frameworksRaw/native/opengl/libs/EGL/eglApi.cpp.orig.orig.orig	2017-07-06 15:34:21.314456285 +0530
+++ frameworksModified/native/opengl/libs/EGL/eglApi.cpp.orig.orig.orig	1970-01-01 05:30:00.000000000 +0530
@@ -1,2117 +0,0 @@
-/*
- ** Copyright 2007, The Android Open Source Project
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-#define ATRACE_TAG ATRACE_TAG_GRAPHICS
-
-#include <dlfcn.h>
-#include <ctype.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include <hardware/gralloc.h>
-#include <system/window.h>
-
-#include <EGL/egl.h>
-#include <EGL/eglext.h>
-
-#include <cutils/log.h>
-#include <cutils/atomic.h>
-#include <cutils/compiler.h>
-#include <cutils/properties.h>
-#include <cutils/memory.h>
-
-#include <gui/ISurfaceComposer.h>
-
-#include <ui/GraphicBuffer.h>
-
-#include <utils/KeyedVector.h>
-#include <utils/SortedVector.h>
-#include <utils/String8.h>
-#include <utils/Trace.h>
-
-#include "binder/Binder.h"
-#include "binder/Parcel.h"
-#include "binder/IServiceManager.h"
-
-#include "../egl_impl.h"
-#include "../hooks.h"
-
-#include "egl_display.h"
-#include "egl_object.h"
-#include "egl_tls.h"
-#include "egldefs.h"
-
-using namespace android;
-
-// This extension has not been ratified yet, so can't be shipped.
-// Implementation is incomplete and untested.
-#define ENABLE_EGL_KHR_GL_COLORSPACE 0
-
-#define ENABLE_EGL_ANDROID_GET_FRAME_TIMESTAMPS 0
-
-// ----------------------------------------------------------------------------
-
-namespace android {
-
-struct extention_map_t {
-    const char* name;
-    __eglMustCastToProperFunctionPointerType address;
-};
-
-/*
- * This is the list of EGL extensions exposed to applications.
- *
- * Some of them (gBuiltinExtensionString) are implemented entirely in this EGL
- * wrapper and are always available.
- *
- * The rest (gExtensionString) depend on support in the EGL driver, and are
- * only available if the driver supports them. However, some of these must be
- * supported because they are used by the Android system itself; these are
- * listed as mandatory below and are required by the CDD. The system *assumes*
- * the mandatory extensions are present and may not function properly if some
- * are missing.
- *
- * NOTE: Both strings MUST have a single space as the last character.
- */
-extern char const * const gBuiltinExtensionString =
-        "EGL_KHR_get_all_proc_addresses "
-        "EGL_ANDROID_presentation_time "
-        "EGL_KHR_swap_buffers_with_damage "
-        "EGL_ANDROID_create_native_client_buffer "
-        "EGL_ANDROID_front_buffer_auto_refresh "
-#if ENABLE_EGL_ANDROID_GET_FRAME_TIMESTAMPS
-        "EGL_ANDROID_get_frame_timestamps "
-#endif
-        ;
-extern char const * const gExtensionString  =
-        "EGL_KHR_image "                        // mandatory
-        "EGL_KHR_image_base "                   // mandatory
-        "EGL_KHR_image_pixmap "
-        "EGL_KHR_lock_surface "
-#if (ENABLE_EGL_KHR_GL_COLORSPACE != 0)
-        "EGL_KHR_gl_colorspace "
-#endif
-        "EGL_KHR_gl_texture_2D_image "
-        "EGL_KHR_gl_texture_3D_image "
-        "EGL_KHR_gl_texture_cubemap_image "
-        "EGL_KHR_gl_renderbuffer_image "
-        "EGL_KHR_reusable_sync "
-        "EGL_KHR_fence_sync "
-        "EGL_KHR_create_context "
-        "EGL_KHR_config_attribs "
-        "EGL_KHR_surfaceless_context "
-        "EGL_KHR_stream "
-        "EGL_KHR_stream_fifo "
-        "EGL_KHR_stream_producer_eglsurface "
-        "EGL_KHR_stream_consumer_gltexture "
-        "EGL_KHR_stream_cross_process_fd "
-        "EGL_EXT_create_context_robustness "
-        "EGL_NV_system_time "
-        "EGL_ANDROID_image_native_buffer "      // mandatory
-        "EGL_KHR_wait_sync "                    // strongly recommended
-        "EGL_ANDROID_recordable "               // mandatory
-        "EGL_KHR_partial_update "               // strongly recommended
-        "EGL_EXT_buffer_age "                   // strongly recommended with partial_update
-        "EGL_KHR_create_context_no_error "
-        "EGL_KHR_mutable_render_buffer "
-        "EGL_EXT_yuv_surface "
-        "EGL_EXT_protected_content "
-        ;
-
-// extensions not exposed to applications but used by the ANDROID system
-//      "EGL_ANDROID_blob_cache "               // strongly recommended
-//      "EGL_IMG_hibernate_process "            // optional
-//      "EGL_ANDROID_native_fence_sync "        // strongly recommended
-//      "EGL_ANDROID_framebuffer_target "       // mandatory for HWC 1.1
-//      "EGL_ANDROID_image_crop "               // optional
-
-/*
- * EGL Extensions entry-points exposed to 3rd party applications
- * (keep in sync with gExtensionString above)
- *
- */
-static const extention_map_t sExtensionMap[] = {
-    // EGL_KHR_lock_surface
-    { "eglLockSurfaceKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglLockSurfaceKHR },
-    { "eglUnlockSurfaceKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglUnlockSurfaceKHR },
-
-    // EGL_KHR_image, EGL_KHR_image_base
-    { "eglCreateImageKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglCreateImageKHR },
-    { "eglDestroyImageKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglDestroyImageKHR },
-
-    // EGL_KHR_reusable_sync, EGL_KHR_fence_sync
-    { "eglCreateSyncKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglCreateSyncKHR },
-    { "eglDestroySyncKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglDestroySyncKHR },
-    { "eglClientWaitSyncKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglClientWaitSyncKHR },
-    { "eglSignalSyncKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglSignalSyncKHR },
-    { "eglGetSyncAttribKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglGetSyncAttribKHR },
-
-    // EGL_NV_system_time
-    { "eglGetSystemTimeFrequencyNV",
-            (__eglMustCastToProperFunctionPointerType)&eglGetSystemTimeFrequencyNV },
-    { "eglGetSystemTimeNV",
-            (__eglMustCastToProperFunctionPointerType)&eglGetSystemTimeNV },
-
-    // EGL_KHR_wait_sync
-    { "eglWaitSyncKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglWaitSyncKHR },
-
-    // EGL_ANDROID_presentation_time
-    { "eglPresentationTimeANDROID",
-            (__eglMustCastToProperFunctionPointerType)&eglPresentationTimeANDROID },
-
-    // EGL_KHR_swap_buffers_with_damage
-    { "eglSwapBuffersWithDamageKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglSwapBuffersWithDamageKHR },
-
-    // EGL_ANDROID_native_client_buffer
-    { "eglCreateNativeClientBufferANDROID",
-            (__eglMustCastToProperFunctionPointerType)&eglCreateNativeClientBufferANDROID },
-
-    // EGL_KHR_partial_update
-    { "eglSetDamageRegionKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglSetDamageRegionKHR },
-
-    { "eglCreateStreamKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglCreateStreamKHR },
-    { "eglDestroyStreamKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglDestroyStreamKHR },
-    { "eglStreamAttribKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglStreamAttribKHR },
-    { "eglQueryStreamKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglQueryStreamKHR },
-    { "eglQueryStreamu64KHR",
-            (__eglMustCastToProperFunctionPointerType)&eglQueryStreamu64KHR },
-    { "eglQueryStreamTimeKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglQueryStreamTimeKHR },
-    { "eglCreateStreamProducerSurfaceKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglCreateStreamProducerSurfaceKHR },
-    { "eglStreamConsumerGLTextureExternalKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglStreamConsumerGLTextureExternalKHR },
-    { "eglStreamConsumerAcquireKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglStreamConsumerAcquireKHR },
-    { "eglStreamConsumerReleaseKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglStreamConsumerReleaseKHR },
-    { "eglGetStreamFileDescriptorKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglGetStreamFileDescriptorKHR },
-    { "eglCreateStreamFromFileDescriptorKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglCreateStreamFromFileDescriptorKHR },
-
-    // EGL_ANDROID_get_frame_timestamps
-    { "eglGetFrameTimestampsANDROID",
-            (__eglMustCastToProperFunctionPointerType)&eglGetFrameTimestampsANDROID },
-    { "eglQueryTimestampSupportedANDROID",
-            (__eglMustCastToProperFunctionPointerType)&eglQueryTimestampSupportedANDROID },
-};
-
-/*
- * These extensions entry-points should not be exposed to applications.
- * They're used internally by the Android EGL layer.
- */
-#define FILTER_EXTENSIONS(procname) \
-        (!strcmp((procname), "eglSetBlobCacheFuncsANDROID") ||    \
-         !strcmp((procname), "eglHibernateProcessIMG")      ||    \
-         !strcmp((procname), "eglAwakenProcessIMG")         ||    \
-         !strcmp((procname), "eglDupNativeFenceFDANDROID"))
-
-
-
-// accesses protected by sExtensionMapMutex
-static DefaultKeyedVector<String8, __eglMustCastToProperFunctionPointerType> sGLExtentionMap;
-static int sGLExtentionSlot = 0;
-static pthread_mutex_t sExtensionMapMutex = PTHREAD_MUTEX_INITIALIZER;
-
-static void(*findProcAddress(const char* name,
-        const extention_map_t* map, size_t n))() {
-    for (uint32_t i=0 ; i<n ; i++) {
-        if (!strcmp(name, map[i].name)) {
-            return map[i].address;
-        }
-    }
-    return NULL;
-}
-
-// ----------------------------------------------------------------------------
-
-extern void setGLHooksThreadSpecific(gl_hooks_t const *value);
-extern EGLBoolean egl_init_drivers();
-extern const __eglMustCastToProperFunctionPointerType gExtensionForwarders[MAX_NUMBER_OF_GL_EXTENSIONS];
-extern gl_hooks_t gHooksTrace;
-
-} // namespace android;
-
-
-// ----------------------------------------------------------------------------
-
-static inline void clearError() { egl_tls_t::clearError(); }
-static inline EGLContext getContext() { return egl_tls_t::getContext(); }
-
-// ----------------------------------------------------------------------------
-
-EGLDisplay eglGetDisplay(EGLNativeDisplayType display)
-{
-    ATRACE_CALL();
-    clearError();
-
-    uintptr_t index = reinterpret_cast<uintptr_t>(display);
-    if (index >= NUM_DISPLAYS) {
-        return setError(EGL_BAD_PARAMETER, EGL_NO_DISPLAY);
-    }
-
-    if (egl_init_drivers() == EGL_FALSE) {
-        return setError(EGL_BAD_PARAMETER, EGL_NO_DISPLAY);
-    }
-
-    EGLDisplay dpy = egl_display_t::getFromNativeDisplay(display);
-    return dpy;
-}
-
-// ----------------------------------------------------------------------------
-// Initialization
-// ----------------------------------------------------------------------------
-
-EGLBoolean eglInitialize(EGLDisplay dpy, EGLint *major, EGLint *minor)
-{
-    clearError();
-
-    egl_display_ptr dp = get_display(dpy);
-    if (!dp) return setError(EGL_BAD_DISPLAY, EGL_FALSE);
-
-    EGLBoolean res = dp->initialize(major, minor);
-
-    return res;
-}
-
-EGLBoolean eglTerminate(EGLDisplay dpy)
-{
-    // NOTE: don't unload the drivers b/c some APIs can be called
-    // after eglTerminate() has been called. eglTerminate() only
-    // terminates an EGLDisplay, not a EGL itself.
-
-    clearError();
-
-    egl_display_ptr dp = get_display(dpy);
-    if (!dp) return setError(EGL_BAD_DISPLAY, EGL_FALSE);
-
-    EGLBoolean res = dp->terminate();
-
-    return res;
-}
-
-// ----------------------------------------------------------------------------
-// configuration
-// ----------------------------------------------------------------------------
-
-EGLBoolean eglGetConfigs(   EGLDisplay dpy,
-                            EGLConfig *configs,
-                            EGLint config_size, EGLint *num_config)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    if (num_config==0) {
-        return setError(EGL_BAD_PARAMETER, EGL_FALSE);
-    }
-
-    EGLBoolean res = EGL_FALSE;
-    *num_config = 0;
-
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso) {
-        res = cnx->egl.eglGetConfigs(
-                dp->disp.dpy, configs, config_size, num_config);
-    }
-
-    return res;
-}
-
-EGLBoolean eglChooseConfig( EGLDisplay dpy, const EGLint *attrib_list,
-                            EGLConfig *configs, EGLint config_size,
-                            EGLint *num_config)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    if (num_config==0) {
-        return setError(EGL_BAD_PARAMETER, EGL_FALSE);
-    }
-
-    EGLBoolean res = EGL_FALSE;
-    *num_config = 0;
-
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso) {
-        if (attrib_list) {
-            char value[PROPERTY_VALUE_MAX];
-            property_get("debug.egl.force_msaa", value, "false");
-
-            if (!strcmp(value, "true")) {
-                size_t attribCount = 0;
-                EGLint attrib = attrib_list[0];
-
-                // Only enable MSAA if the context is OpenGL ES 2.0 and
-                // if no caveat is requested
-                const EGLint *attribRendererable = NULL;
-                const EGLint *attribCaveat = NULL;
-
-                // Count the number of attributes and look for
-                // EGL_RENDERABLE_TYPE and EGL_CONFIG_CAVEAT
-                while (attrib != EGL_NONE) {
-                    attrib = attrib_list[attribCount];
-                    switch (attrib) {
-                        case EGL_RENDERABLE_TYPE:
-                            attribRendererable = &attrib_list[attribCount];
-                            break;
-                        case EGL_CONFIG_CAVEAT:
-                            attribCaveat = &attrib_list[attribCount];
-                            break;
-                    }
-                    attribCount++;
-                }
-
-                if (attribRendererable && attribRendererable[1] == EGL_OPENGL_ES2_BIT &&
-                        (!attribCaveat || attribCaveat[1] != EGL_NONE)) {
-
-                    // Insert 2 extra attributes to force-enable MSAA 4x
-                    EGLint aaAttribs[attribCount + 4];
-                    aaAttribs[0] = EGL_SAMPLE_BUFFERS;
-                    aaAttribs[1] = 1;
-                    aaAttribs[2] = EGL_SAMPLES;
-                    aaAttribs[3] = 4;
-
-                    memcpy(&aaAttribs[4], attrib_list, attribCount * sizeof(EGLint));
-
-                    EGLint numConfigAA;
-                    EGLBoolean resAA = cnx->egl.eglChooseConfig(
-                            dp->disp.dpy, aaAttribs, configs, config_size, &numConfigAA);
-
-                    if (resAA == EGL_TRUE && numConfigAA > 0) {
-                        ALOGD("Enabling MSAA 4x");
-                        *num_config = numConfigAA;
-                        return resAA;
-                    }
-                }
-            }
-        }
-
-        res = cnx->egl.eglChooseConfig(
-                dp->disp.dpy, attrib_list, configs, config_size, num_config);
-    }
-    return res;
-}
-
-EGLBoolean eglGetConfigAttrib(EGLDisplay dpy, EGLConfig config,
-        EGLint attribute, EGLint *value)
-{
-    clearError();
-
-    egl_connection_t* cnx = NULL;
-    const egl_display_ptr dp = validate_display_connection(dpy, cnx);
-    if (!dp) return EGL_FALSE;
-
-    return cnx->egl.eglGetConfigAttrib(
-            dp->disp.dpy, config, attribute, value);
-}
-
-// ----------------------------------------------------------------------------
-// surfaces
-// ----------------------------------------------------------------------------
-
-// The EGL_KHR_gl_colorspace spec hasn't been ratified yet, so these haven't
-// been added to the Khronos egl.h.
-#define EGL_GL_COLORSPACE_KHR           EGL_VG_COLORSPACE
-#define EGL_GL_COLORSPACE_SRGB_KHR      EGL_VG_COLORSPACE_sRGB
-#define EGL_GL_COLORSPACE_LINEAR_KHR    EGL_VG_COLORSPACE_LINEAR
-
-// Turn linear formats into corresponding sRGB formats when colorspace is
-// EGL_GL_COLORSPACE_SRGB_KHR, or turn sRGB formats into corresponding linear
-// formats when colorspace is EGL_GL_COLORSPACE_LINEAR_KHR. In any cases where
-// the modification isn't possible, the original dataSpace is returned.
-static android_dataspace modifyBufferDataspace( android_dataspace dataSpace,
-                                                EGLint colorspace) {
-    if (colorspace == EGL_GL_COLORSPACE_LINEAR_KHR) {
-        return HAL_DATASPACE_SRGB_LINEAR;
-    } else if (colorspace == EGL_GL_COLORSPACE_SRGB_KHR) {
-        return HAL_DATASPACE_SRGB;
-    }
-    return dataSpace;
-}
-
-EGLSurface eglCreateWindowSurface(  EGLDisplay dpy, EGLConfig config,
-                                    NativeWindowType window,
-                                    const EGLint *attrib_list)
-{
-    clearError();
-
-    egl_connection_t* cnx = NULL;
-    egl_display_ptr dp = validate_display_connection(dpy, cnx);
-    if (dp) {
-        EGLDisplay iDpy = dp->disp.dpy;
-
-        int result = native_window_api_connect(window, NATIVE_WINDOW_API_EGL);
-        if (result != OK) {
-            ALOGE("eglCreateWindowSurface: native_window_api_connect (win=%p) "
-                    "failed (%#x) (already connected to another API?)",
-                    window, result);
-            return setError(EGL_BAD_ALLOC, EGL_NO_SURFACE);
-        }
-
-        // Set the native window's buffers format to match what this config requests.
-        // Whether to use sRGB gamma is not part of the EGLconfig, but is part
-        // of our native format. So if sRGB gamma is requested, we have to
-        // modify the EGLconfig's format before setting the native window's
-        // format.
-
-        // by default, just pick RGBA_8888
-        EGLint format = HAL_PIXEL_FORMAT_RGBA_8888;
-        android_dataspace dataSpace = HAL_DATASPACE_UNKNOWN;
-
-        EGLint a = 0;
-        cnx->egl.eglGetConfigAttrib(iDpy, config, EGL_ALPHA_SIZE, &a);
-        if (a > 0) {
-            // alpha-channel requested, there's really only one suitable format
-            format = HAL_PIXEL_FORMAT_RGBA_8888;
-        } else {
-            EGLint r, g, b;
-            r = g = b = 0;
-            cnx->egl.eglGetConfigAttrib(iDpy, config, EGL_RED_SIZE,   &r);
-            cnx->egl.eglGetConfigAttrib(iDpy, config, EGL_GREEN_SIZE, &g);
-            cnx->egl.eglGetConfigAttrib(iDpy, config, EGL_BLUE_SIZE,  &b);
-            EGLint colorDepth = r + g + b;
-            if (colorDepth <= 16) {
-                format = HAL_PIXEL_FORMAT_RGB_565;
-            } else {
-                format = HAL_PIXEL_FORMAT_RGBX_8888;
-            }
-        }
-
-        // now select a corresponding sRGB format if needed
-        if (attrib_list && dp->haveExtension("EGL_KHR_gl_colorspace")) {
-            for (const EGLint* attr = attrib_list; *attr != EGL_NONE; attr += 2) {
-                if (*attr == EGL_GL_COLORSPACE_KHR) {
-                    if (ENABLE_EGL_KHR_GL_COLORSPACE) {
-                        dataSpace = modifyBufferDataspace(dataSpace, *(attr+1));
-                    } else {
-                        // Normally we'd pass through unhandled attributes to
-                        // the driver. But in case the driver implements this
-                        // extension but we're disabling it, we want to prevent
-                        // it getting through -- support will be broken without
-                        // our help.
-                        ALOGE("sRGB window surfaces not supported");
-                        return setError(EGL_BAD_ATTRIBUTE, EGL_NO_SURFACE);
-                    }
-                }
-            }
-        }
-
-        if (format != 0) {
-            int err = native_window_set_buffers_format(window, format);
-            if (err != 0) {
-                ALOGE("error setting native window pixel format: %s (%d)",
-                        strerror(-err), err);
-                native_window_api_disconnect(window, NATIVE_WINDOW_API_EGL);
-                return setError(EGL_BAD_NATIVE_WINDOW, EGL_NO_SURFACE);
-            }
-        }
-
-        if (dataSpace != 0) {
-            int err = native_window_set_buffers_data_space(window, dataSpace);
-            if (err != 0) {
-                ALOGE("error setting native window pixel dataSpace: %s (%d)",
-                        strerror(-err), err);
-                native_window_api_disconnect(window, NATIVE_WINDOW_API_EGL);
-                return setError(EGL_BAD_NATIVE_WINDOW, EGL_NO_SURFACE);
-            }
-        }
-
-        // the EGL spec requires that a new EGLSurface default to swap interval
-        // 1, so explicitly set that on the window here.
-        ANativeWindow* anw = reinterpret_cast<ANativeWindow*>(window);
-        anw->setSwapInterval(anw, 1);
-
-        EGLSurface surface = cnx->egl.eglCreateWindowSurface(
-                iDpy, config, window, attrib_list);
-        if (surface != EGL_NO_SURFACE) {
-            egl_surface_t* s = new egl_surface_t(dp.get(), config, window,
-                    surface, cnx);
-            return s;
-        }
-
-        // EGLSurface creation failed
-        native_window_set_buffers_format(window, 0);
-        native_window_api_disconnect(window, NATIVE_WINDOW_API_EGL);
-    }
-    return EGL_NO_SURFACE;
-}
-
-EGLSurface eglCreatePixmapSurface(  EGLDisplay dpy, EGLConfig config,
-                                    NativePixmapType pixmap,
-                                    const EGLint *attrib_list)
-{
-    clearError();
-
-    egl_connection_t* cnx = NULL;
-    egl_display_ptr dp = validate_display_connection(dpy, cnx);
-    if (dp) {
-        EGLSurface surface = cnx->egl.eglCreatePixmapSurface(
-                dp->disp.dpy, config, pixmap, attrib_list);
-        if (surface != EGL_NO_SURFACE) {
-            egl_surface_t* s = new egl_surface_t(dp.get(), config, NULL,
-                    surface, cnx);
-            return s;
-        }
-    }
-    return EGL_NO_SURFACE;
-}
-
-EGLSurface eglCreatePbufferSurface( EGLDisplay dpy, EGLConfig config,
-                                    const EGLint *attrib_list)
-{
-    clearError();
-
-    egl_connection_t* cnx = NULL;
-    egl_display_ptr dp = validate_display_connection(dpy, cnx);
-    if (dp) {
-        EGLSurface surface = cnx->egl.eglCreatePbufferSurface(
-                dp->disp.dpy, config, attrib_list);
-        if (surface != EGL_NO_SURFACE) {
-            egl_surface_t* s = new egl_surface_t(dp.get(), config, NULL,
-                    surface, cnx);
-            return s;
-        }
-    }
-    return EGL_NO_SURFACE;
-}
-
-EGLBoolean eglDestroySurface(EGLDisplay dpy, EGLSurface surface)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    SurfaceRef _s(dp.get(), surface);
-    if (!_s.get())
-        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-
-    egl_surface_t * const s = get_surface(surface);
-    EGLBoolean result = s->cnx->egl.eglDestroySurface(dp->disp.dpy, s->surface);
-    if (result == EGL_TRUE) {
-        _s.terminate();
-    }
-    return result;
-}
-
-EGLBoolean eglQuerySurface( EGLDisplay dpy, EGLSurface surface,
-                            EGLint attribute, EGLint *value)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    SurfaceRef _s(dp.get(), surface);
-    if (!_s.get())
-        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-
-    egl_surface_t const * const s = get_surface(surface);
-    return s->cnx->egl.eglQuerySurface(
-            dp->disp.dpy, s->surface, attribute, value);
-}
-
-void EGLAPI eglBeginFrame(EGLDisplay dpy, EGLSurface surface) {
-    ATRACE_CALL();
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) {
-        return;
-    }
-
-    SurfaceRef _s(dp.get(), surface);
-    if (!_s.get()) {
-        setError(EGL_BAD_SURFACE, EGL_FALSE);
-        return;
-    }
-}
-
-// ----------------------------------------------------------------------------
-// Contexts
-// ----------------------------------------------------------------------------
-
-EGLContext eglCreateContext(EGLDisplay dpy, EGLConfig config,
-                            EGLContext share_list, const EGLint *attrib_list)
-{
-    clearError();
-
-    egl_connection_t* cnx = NULL;
-    const egl_display_ptr dp = validate_display_connection(dpy, cnx);
-    if (dp) {
-        if (share_list != EGL_NO_CONTEXT) {
-            if (!ContextRef(dp.get(), share_list).get()) {
-                return setError(EGL_BAD_CONTEXT, EGL_NO_CONTEXT);
-            }
-            egl_context_t* const c = get_context(share_list);
-            share_list = c->context;
-        }
-        EGLContext context = cnx->egl.eglCreateContext(
-                dp->disp.dpy, config, share_list, attrib_list);
-        if (context != EGL_NO_CONTEXT) {
-            // figure out if it's a GLESv1 or GLESv2
-            int version = 0;
-            if (attrib_list) {
-                while (*attrib_list != EGL_NONE) {
-                    GLint attr = *attrib_list++;
-                    GLint value = *attrib_list++;
-                    if (attr == EGL_CONTEXT_CLIENT_VERSION) {
-                        if (value == 1) {
-                            version = egl_connection_t::GLESv1_INDEX;
-                        } else if (value == 2 || value == 3) {
-                            version = egl_connection_t::GLESv2_INDEX;
-                        }
-                    }
-                };
-            }
-            egl_context_t* c = new egl_context_t(dpy, context, config, cnx,
-                    version);
-            return c;
-        }
-    }
-    return EGL_NO_CONTEXT;
-}
-
-EGLBoolean eglDestroyContext(EGLDisplay dpy, EGLContext ctx)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp)
-        return EGL_FALSE;
-
-    ContextRef _c(dp.get(), ctx);
-    if (!_c.get())
-        return setError(EGL_BAD_CONTEXT, EGL_FALSE);
-
-    egl_context_t * const c = get_context(ctx);
-    EGLBoolean result = c->cnx->egl.eglDestroyContext(dp->disp.dpy, c->context);
-    if (result == EGL_TRUE) {
-        _c.terminate();
-    }
-    return result;
-}
-
-EGLBoolean eglMakeCurrent(  EGLDisplay dpy, EGLSurface draw,
-                            EGLSurface read, EGLContext ctx)
-{
-    clearError();
-
-    egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return setError(EGL_BAD_DISPLAY, EGL_FALSE);
-
-    // If ctx is not EGL_NO_CONTEXT, read is not EGL_NO_SURFACE, or draw is not
-    // EGL_NO_SURFACE, then an EGL_NOT_INITIALIZED error is generated if dpy is
-    // a valid but uninitialized display.
-    if ( (ctx != EGL_NO_CONTEXT) || (read != EGL_NO_SURFACE) ||
-         (draw != EGL_NO_SURFACE) ) {
-        if (!dp->isReady()) return setError(EGL_NOT_INITIALIZED, EGL_FALSE);
-    }
-
-    // get a reference to the object passed in
-    ContextRef _c(dp.get(), ctx);
-    SurfaceRef _d(dp.get(), draw);
-    SurfaceRef _r(dp.get(), read);
-
-    // validate the context (if not EGL_NO_CONTEXT)
-    if ((ctx != EGL_NO_CONTEXT) && !_c.get()) {
-        // EGL_NO_CONTEXT is valid
-        return setError(EGL_BAD_CONTEXT, EGL_FALSE);
-    }
-
-    // these are the underlying implementation's object
-    EGLContext impl_ctx  = EGL_NO_CONTEXT;
-    EGLSurface impl_draw = EGL_NO_SURFACE;
-    EGLSurface impl_read = EGL_NO_SURFACE;
-
-    // these are our objects structs passed in
-    egl_context_t       * c = NULL;
-    egl_surface_t const * d = NULL;
-    egl_surface_t const * r = NULL;
-
-    // these are the current objects structs
-    egl_context_t * cur_c = get_context(getContext());
-
-    if (ctx != EGL_NO_CONTEXT) {
-        c = get_context(ctx);
-        impl_ctx = c->context;
-    } else {
-        // no context given, use the implementation of the current context
-        if (draw != EGL_NO_SURFACE || read != EGL_NO_SURFACE) {
-            // calling eglMakeCurrent( ..., !=0, !=0, EGL_NO_CONTEXT);
-            return setError(EGL_BAD_MATCH, EGL_FALSE);
-        }
-        if (cur_c == NULL) {
-            // no current context
-            // not an error, there is just no current context.
-            return EGL_TRUE;
-        }
-    }
-
-    // retrieve the underlying implementation's draw EGLSurface
-    if (draw != EGL_NO_SURFACE) {
-        if (!_d.get()) return setError(EGL_BAD_SURFACE, EGL_FALSE);
-        d = get_surface(draw);
-        impl_draw = d->surface;
-    }
-
-    // retrieve the underlying implementation's read EGLSurface
-    if (read != EGL_NO_SURFACE) {
-        if (!_r.get()) return setError(EGL_BAD_SURFACE, EGL_FALSE);
-        r = get_surface(read);
-        impl_read = r->surface;
-    }
-
-
-    EGLBoolean result = dp->makeCurrent(c, cur_c,
-            draw, read, ctx,
-            impl_draw, impl_read, impl_ctx);
-
-    if (result == EGL_TRUE) {
-        if (c) {
-            setGLHooksThreadSpecific(c->cnx->hooks[c->version]);
-            egl_tls_t::setContext(ctx);
-            _c.acquire();
-            _r.acquire();
-            _d.acquire();
-        } else {
-            setGLHooksThreadSpecific(&gHooksNoContext);
-            egl_tls_t::setContext(EGL_NO_CONTEXT);
-        }
-    } else {
-        // this will ALOGE the error
-        egl_connection_t* const cnx = &gEGLImpl;
-        result = setError(cnx->egl.eglGetError(), EGL_FALSE);
-    }
-    return result;
-}
-
-
-EGLBoolean eglQueryContext( EGLDisplay dpy, EGLContext ctx,
-                            EGLint attribute, EGLint *value)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    ContextRef _c(dp.get(), ctx);
-    if (!_c.get()) return setError(EGL_BAD_CONTEXT, EGL_FALSE);
-
-    egl_context_t * const c = get_context(ctx);
-    return c->cnx->egl.eglQueryContext(
-            dp->disp.dpy, c->context, attribute, value);
-
-}
-
-EGLContext eglGetCurrentContext(void)
-{
-    // could be called before eglInitialize(), but we wouldn't have a context
-    // then, and this function would correctly return EGL_NO_CONTEXT.
-
-    clearError();
-
-    EGLContext ctx = getContext();
-    return ctx;
-}
-
-EGLSurface eglGetCurrentSurface(EGLint readdraw)
-{
-    // could be called before eglInitialize(), but we wouldn't have a context
-    // then, and this function would correctly return EGL_NO_SURFACE.
-
-    clearError();
-
-    EGLContext ctx = getContext();
-    if (ctx) {
-        egl_context_t const * const c = get_context(ctx);
-        if (!c) return setError(EGL_BAD_CONTEXT, EGL_NO_SURFACE);
-        switch (readdraw) {
-            case EGL_READ: return c->read;
-            case EGL_DRAW: return c->draw;
-            default: return setError(EGL_BAD_PARAMETER, EGL_NO_SURFACE);
-        }
-    }
-    return EGL_NO_SURFACE;
-}
-
-EGLDisplay eglGetCurrentDisplay(void)
-{
-    // could be called before eglInitialize(), but we wouldn't have a context
-    // then, and this function would correctly return EGL_NO_DISPLAY.
-
-    clearError();
-
-    EGLContext ctx = getContext();
-    if (ctx) {
-        egl_context_t const * const c = get_context(ctx);
-        if (!c) return setError(EGL_BAD_CONTEXT, EGL_NO_SURFACE);
-        return c->dpy;
-    }
-    return EGL_NO_DISPLAY;
-}
-
-EGLBoolean eglWaitGL(void)
-{
-    clearError();
-
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (!cnx->dso)
-        return setError(EGL_BAD_CONTEXT, EGL_FALSE);
-
-    return cnx->egl.eglWaitGL();
-}
-
-EGLBoolean eglWaitNative(EGLint engine)
-{
-    clearError();
-
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (!cnx->dso)
-        return setError(EGL_BAD_CONTEXT, EGL_FALSE);
-
-    return cnx->egl.eglWaitNative(engine);
-}
-
-EGLint eglGetError(void)
-{
-    EGLint err = EGL_SUCCESS;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso) {
-        err = cnx->egl.eglGetError();
-    }
-    if (err == EGL_SUCCESS) {
-        err = egl_tls_t::getError();
-    }
-    return err;
-}
-
-static __eglMustCastToProperFunctionPointerType findBuiltinWrapper(
-        const char* procname) {
-    const egl_connection_t* cnx = &gEGLImpl;
-    void* proc = NULL;
-
-    proc = dlsym(cnx->libEgl, procname);
-    if (proc) return (__eglMustCastToProperFunctionPointerType)proc;
-
-    proc = dlsym(cnx->libGles2, procname);
-    if (proc) return (__eglMustCastToProperFunctionPointerType)proc;
-
-    proc = dlsym(cnx->libGles1, procname);
-    if (proc) return (__eglMustCastToProperFunctionPointerType)proc;
-
-    return NULL;
-}
-
-__eglMustCastToProperFunctionPointerType eglGetProcAddress(const char *procname)
-{
-    // eglGetProcAddress() could be the very first function called
-    // in which case we must make sure we've initialized ourselves, this
-    // happens the first time egl_get_display() is called.
-
-    clearError();
-
-    if (egl_init_drivers() == EGL_FALSE) {
-        setError(EGL_BAD_PARAMETER, NULL);
-        return  NULL;
-    }
-
-    if (FILTER_EXTENSIONS(procname)) {
-        return NULL;
-    }
-
-    __eglMustCastToProperFunctionPointerType addr;
-    addr = findProcAddress(procname, sExtensionMap, NELEM(sExtensionMap));
-    if (addr) return addr;
-
-    addr = findBuiltinWrapper(procname);
-    if (addr) return addr;
-
-    // this protects accesses to sGLExtentionMap and sGLExtentionSlot
-    pthread_mutex_lock(&sExtensionMapMutex);
-
-        /*
-         * Since eglGetProcAddress() is not associated to anything, it needs
-         * to return a function pointer that "works" regardless of what
-         * the current context is.
-         *
-         * For this reason, we return a "forwarder", a small stub that takes
-         * care of calling the function associated with the context
-         * currently bound.
-         *
-         * We first look for extensions we've already resolved, if we're seeing
-         * this extension for the first time, we go through all our
-         * implementations and call eglGetProcAddress() and record the
-         * result in the appropriate implementation hooks and return the
-         * address of the forwarder corresponding to that hook set.
-         *
-         */
-
-        const String8 name(procname);
-        addr = sGLExtentionMap.valueFor(name);
-        const int slot = sGLExtentionSlot;
-
-        ALOGE_IF(slot >= MAX_NUMBER_OF_GL_EXTENSIONS,
-                "no more slots for eglGetProcAddress(\"%s\")",
-                procname);
-
-        if (!addr && (slot < MAX_NUMBER_OF_GL_EXTENSIONS)) {
-            bool found = false;
-
-            egl_connection_t* const cnx = &gEGLImpl;
-            if (cnx->dso && cnx->egl.eglGetProcAddress) {
-                // Extensions are independent of the bound context
-                addr =
-                cnx->hooks[egl_connection_t::GLESv1_INDEX]->ext.extensions[slot] =
-                cnx->hooks[egl_connection_t::GLESv2_INDEX]->ext.extensions[slot] =
-                        cnx->egl.eglGetProcAddress(procname);
-                if (addr) found = true;
-            }
-
-            if (found) {
-                addr = gExtensionForwarders[slot];
-                sGLExtentionMap.add(name, addr);
-                sGLExtentionSlot++;
-            }
-        }
-
-    pthread_mutex_unlock(&sExtensionMapMutex);
-    return addr;
-}
-
-class FrameCompletionThread : public Thread {
-public:
-
-    static void queueSync(EGLSyncKHR sync) {
-        static sp<FrameCompletionThread> thread(new FrameCompletionThread);
-        static bool running = false;
-        if (!running) {
-            thread->run("GPUFrameCompletion");
-            running = true;
-        }
-        {
-            Mutex::Autolock lock(thread->mMutex);
-            ScopedTrace st(ATRACE_TAG, String8::format("kicked off frame %d",
-                    thread->mFramesQueued).string());
-            thread->mQueue.push_back(sync);
-            thread->mCondition.signal();
-            thread->mFramesQueued++;
-            ATRACE_INT("GPU Frames Outstanding", thread->mQueue.size());
-        }
-    }
-
-private:
-    FrameCompletionThread() : mFramesQueued(0), mFramesCompleted(0) {}
-
-    virtual bool threadLoop() {
-        EGLSyncKHR sync;
-        uint32_t frameNum;
-        {
-            Mutex::Autolock lock(mMutex);
-            while (mQueue.isEmpty()) {
-                mCondition.wait(mMutex);
-            }
-            sync = mQueue[0];
-            frameNum = mFramesCompleted;
-        }
-        EGLDisplay dpy = eglGetDisplay(EGL_DEFAULT_DISPLAY);
-        {
-            ScopedTrace st(ATRACE_TAG, String8::format("waiting for frame %d",
-                    frameNum).string());
-            EGLint result = eglClientWaitSyncKHR(dpy, sync, 0, EGL_FOREVER_KHR);
-            if (result == EGL_FALSE) {
-                ALOGE("FrameCompletion: error waiting for fence: %#x", eglGetError());
-            } else if (result == EGL_TIMEOUT_EXPIRED_KHR) {
-                ALOGE("FrameCompletion: timeout waiting for fence");
-            }
-            eglDestroySyncKHR(dpy, sync);
-        }
-        {
-            Mutex::Autolock lock(mMutex);
-            mQueue.removeAt(0);
-            mFramesCompleted++;
-            ATRACE_INT("GPU Frames Outstanding", mQueue.size());
-        }
-        return true;
-    }
-
-    uint32_t mFramesQueued;
-    uint32_t mFramesCompleted;
-    Vector<EGLSyncKHR> mQueue;
-    Condition mCondition;
-    Mutex mMutex;
-};
-
-EGLBoolean eglSwapBuffersWithDamageKHR(EGLDisplay dpy, EGLSurface draw,
-        EGLint *rects, EGLint n_rects)
-{
-    ATRACE_CALL();
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    SurfaceRef _s(dp.get(), draw);
-    if (!_s.get())
-        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-
-    egl_surface_t const * const s = get_surface(draw);
-
-    if (CC_UNLIKELY(dp->traceGpuCompletion)) {
-        EGLSyncKHR sync = eglCreateSyncKHR(dpy, EGL_SYNC_FENCE_KHR, NULL);
-        if (sync != EGL_NO_SYNC_KHR) {
-            FrameCompletionThread::queueSync(sync);
-        }
-    }
-
-    if (CC_UNLIKELY(dp->finishOnSwap)) {
-        uint32_t pixel;
-        egl_context_t * const c = get_context( egl_tls_t::getContext() );
-        if (c) {
-            // glReadPixels() ensures that the frame is complete
-            s->cnx->hooks[c->version]->gl.glReadPixels(0,0,1,1,
-                    GL_RGBA,GL_UNSIGNED_BYTE,&pixel);
-        }
-    }
-
-    if (n_rects == 0) {
-        return s->cnx->egl.eglSwapBuffers(dp->disp.dpy, s->surface);
-    }
-
-    Vector<android_native_rect_t> androidRects;
-    for (int r = 0; r < n_rects; ++r) {
-        int offset = r * 4;
-        int x = rects[offset];
-        int y = rects[offset + 1];
-        int width = rects[offset + 2];
-        int height = rects[offset + 3];
-        android_native_rect_t androidRect;
-        androidRect.left = x;
-        androidRect.top = y + height;
-        androidRect.right = x + width;
-        androidRect.bottom = y;
-        androidRects.push_back(androidRect);
-    }
-    native_window_set_surface_damage(s->win.get(), androidRects.array(),
-            androidRects.size());
-
-    if (s->cnx->egl.eglSwapBuffersWithDamageKHR) {
-        return s->cnx->egl.eglSwapBuffersWithDamageKHR(dp->disp.dpy, s->surface,
-                rects, n_rects);
-    } else {
-        return s->cnx->egl.eglSwapBuffers(dp->disp.dpy, s->surface);
-    }
-}
-
-EGLBoolean eglSwapBuffers(EGLDisplay dpy, EGLSurface surface)
-{
-    return eglSwapBuffersWithDamageKHR(dpy, surface, NULL, 0);
-}
-
-EGLBoolean eglCopyBuffers(  EGLDisplay dpy, EGLSurface surface,
-                            NativePixmapType target)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    SurfaceRef _s(dp.get(), surface);
-    if (!_s.get())
-        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-
-    egl_surface_t const * const s = get_surface(surface);
-    return s->cnx->egl.eglCopyBuffers(dp->disp.dpy, s->surface, target);
-}
-
-const char* eglQueryString(EGLDisplay dpy, EGLint name)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return (const char *) NULL;
-
-    switch (name) {
-        case EGL_VENDOR:
-            return dp->getVendorString();
-        case EGL_VERSION:
-            return dp->getVersionString();
-        case EGL_EXTENSIONS:
-            return dp->getExtensionString();
-        case EGL_CLIENT_APIS:
-            return dp->getClientApiString();
-    }
-    return setError(EGL_BAD_PARAMETER, (const char *)0);
-}
-
-EGLAPI const char* eglQueryStringImplementationANDROID(EGLDisplay dpy, EGLint name)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return (const char *) NULL;
-
-    switch (name) {
-        case EGL_VENDOR:
-            return dp->disp.queryString.vendor;
-        case EGL_VERSION:
-            return dp->disp.queryString.version;
-        case EGL_EXTENSIONS:
-            return dp->disp.queryString.extensions;
-        case EGL_CLIENT_APIS:
-            return dp->disp.queryString.clientApi;
-    }
-    return setError(EGL_BAD_PARAMETER, (const char *)0);
-}
-
-// ----------------------------------------------------------------------------
-// EGL 1.1
-// ----------------------------------------------------------------------------
-
-EGLBoolean eglSurfaceAttrib(
-        EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint value)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    SurfaceRef _s(dp.get(), surface);
-    if (!_s.get())
-        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-
-    egl_surface_t * const s = get_surface(surface);
-
-    if (attribute == EGL_FRONT_BUFFER_AUTO_REFRESH_ANDROID) {
-        int err = native_window_set_auto_refresh(s->win.get(),
-            value ? true : false);
-        return (err == NO_ERROR) ? EGL_TRUE :
-            setError(EGL_BAD_SURFACE, EGL_FALSE);
-    }
-
-#if ENABLE_EGL_ANDROID_GET_FRAME_TIMESTAMPS
-    if (attribute == EGL_TIMESTAMPS_ANDROID) {
-        s->enableTimestamps = value;
-        return EGL_TRUE;
-    }
-#endif
-
-    if (s->cnx->egl.eglSurfaceAttrib) {
-        return s->cnx->egl.eglSurfaceAttrib(
-                dp->disp.dpy, s->surface, attribute, value);
-    }
-    return setError(EGL_BAD_SURFACE, EGL_FALSE);
-}
-
-EGLBoolean eglBindTexImage(
-        EGLDisplay dpy, EGLSurface surface, EGLint buffer)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    SurfaceRef _s(dp.get(), surface);
-    if (!_s.get())
-        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-
-    egl_surface_t const * const s = get_surface(surface);
-    if (s->cnx->egl.eglBindTexImage) {
-        return s->cnx->egl.eglBindTexImage(
-                dp->disp.dpy, s->surface, buffer);
-    }
-    return setError(EGL_BAD_SURFACE, EGL_FALSE);
-}
-
-EGLBoolean eglReleaseTexImage(
-        EGLDisplay dpy, EGLSurface surface, EGLint buffer)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    SurfaceRef _s(dp.get(), surface);
-    if (!_s.get())
-        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-
-    egl_surface_t const * const s = get_surface(surface);
-    if (s->cnx->egl.eglReleaseTexImage) {
-        return s->cnx->egl.eglReleaseTexImage(
-                dp->disp.dpy, s->surface, buffer);
-    }
-    return setError(EGL_BAD_SURFACE, EGL_FALSE);
-}
-
-EGLBoolean eglSwapInterval(EGLDisplay dpy, EGLint interval)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    EGLBoolean res = EGL_TRUE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglSwapInterval) {
-        res = cnx->egl.eglSwapInterval(dp->disp.dpy, interval);
-    }
-
-    return res;
-}
-
-
-// ----------------------------------------------------------------------------
-// EGL 1.2
-// ----------------------------------------------------------------------------
-
-EGLBoolean eglWaitClient(void)
-{
-    clearError();
-
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (!cnx->dso)
-        return setError(EGL_BAD_CONTEXT, EGL_FALSE);
-
-    EGLBoolean res;
-    if (cnx->egl.eglWaitClient) {
-        res = cnx->egl.eglWaitClient();
-    } else {
-        res = cnx->egl.eglWaitGL();
-    }
-    return res;
-}
-
-EGLBoolean eglBindAPI(EGLenum api)
-{
-    clearError();
-
-    if (egl_init_drivers() == EGL_FALSE) {
-        return setError(EGL_BAD_PARAMETER, EGL_FALSE);
-    }
-
-    // bind this API on all EGLs
-    EGLBoolean res = EGL_TRUE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglBindAPI) {
-        res = cnx->egl.eglBindAPI(api);
-    }
-    return res;
-}
-
-EGLenum eglQueryAPI(void)
-{
-    clearError();
-
-    if (egl_init_drivers() == EGL_FALSE) {
-        return setError(EGL_BAD_PARAMETER, EGL_FALSE);
-    }
-
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglQueryAPI) {
-        return cnx->egl.eglQueryAPI();
-    }
-
-    // or, it can only be OpenGL ES
-    return EGL_OPENGL_ES_API;
-}
-
-EGLBoolean eglReleaseThread(void)
-{
-    clearError();
-
-    // If there is context bound to the thread, release it
-    egl_display_t::loseCurrent(get_context(getContext()));
-
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglReleaseThread) {
-        cnx->egl.eglReleaseThread();
-    }
-    egl_tls_t::clearTLS();
-    return EGL_TRUE;
-}
-
-EGLSurface eglCreatePbufferFromClientBuffer(
-          EGLDisplay dpy, EGLenum buftype, EGLClientBuffer buffer,
-          EGLConfig config, const EGLint *attrib_list)
-{
-    clearError();
-
-    egl_connection_t* cnx = NULL;
-    const egl_display_ptr dp = validate_display_connection(dpy, cnx);
-    if (!dp) return EGL_FALSE;
-    if (cnx->egl.eglCreatePbufferFromClientBuffer) {
-        return cnx->egl.eglCreatePbufferFromClientBuffer(
-                dp->disp.dpy, buftype, buffer, config, attrib_list);
-    }
-    return setError(EGL_BAD_CONFIG, EGL_NO_SURFACE);
-}
-
-// ----------------------------------------------------------------------------
-// EGL_EGLEXT_VERSION 3
-// ----------------------------------------------------------------------------
-
-EGLBoolean eglLockSurfaceKHR(EGLDisplay dpy, EGLSurface surface,
-        const EGLint *attrib_list)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    SurfaceRef _s(dp.get(), surface);
-    if (!_s.get())
-        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-
-    egl_surface_t const * const s = get_surface(surface);
-    if (s->cnx->egl.eglLockSurfaceKHR) {
-        return s->cnx->egl.eglLockSurfaceKHR(
-                dp->disp.dpy, s->surface, attrib_list);
-    }
-    return setError(EGL_BAD_DISPLAY, EGL_FALSE);
-}
-
-EGLBoolean eglUnlockSurfaceKHR(EGLDisplay dpy, EGLSurface surface)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    SurfaceRef _s(dp.get(), surface);
-    if (!_s.get())
-        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-
-    egl_surface_t const * const s = get_surface(surface);
-    if (s->cnx->egl.eglUnlockSurfaceKHR) {
-        return s->cnx->egl.eglUnlockSurfaceKHR(dp->disp.dpy, s->surface);
-    }
-    return setError(EGL_BAD_DISPLAY, EGL_FALSE);
-}
-
-EGLImageKHR eglCreateImageKHR(EGLDisplay dpy, EGLContext ctx, EGLenum target,
-        EGLClientBuffer buffer, const EGLint *attrib_list)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_NO_IMAGE_KHR;
-
-    ContextRef _c(dp.get(), ctx);
-    egl_context_t * const c = _c.get();
-
-    EGLImageKHR result = EGL_NO_IMAGE_KHR;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglCreateImageKHR) {
-        result = cnx->egl.eglCreateImageKHR(
-                dp->disp.dpy,
-                c ? c->context : EGL_NO_CONTEXT,
-                target, buffer, attrib_list);
-    }
-    return result;
-}
-
-EGLBoolean eglDestroyImageKHR(EGLDisplay dpy, EGLImageKHR img)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    EGLBoolean result = EGL_FALSE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglDestroyImageKHR) {
-        result = cnx->egl.eglDestroyImageKHR(dp->disp.dpy, img);
-    }
-    return result;
-}
-
-// ----------------------------------------------------------------------------
-// EGL_EGLEXT_VERSION 5
-// ----------------------------------------------------------------------------
-
-
-EGLSyncKHR eglCreateSyncKHR(EGLDisplay dpy, EGLenum type, const EGLint *attrib_list)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_NO_SYNC_KHR;
-
-    EGLSyncKHR result = EGL_NO_SYNC_KHR;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglCreateSyncKHR) {
-        result = cnx->egl.eglCreateSyncKHR(dp->disp.dpy, type, attrib_list);
-    }
-    return result;
-}
-
-EGLBoolean eglDestroySyncKHR(EGLDisplay dpy, EGLSyncKHR sync)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    EGLBoolean result = EGL_FALSE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglDestroySyncKHR) {
-        result = cnx->egl.eglDestroySyncKHR(dp->disp.dpy, sync);
-    }
-    return result;
-}
-
-EGLBoolean eglSignalSyncKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLenum mode) {
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    EGLBoolean result = EGL_FALSE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglSignalSyncKHR) {
-        result = cnx->egl.eglSignalSyncKHR(
-                dp->disp.dpy, sync, mode);
-    }
-    return result;
-}
-
-EGLint eglClientWaitSyncKHR(EGLDisplay dpy, EGLSyncKHR sync,
-        EGLint flags, EGLTimeKHR timeout)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    EGLBoolean result = EGL_FALSE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglClientWaitSyncKHR) {
-        result = cnx->egl.eglClientWaitSyncKHR(
-                dp->disp.dpy, sync, flags, timeout);
-    }
-    return result;
-}
-
-EGLBoolean eglGetSyncAttribKHR(EGLDisplay dpy, EGLSyncKHR sync,
-        EGLint attribute, EGLint *value)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    EGLBoolean result = EGL_FALSE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglGetSyncAttribKHR) {
-        result = cnx->egl.eglGetSyncAttribKHR(
-                dp->disp.dpy, sync, attribute, value);
-    }
-    return result;
-}
-
-EGLStreamKHR eglCreateStreamKHR(EGLDisplay dpy, const EGLint *attrib_list)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_NO_STREAM_KHR;
-
-    EGLStreamKHR result = EGL_NO_STREAM_KHR;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglCreateStreamKHR) {
-        result = cnx->egl.eglCreateStreamKHR(
-                dp->disp.dpy, attrib_list);
-    }
-    return result;
-}
-
-EGLBoolean eglDestroyStreamKHR(EGLDisplay dpy, EGLStreamKHR stream)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    EGLBoolean result = EGL_FALSE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglDestroyStreamKHR) {
-        result = cnx->egl.eglDestroyStreamKHR(
-                dp->disp.dpy, stream);
-    }
-    return result;
-}
-
-EGLBoolean eglStreamAttribKHR(EGLDisplay dpy, EGLStreamKHR stream,
-        EGLenum attribute, EGLint value)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    EGLBoolean result = EGL_FALSE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglStreamAttribKHR) {
-        result = cnx->egl.eglStreamAttribKHR(
-                dp->disp.dpy, stream, attribute, value);
-    }
-    return result;
-}
-
-EGLBoolean eglQueryStreamKHR(EGLDisplay dpy, EGLStreamKHR stream,
-        EGLenum attribute, EGLint *value)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    EGLBoolean result = EGL_FALSE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglQueryStreamKHR) {
-        result = cnx->egl.eglQueryStreamKHR(
-                dp->disp.dpy, stream, attribute, value);
-    }
-    return result;
-}
-
-EGLBoolean eglQueryStreamu64KHR(EGLDisplay dpy, EGLStreamKHR stream,
-        EGLenum attribute, EGLuint64KHR *value)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    EGLBoolean result = EGL_FALSE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglQueryStreamu64KHR) {
-        result = cnx->egl.eglQueryStreamu64KHR(
-                dp->disp.dpy, stream, attribute, value);
-    }
-    return result;
-}
-
-EGLBoolean eglQueryStreamTimeKHR(EGLDisplay dpy, EGLStreamKHR stream,
-        EGLenum attribute, EGLTimeKHR *value)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    EGLBoolean result = EGL_FALSE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglQueryStreamTimeKHR) {
-        result = cnx->egl.eglQueryStreamTimeKHR(
-                dp->disp.dpy, stream, attribute, value);
-    }
-    return result;
-}
-
-EGLSurface eglCreateStreamProducerSurfaceKHR(EGLDisplay dpy, EGLConfig config,
-        EGLStreamKHR stream, const EGLint *attrib_list)
-{
-    clearError();
-
-    egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_NO_SURFACE;
-
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglCreateStreamProducerSurfaceKHR) {
-        EGLSurface surface = cnx->egl.eglCreateStreamProducerSurfaceKHR(
-                dp->disp.dpy, config, stream, attrib_list);
-        if (surface != EGL_NO_SURFACE) {
-            egl_surface_t* s = new egl_surface_t(dp.get(), config, NULL,
-                    surface, cnx);
-            return s;
-        }
-    }
-    return EGL_NO_SURFACE;
-}
-
-EGLBoolean eglStreamConsumerGLTextureExternalKHR(EGLDisplay dpy,
-        EGLStreamKHR stream)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    EGLBoolean result = EGL_FALSE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglStreamConsumerGLTextureExternalKHR) {
-        result = cnx->egl.eglStreamConsumerGLTextureExternalKHR(
-                dp->disp.dpy, stream);
-    }
-    return result;
-}
-
-EGLBoolean eglStreamConsumerAcquireKHR(EGLDisplay dpy,
-        EGLStreamKHR stream)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    EGLBoolean result = EGL_FALSE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglStreamConsumerAcquireKHR) {
-        result = cnx->egl.eglStreamConsumerAcquireKHR(
-                dp->disp.dpy, stream);
-    }
-    return result;
-}
-
-EGLBoolean eglStreamConsumerReleaseKHR(EGLDisplay dpy,
-        EGLStreamKHR stream)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    EGLBoolean result = EGL_FALSE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglStreamConsumerReleaseKHR) {
-        result = cnx->egl.eglStreamConsumerReleaseKHR(
-                dp->disp.dpy, stream);
-    }
-    return result;
-}
-
-EGLNativeFileDescriptorKHR eglGetStreamFileDescriptorKHR(
-        EGLDisplay dpy, EGLStreamKHR stream)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_NO_FILE_DESCRIPTOR_KHR;
-
-    EGLNativeFileDescriptorKHR result = EGL_NO_FILE_DESCRIPTOR_KHR;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglGetStreamFileDescriptorKHR) {
-        result = cnx->egl.eglGetStreamFileDescriptorKHR(
-                dp->disp.dpy, stream);
-    }
-    return result;
-}
-
-EGLStreamKHR eglCreateStreamFromFileDescriptorKHR(
-        EGLDisplay dpy, EGLNativeFileDescriptorKHR file_descriptor)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_NO_STREAM_KHR;
-
-    EGLStreamKHR result = EGL_NO_STREAM_KHR;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglCreateStreamFromFileDescriptorKHR) {
-        result = cnx->egl.eglCreateStreamFromFileDescriptorKHR(
-                dp->disp.dpy, file_descriptor);
-    }
-    return result;
-}
-
-// ----------------------------------------------------------------------------
-// EGL_EGLEXT_VERSION 15
-// ----------------------------------------------------------------------------
-
-EGLint eglWaitSyncKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLint flags) {
-    clearError();
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-    EGLint result = EGL_FALSE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglWaitSyncKHR) {
-        result = cnx->egl.eglWaitSyncKHR(dp->disp.dpy, sync, flags);
-    }
-    return result;
-}
-
-// ----------------------------------------------------------------------------
-// ANDROID extensions
-// ----------------------------------------------------------------------------
-
-EGLint eglDupNativeFenceFDANDROID(EGLDisplay dpy, EGLSyncKHR sync)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_NO_NATIVE_FENCE_FD_ANDROID;
-
-    EGLint result = EGL_NO_NATIVE_FENCE_FD_ANDROID;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglDupNativeFenceFDANDROID) {
-        result = cnx->egl.eglDupNativeFenceFDANDROID(dp->disp.dpy, sync);
-    }
-    return result;
-}
-
-EGLBoolean eglPresentationTimeANDROID(EGLDisplay dpy, EGLSurface surface,
-        EGLnsecsANDROID time)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) {
-        return EGL_FALSE;
-    }
-
-    SurfaceRef _s(dp.get(), surface);
-    if (!_s.get()) {
-        setError(EGL_BAD_SURFACE, EGL_FALSE);
-        return EGL_FALSE;
-    }
-
-    egl_surface_t const * const s = get_surface(surface);
-    native_window_set_buffers_timestamp(s->win.get(), time);
-
-    return EGL_TRUE;
-}
-
-EGLClientBuffer eglCreateNativeClientBufferANDROID(const EGLint *attrib_list)
-{
-    clearError();
-
-    int usage = 0;
-    uint32_t width = 0;
-    uint32_t height = 0;
-    uint32_t format = 0;
-    uint32_t red_size = 0;
-    uint32_t green_size = 0;
-    uint32_t blue_size = 0;
-    uint32_t alpha_size = 0;
-
-#define GET_NONNEGATIVE_VALUE(case_name, target) \
-    case case_name: \
-        if (value >= 0) { \
-            target = value; \
-        } else { \
-            return setError(EGL_BAD_PARAMETER, (EGLClientBuffer)0); \
-        } \
-        break
-
-    if (attrib_list) {
-        while (*attrib_list != EGL_NONE) {
-            GLint attr = *attrib_list++;
-            GLint value = *attrib_list++;
-            switch (attr) {
-                GET_NONNEGATIVE_VALUE(EGL_WIDTH, width);
-                GET_NONNEGATIVE_VALUE(EGL_HEIGHT, height);
-                GET_NONNEGATIVE_VALUE(EGL_RED_SIZE, red_size);
-                GET_NONNEGATIVE_VALUE(EGL_GREEN_SIZE, green_size);
-                GET_NONNEGATIVE_VALUE(EGL_BLUE_SIZE, blue_size);
-                GET_NONNEGATIVE_VALUE(EGL_ALPHA_SIZE, alpha_size);
-                case EGL_NATIVE_BUFFER_USAGE_ANDROID:
-                    if (value & EGL_NATIVE_BUFFER_USAGE_PROTECTED_BIT_ANDROID) {
-                        usage |= GRALLOC_USAGE_PROTECTED;
-                    }
-                    if (value & EGL_NATIVE_BUFFER_USAGE_RENDERBUFFER_BIT_ANDROID) {
-                        usage |= GRALLOC_USAGE_HW_RENDER;
-                    }
-                    if (value & EGL_NATIVE_BUFFER_USAGE_TEXTURE_BIT_ANDROID) {
-                        usage |= GRALLOC_USAGE_HW_TEXTURE;
-                    }
-                    break;
-                default:
-                    return setError(EGL_BAD_PARAMETER, (EGLClientBuffer)0);
-            }
-        }
-    }
-#undef GET_NONNEGATIVE_VALUE
-
-    // Validate format.
-    if (red_size == 8 && green_size == 8 && blue_size == 8) {
-        if (alpha_size == 8) {
-            format = HAL_PIXEL_FORMAT_RGBA_8888;
-        } else {
-            format = HAL_PIXEL_FORMAT_RGB_888;
-        }
-    } else if (red_size == 5 && green_size == 6 && blue_size == 5 &&
-               alpha_size == 0) {
-        format = HAL_PIXEL_FORMAT_RGB_565;
-    } else {
-        ALOGE("Invalid native pixel format { r=%d, g=%d, b=%d, a=%d }",
-                red_size, green_size, blue_size, alpha_size);
-        return setError(EGL_BAD_PARAMETER, (EGLClientBuffer)0);
-    }
-
-#define CHECK_ERROR_CONDITION(message) \
-    if (err != NO_ERROR) { \
-        ALOGE(message); \
-        goto error_condition; \
-    }
-
-    // The holder is used to destroy the buffer if an error occurs.
-    GraphicBuffer* gBuffer = new GraphicBuffer();
-    sp<IServiceManager> sm = defaultServiceManager();
-    sp<IBinder> surfaceFlinger = sm->getService(String16("SurfaceFlinger"));
-    sp<IBinder> allocator;
-    Parcel sc_data, sc_reply, data, reply;
-    status_t err = NO_ERROR;
-    if (sm == NULL) {
-        ALOGE("Unable to connect to ServiceManager");
-        goto error_condition;
-    }
-
-    // Obtain an allocator.
-    if (surfaceFlinger == NULL) {
-        ALOGE("Unable to connect to SurfaceFlinger");
-        goto error_condition;
-    }
-    sc_data.writeInterfaceToken(String16("android.ui.ISurfaceComposer"));
-    err = surfaceFlinger->transact(
-            BnSurfaceComposer::CREATE_GRAPHIC_BUFFER_ALLOC, sc_data, &sc_reply);
-    CHECK_ERROR_CONDITION("Unable to obtain allocator from SurfaceFlinger");
-    allocator = sc_reply.readStrongBinder();
-
-    if (allocator == NULL) {
-        ALOGE("Unable to obtain an ISurfaceComposer");
-        goto error_condition;
-    }
-    data.writeInterfaceToken(String16("android.ui.IGraphicBufferAlloc"));
-    err = data.writeUint32(width);
-    CHECK_ERROR_CONDITION("Unable to write width");
-    err = data.writeUint32(height);
-    CHECK_ERROR_CONDITION("Unable to write height");
-    err = data.writeInt32(static_cast<int32_t>(format));
-    CHECK_ERROR_CONDITION("Unable to write format");
-    err = data.writeUint32(usage);
-    CHECK_ERROR_CONDITION("Unable to write usage");
-    err = data.writeUtf8AsUtf16(
-            std::string("[eglCreateNativeClientBufferANDROID pid ") +
-            std::to_string(getpid()) + ']');
-    CHECK_ERROR_CONDITION("Unable to write requestor name");
-    err = allocator->transact(IBinder::FIRST_CALL_TRANSACTION, data,
-            &reply);
-    CHECK_ERROR_CONDITION(
-            "Unable to request buffer allocation from surface composer");
-    err = reply.readInt32();
-    CHECK_ERROR_CONDITION("Unable to obtain buffer from surface composer");
-    err = reply.read(*gBuffer);
-    CHECK_ERROR_CONDITION("Unable to read buffer from surface composer");
-
-    err = gBuffer->initCheck();
-    if (err != NO_ERROR) {
-        ALOGE("Unable to create native buffer { w=%d, h=%d, f=%d, u=%#x }: %#x",
-                width, height, format, usage, err);
-        goto error_condition;
-    }
-    ALOGD("Created new native buffer %p { w=%d, h=%d, f=%d, u=%#x }",
-            gBuffer, width, height, format, usage);
-    return static_cast<EGLClientBuffer>(gBuffer->getNativeBuffer());
-
-#undef CHECK_ERROR_CONDITION
-
-error_condition:
-    // Delete the buffer.
-    sp<GraphicBuffer> holder(gBuffer);
-    return setError(EGL_BAD_ALLOC, (EGLClientBuffer)0);
-}
-
-// ----------------------------------------------------------------------------
-// NVIDIA extensions
-// ----------------------------------------------------------------------------
-EGLuint64NV eglGetSystemTimeFrequencyNV()
-{
-    clearError();
-
-    if (egl_init_drivers() == EGL_FALSE) {
-        return setError(EGL_BAD_PARAMETER, EGL_FALSE);
-    }
-
-    EGLuint64NV ret = 0;
-    egl_connection_t* const cnx = &gEGLImpl;
-
-    if (cnx->dso && cnx->egl.eglGetSystemTimeFrequencyNV) {
-        return cnx->egl.eglGetSystemTimeFrequencyNV();
-    }
-
-    return setErrorQuiet(EGL_BAD_DISPLAY, 0);
-}
-
-EGLuint64NV eglGetSystemTimeNV()
-{
-    clearError();
-
-    if (egl_init_drivers() == EGL_FALSE) {
-        return setError(EGL_BAD_PARAMETER, EGL_FALSE);
-    }
-
-    EGLuint64NV ret = 0;
-    egl_connection_t* const cnx = &gEGLImpl;
-
-    if (cnx->dso && cnx->egl.eglGetSystemTimeNV) {
-        return cnx->egl.eglGetSystemTimeNV();
-    }
-
-    return setErrorQuiet(EGL_BAD_DISPLAY, 0);
-}
-
-// ----------------------------------------------------------------------------
-// Partial update extension
-// ----------------------------------------------------------------------------
-EGLBoolean eglSetDamageRegionKHR(EGLDisplay dpy, EGLSurface surface,
-        EGLint *rects, EGLint n_rects)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) {
-        setError(EGL_BAD_DISPLAY, EGL_FALSE);
-        return EGL_FALSE;
-    }
-
-    SurfaceRef _s(dp.get(), surface);
-    if (!_s.get()) {
-        setError(EGL_BAD_SURFACE, EGL_FALSE);
-        return EGL_FALSE;
-    }
-
-    egl_surface_t const * const s = get_surface(surface);
-    if (s->cnx->egl.eglSetDamageRegionKHR) {
-        return s->cnx->egl.eglSetDamageRegionKHR(dp->disp.dpy, s->surface,
-                rects, n_rects);
-    }
-
-    return EGL_FALSE;
-}
-
-EGLBoolean eglGetFrameTimestampsANDROID(EGLDisplay dpy, EGLSurface surface,
-        EGLint framesAgo, EGLint numTimestamps, const EGLint *timestamps,
-        EGLnsecsANDROID *values)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) {
-        setError(EGL_BAD_DISPLAY, EGL_FALSE);
-        return EGL_FALSE;
-    }
-
-    SurfaceRef _s(dp.get(), surface);
-    if (!_s.get()) {
-        setError(EGL_BAD_SURFACE, EGL_FALSE);
-        return EGL_FALSE;
-    }
-
-    egl_surface_t const * const s = get_surface(surface);
-
-    if (!s->enableTimestamps) {
-        setError(EGL_BAD_SURFACE, EGL_FALSE);
-        return EGL_FALSE;
-    }
-
-    nsecs_t* postedTime = nullptr;
-    nsecs_t* acquireTime = nullptr;
-    nsecs_t* refreshStartTime = nullptr;
-    nsecs_t* GLCompositionDoneTime = nullptr;
-    nsecs_t* displayRetireTime = nullptr;
-    nsecs_t* releaseTime = nullptr;
-
-    for (int i = 0; i < numTimestamps; i++) {
-        switch (timestamps[i]) {
-            case EGL_QUEUE_TIME_ANDROID:
-                postedTime = &values[i];
-                break;
-            case EGL_RENDERING_COMPLETE_TIME_ANDROID:
-                acquireTime = &values[i];
-                break;
-            case EGL_COMPOSITION_START_TIME_ANDROID:
-                refreshStartTime = &values[i];
-                break;
-            case EGL_COMPOSITION_FINISHED_TIME_ANDROID:
-                GLCompositionDoneTime = &values[i];
-                break;
-            case EGL_DISPLAY_RETIRE_TIME_ANDROID:
-                displayRetireTime = &values[i];
-                break;
-            case EGL_READS_DONE_TIME_ANDROID:
-                releaseTime = &values[i];
-                break;
-            default:
-                setError(EGL_BAD_PARAMETER, EGL_FALSE);
-                return EGL_FALSE;
-        }
-    }
-
-    status_t ret = native_window_get_frame_timestamps(s->win.get(), framesAgo,
-            postedTime, acquireTime, refreshStartTime, GLCompositionDoneTime,
-            displayRetireTime, releaseTime);
-
-    if (ret != NO_ERROR) {
-        setError(EGL_BAD_ACCESS, EGL_FALSE);
-        return EGL_FALSE;
-    }
-
-    return EGL_TRUE;
-}
-
-EGLBoolean eglQueryTimestampSupportedANDROID(EGLDisplay dpy, EGLSurface surface,
-        EGLint timestamp)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) {
-        setError(EGL_BAD_DISPLAY, EGL_FALSE);
-        return EGL_FALSE;
-    }
-
-    SurfaceRef _s(dp.get(), surface);
-    if (!_s.get()) {
-        setError(EGL_BAD_SURFACE, EGL_FALSE);
-        return EGL_FALSE;
-    }
-
-    switch (timestamp) {
-#if ENABLE_EGL_ANDROID_GET_FRAME_TIMESTAMPS
-        case EGL_QUEUE_TIME_ANDROID:
-        case EGL_RENDERING_COMPLETE_TIME_ANDROID:
-        case EGL_COMPOSITION_START_TIME_ANDROID:
-        case EGL_COMPOSITION_FINISHED_TIME_ANDROID:
-        case EGL_DISPLAY_RETIRE_TIME_ANDROID:
-        case EGL_READS_DONE_TIME_ANDROID:
-            return EGL_TRUE;
-#endif
-        default:
-            return EGL_FALSE;
-    }
-}
diff -Naur frameworksRaw/native/opengl/libs/EGL/eglApi.cpp.orig.orig.rej frameworksModified/native/opengl/libs/EGL/eglApi.cpp.orig.orig.rej
--- frameworksRaw/native/opengl/libs/EGL/eglApi.cpp.orig.orig.rej	2017-07-06 15:34:21.250450915 +0530
+++ frameworksModified/native/opengl/libs/EGL/eglApi.cpp.orig.orig.rej	1970-01-01 05:30:00.000000000 +0530
@@ -1,2120 +0,0 @@
---- native/opengl/libs/EGL/eglApi.cpp.orig.orig	1970-01-01 05:30:00.000000000 +0530
-+++ native/opengl/libs/EGL/eglApi.cpp.orig.orig	2017-07-06 13:50:15.207676932 +0530
-@@ -0,0 +1,2117 @@
-+/*
-+ ** Copyright 2007, The Android Open Source Project
-+ **
-+ ** Licensed under the Apache License, Version 2.0 (the "License");
-+ ** you may not use this file except in compliance with the License.
-+ ** You may obtain a copy of the License at
-+ **
-+ **     http://www.apache.org/licenses/LICENSE-2.0
-+ **
-+ ** Unless required by applicable law or agreed to in writing, software
-+ ** distributed under the License is distributed on an "AS IS" BASIS,
-+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-+ ** See the License for the specific language governing permissions and
-+ ** limitations under the License.
-+ */
-+
-+#define ATRACE_TAG ATRACE_TAG_GRAPHICS
-+
-+#include <dlfcn.h>
-+#include <ctype.h>
-+#include <stdlib.h>
-+#include <string.h>
-+
-+#include <hardware/gralloc.h>
-+#include <system/window.h>
-+
-+#include <EGL/egl.h>
-+#include <EGL/eglext.h>
-+
-+#include <cutils/log.h>
-+#include <cutils/atomic.h>
-+#include <cutils/compiler.h>
-+#include <cutils/properties.h>
-+#include <cutils/memory.h>
-+
-+#include <gui/ISurfaceComposer.h>
-+
-+#include <ui/GraphicBuffer.h>
-+
-+#include <utils/KeyedVector.h>
-+#include <utils/SortedVector.h>
-+#include <utils/String8.h>
-+#include <utils/Trace.h>
-+
-+#include "binder/Binder.h"
-+#include "binder/Parcel.h"
-+#include "binder/IServiceManager.h"
-+
-+#include "../egl_impl.h"
-+#include "../hooks.h"
-+
-+#include "egl_display.h"
-+#include "egl_object.h"
-+#include "egl_tls.h"
-+#include "egldefs.h"
-+
-+using namespace android;
-+
-+// This extension has not been ratified yet, so can't be shipped.
-+// Implementation is incomplete and untested.
-+#define ENABLE_EGL_KHR_GL_COLORSPACE 0
-+
-+#define ENABLE_EGL_ANDROID_GET_FRAME_TIMESTAMPS 0
-+
-+// ----------------------------------------------------------------------------
-+
-+namespace android {
-+
-+struct extention_map_t {
-+    const char* name;
-+    __eglMustCastToProperFunctionPointerType address;
-+};
-+
-+/*
-+ * This is the list of EGL extensions exposed to applications.
-+ *
-+ * Some of them (gBuiltinExtensionString) are implemented entirely in this EGL
-+ * wrapper and are always available.
-+ *
-+ * The rest (gExtensionString) depend on support in the EGL driver, and are
-+ * only available if the driver supports them. However, some of these must be
-+ * supported because they are used by the Android system itself; these are
-+ * listed as mandatory below and are required by the CDD. The system *assumes*
-+ * the mandatory extensions are present and may not function properly if some
-+ * are missing.
-+ *
-+ * NOTE: Both strings MUST have a single space as the last character.
-+ */
-+extern char const * const gBuiltinExtensionString =
-+        "EGL_KHR_get_all_proc_addresses "
-+        "EGL_ANDROID_presentation_time "
-+        "EGL_KHR_swap_buffers_with_damage "
-+        "EGL_ANDROID_create_native_client_buffer "
-+        "EGL_ANDROID_front_buffer_auto_refresh "
-+#if ENABLE_EGL_ANDROID_GET_FRAME_TIMESTAMPS
-+        "EGL_ANDROID_get_frame_timestamps "
-+#endif
-+        ;
-+extern char const * const gExtensionString  =
-+        "EGL_KHR_image "                        // mandatory
-+        "EGL_KHR_image_base "                   // mandatory
-+        "EGL_KHR_image_pixmap "
-+        "EGL_KHR_lock_surface "
-+#if (ENABLE_EGL_KHR_GL_COLORSPACE != 0)
-+        "EGL_KHR_gl_colorspace "
-+#endif
-+        "EGL_KHR_gl_texture_2D_image "
-+        "EGL_KHR_gl_texture_3D_image "
-+        "EGL_KHR_gl_texture_cubemap_image "
-+        "EGL_KHR_gl_renderbuffer_image "
-+        "EGL_KHR_reusable_sync "
-+        "EGL_KHR_fence_sync "
-+        "EGL_KHR_create_context "
-+        "EGL_KHR_config_attribs "
-+        "EGL_KHR_surfaceless_context "
-+        "EGL_KHR_stream "
-+        "EGL_KHR_stream_fifo "
-+        "EGL_KHR_stream_producer_eglsurface "
-+        "EGL_KHR_stream_consumer_gltexture "
-+        "EGL_KHR_stream_cross_process_fd "
-+        "EGL_EXT_create_context_robustness "
-+        "EGL_NV_system_time "
-+        "EGL_ANDROID_image_native_buffer "      // mandatory
-+        "EGL_KHR_wait_sync "                    // strongly recommended
-+        "EGL_ANDROID_recordable "               // mandatory
-+        "EGL_KHR_partial_update "               // strongly recommended
-+        "EGL_EXT_buffer_age "                   // strongly recommended with partial_update
-+        "EGL_KHR_create_context_no_error "
-+        "EGL_KHR_mutable_render_buffer "
-+        "EGL_EXT_yuv_surface "
-+        "EGL_EXT_protected_content "
-+        ;
-+
-+// extensions not exposed to applications but used by the ANDROID system
-+//      "EGL_ANDROID_blob_cache "               // strongly recommended
-+//      "EGL_IMG_hibernate_process "            // optional
-+//      "EGL_ANDROID_native_fence_sync "        // strongly recommended
-+//      "EGL_ANDROID_framebuffer_target "       // mandatory for HWC 1.1
-+//      "EGL_ANDROID_image_crop "               // optional
-+
-+/*
-+ * EGL Extensions entry-points exposed to 3rd party applications
-+ * (keep in sync with gExtensionString above)
-+ *
-+ */
-+static const extention_map_t sExtensionMap[] = {
-+    // EGL_KHR_lock_surface
-+    { "eglLockSurfaceKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglLockSurfaceKHR },
-+    { "eglUnlockSurfaceKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglUnlockSurfaceKHR },
-+
-+    // EGL_KHR_image, EGL_KHR_image_base
-+    { "eglCreateImageKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglCreateImageKHR },
-+    { "eglDestroyImageKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglDestroyImageKHR },
-+
-+    // EGL_KHR_reusable_sync, EGL_KHR_fence_sync
-+    { "eglCreateSyncKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglCreateSyncKHR },
-+    { "eglDestroySyncKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglDestroySyncKHR },
-+    { "eglClientWaitSyncKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglClientWaitSyncKHR },
-+    { "eglSignalSyncKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglSignalSyncKHR },
-+    { "eglGetSyncAttribKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglGetSyncAttribKHR },
-+
-+    // EGL_NV_system_time
-+    { "eglGetSystemTimeFrequencyNV",
-+            (__eglMustCastToProperFunctionPointerType)&eglGetSystemTimeFrequencyNV },
-+    { "eglGetSystemTimeNV",
-+            (__eglMustCastToProperFunctionPointerType)&eglGetSystemTimeNV },
-+
-+    // EGL_KHR_wait_sync
-+    { "eglWaitSyncKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglWaitSyncKHR },
-+
-+    // EGL_ANDROID_presentation_time
-+    { "eglPresentationTimeANDROID",
-+            (__eglMustCastToProperFunctionPointerType)&eglPresentationTimeANDROID },
-+
-+    // EGL_KHR_swap_buffers_with_damage
-+    { "eglSwapBuffersWithDamageKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglSwapBuffersWithDamageKHR },
-+
-+    // EGL_ANDROID_native_client_buffer
-+    { "eglCreateNativeClientBufferANDROID",
-+            (__eglMustCastToProperFunctionPointerType)&eglCreateNativeClientBufferANDROID },
-+
-+    // EGL_KHR_partial_update
-+    { "eglSetDamageRegionKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglSetDamageRegionKHR },
-+
-+    { "eglCreateStreamKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglCreateStreamKHR },
-+    { "eglDestroyStreamKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglDestroyStreamKHR },
-+    { "eglStreamAttribKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglStreamAttribKHR },
-+    { "eglQueryStreamKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglQueryStreamKHR },
-+    { "eglQueryStreamu64KHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglQueryStreamu64KHR },
-+    { "eglQueryStreamTimeKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglQueryStreamTimeKHR },
-+    { "eglCreateStreamProducerSurfaceKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglCreateStreamProducerSurfaceKHR },
-+    { "eglStreamConsumerGLTextureExternalKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglStreamConsumerGLTextureExternalKHR },
-+    { "eglStreamConsumerAcquireKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglStreamConsumerAcquireKHR },
-+    { "eglStreamConsumerReleaseKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglStreamConsumerReleaseKHR },
-+    { "eglGetStreamFileDescriptorKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglGetStreamFileDescriptorKHR },
-+    { "eglCreateStreamFromFileDescriptorKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglCreateStreamFromFileDescriptorKHR },
-+
-+    // EGL_ANDROID_get_frame_timestamps
-+    { "eglGetFrameTimestampsANDROID",
-+            (__eglMustCastToProperFunctionPointerType)&eglGetFrameTimestampsANDROID },
-+    { "eglQueryTimestampSupportedANDROID",
-+            (__eglMustCastToProperFunctionPointerType)&eglQueryTimestampSupportedANDROID },
-+};
-+
-+/*
-+ * These extensions entry-points should not be exposed to applications.
-+ * They're used internally by the Android EGL layer.
-+ */
-+#define FILTER_EXTENSIONS(procname) \
-+        (!strcmp((procname), "eglSetBlobCacheFuncsANDROID") ||    \
-+         !strcmp((procname), "eglHibernateProcessIMG")      ||    \
-+         !strcmp((procname), "eglAwakenProcessIMG")         ||    \
-+         !strcmp((procname), "eglDupNativeFenceFDANDROID"))
-+
-+
-+
-+// accesses protected by sExtensionMapMutex
-+static DefaultKeyedVector<String8, __eglMustCastToProperFunctionPointerType> sGLExtentionMap;
-+static int sGLExtentionSlot = 0;
-+static pthread_mutex_t sExtensionMapMutex = PTHREAD_MUTEX_INITIALIZER;
-+
-+static void(*findProcAddress(const char* name,
-+        const extention_map_t* map, size_t n))() {
-+    for (uint32_t i=0 ; i<n ; i++) {
-+        if (!strcmp(name, map[i].name)) {
-+            return map[i].address;
-+        }
-+    }
-+    return NULL;
-+}
-+
-+// ----------------------------------------------------------------------------
-+
-+extern void setGLHooksThreadSpecific(gl_hooks_t const *value);
-+extern EGLBoolean egl_init_drivers();
-+extern const __eglMustCastToProperFunctionPointerType gExtensionForwarders[MAX_NUMBER_OF_GL_EXTENSIONS];
-+extern gl_hooks_t gHooksTrace;
-+
-+} // namespace android;
-+
-+
-+// ----------------------------------------------------------------------------
-+
-+static inline void clearError() { egl_tls_t::clearError(); }
-+static inline EGLContext getContext() { return egl_tls_t::getContext(); }
-+
-+// ----------------------------------------------------------------------------
-+
-+EGLDisplay eglGetDisplay(EGLNativeDisplayType display)
-+{
-+    ATRACE_CALL();
-+    clearError();
-+
-+    uintptr_t index = reinterpret_cast<uintptr_t>(display);
-+    if (index >= NUM_DISPLAYS) {
-+        return setError(EGL_BAD_PARAMETER, EGL_NO_DISPLAY);
-+    }
-+
-+    if (egl_init_drivers() == EGL_FALSE) {
-+        return setError(EGL_BAD_PARAMETER, EGL_NO_DISPLAY);
-+    }
-+
-+    EGLDisplay dpy = egl_display_t::getFromNativeDisplay(display);
-+    return dpy;
-+}
-+
-+// ----------------------------------------------------------------------------
-+// Initialization
-+// ----------------------------------------------------------------------------
-+
-+EGLBoolean eglInitialize(EGLDisplay dpy, EGLint *major, EGLint *minor)
-+{
-+    clearError();
-+
-+    egl_display_ptr dp = get_display(dpy);
-+    if (!dp) return setError(EGL_BAD_DISPLAY, EGL_FALSE);
-+
-+    EGLBoolean res = dp->initialize(major, minor);
-+
-+    return res;
-+}
-+
-+EGLBoolean eglTerminate(EGLDisplay dpy)
-+{
-+    // NOTE: don't unload the drivers b/c some APIs can be called
-+    // after eglTerminate() has been called. eglTerminate() only
-+    // terminates an EGLDisplay, not a EGL itself.
-+
-+    clearError();
-+
-+    egl_display_ptr dp = get_display(dpy);
-+    if (!dp) return setError(EGL_BAD_DISPLAY, EGL_FALSE);
-+
-+    EGLBoolean res = dp->terminate();
-+
-+    return res;
-+}
-+
-+// ----------------------------------------------------------------------------
-+// configuration
-+// ----------------------------------------------------------------------------
-+
-+EGLBoolean eglGetConfigs(   EGLDisplay dpy,
-+                            EGLConfig *configs,
-+                            EGLint config_size, EGLint *num_config)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    if (num_config==0) {
-+        return setError(EGL_BAD_PARAMETER, EGL_FALSE);
-+    }
-+
-+    EGLBoolean res = EGL_FALSE;
-+    *num_config = 0;
-+
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso) {
-+        res = cnx->egl.eglGetConfigs(
-+                dp->disp.dpy, configs, config_size, num_config);
-+    }
-+
-+    return res;
-+}
-+
-+EGLBoolean eglChooseConfig( EGLDisplay dpy, const EGLint *attrib_list,
-+                            EGLConfig *configs, EGLint config_size,
-+                            EGLint *num_config)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    if (num_config==0) {
-+        return setError(EGL_BAD_PARAMETER, EGL_FALSE);
-+    }
-+
-+    EGLBoolean res = EGL_FALSE;
-+    *num_config = 0;
-+
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso) {
-+        if (attrib_list) {
-+            char value[PROPERTY_VALUE_MAX];
-+            property_get("debug.egl.force_msaa", value, "false");
-+
-+            if (!strcmp(value, "true")) {
-+                size_t attribCount = 0;
-+                EGLint attrib = attrib_list[0];
-+
-+                // Only enable MSAA if the context is OpenGL ES 2.0 and
-+                // if no caveat is requested
-+                const EGLint *attribRendererable = NULL;
-+                const EGLint *attribCaveat = NULL;
-+
-+                // Count the number of attributes and look for
-+                // EGL_RENDERABLE_TYPE and EGL_CONFIG_CAVEAT
-+                while (attrib != EGL_NONE) {
-+                    attrib = attrib_list[attribCount];
-+                    switch (attrib) {
-+                        case EGL_RENDERABLE_TYPE:
-+                            attribRendererable = &attrib_list[attribCount];
-+                            break;
-+                        case EGL_CONFIG_CAVEAT:
-+                            attribCaveat = &attrib_list[attribCount];
-+                            break;
-+                    }
-+                    attribCount++;
-+                }
-+
-+                if (attribRendererable && attribRendererable[1] == EGL_OPENGL_ES2_BIT &&
-+                        (!attribCaveat || attribCaveat[1] != EGL_NONE)) {
-+
-+                    // Insert 2 extra attributes to force-enable MSAA 4x
-+                    EGLint aaAttribs[attribCount + 4];
-+                    aaAttribs[0] = EGL_SAMPLE_BUFFERS;
-+                    aaAttribs[1] = 1;
-+                    aaAttribs[2] = EGL_SAMPLES;
-+                    aaAttribs[3] = 4;
-+
-+                    memcpy(&aaAttribs[4], attrib_list, attribCount * sizeof(EGLint));
-+
-+                    EGLint numConfigAA;
-+                    EGLBoolean resAA = cnx->egl.eglChooseConfig(
-+                            dp->disp.dpy, aaAttribs, configs, config_size, &numConfigAA);
-+
-+                    if (resAA == EGL_TRUE && numConfigAA > 0) {
-+                        ALOGD("Enabling MSAA 4x");
-+                        *num_config = numConfigAA;
-+                        return resAA;
-+                    }
-+                }
-+            }
-+        }
-+
-+        res = cnx->egl.eglChooseConfig(
-+                dp->disp.dpy, attrib_list, configs, config_size, num_config);
-+    }
-+    return res;
-+}
-+
-+EGLBoolean eglGetConfigAttrib(EGLDisplay dpy, EGLConfig config,
-+        EGLint attribute, EGLint *value)
-+{
-+    clearError();
-+
-+    egl_connection_t* cnx = NULL;
-+    const egl_display_ptr dp = validate_display_connection(dpy, cnx);
-+    if (!dp) return EGL_FALSE;
-+
-+    return cnx->egl.eglGetConfigAttrib(
-+            dp->disp.dpy, config, attribute, value);
-+}
-+
-+// ----------------------------------------------------------------------------
-+// surfaces
-+// ----------------------------------------------------------------------------
-+
-+// The EGL_KHR_gl_colorspace spec hasn't been ratified yet, so these haven't
-+// been added to the Khronos egl.h.
-+#define EGL_GL_COLORSPACE_KHR           EGL_VG_COLORSPACE
-+#define EGL_GL_COLORSPACE_SRGB_KHR      EGL_VG_COLORSPACE_sRGB
-+#define EGL_GL_COLORSPACE_LINEAR_KHR    EGL_VG_COLORSPACE_LINEAR
-+
-+// Turn linear formats into corresponding sRGB formats when colorspace is
-+// EGL_GL_COLORSPACE_SRGB_KHR, or turn sRGB formats into corresponding linear
-+// formats when colorspace is EGL_GL_COLORSPACE_LINEAR_KHR. In any cases where
-+// the modification isn't possible, the original dataSpace is returned.
-+static android_dataspace modifyBufferDataspace( android_dataspace dataSpace,
-+                                                EGLint colorspace) {
-+    if (colorspace == EGL_GL_COLORSPACE_LINEAR_KHR) {
-+        return HAL_DATASPACE_SRGB_LINEAR;
-+    } else if (colorspace == EGL_GL_COLORSPACE_SRGB_KHR) {
-+        return HAL_DATASPACE_SRGB;
-+    }
-+    return dataSpace;
-+}
-+
-+EGLSurface eglCreateWindowSurface(  EGLDisplay dpy, EGLConfig config,
-+                                    NativeWindowType window,
-+                                    const EGLint *attrib_list)
-+{
-+    clearError();
-+
-+    egl_connection_t* cnx = NULL;
-+    egl_display_ptr dp = validate_display_connection(dpy, cnx);
-+    if (dp) {
-+        EGLDisplay iDpy = dp->disp.dpy;
-+
-+        int result = native_window_api_connect(window, NATIVE_WINDOW_API_EGL);
-+        if (result != OK) {
-+            ALOGE("eglCreateWindowSurface: native_window_api_connect (win=%p) "
-+                    "failed (%#x) (already connected to another API?)",
-+                    window, result);
-+            return setError(EGL_BAD_ALLOC, EGL_NO_SURFACE);
-+        }
-+
-+        // Set the native window's buffers format to match what this config requests.
-+        // Whether to use sRGB gamma is not part of the EGLconfig, but is part
-+        // of our native format. So if sRGB gamma is requested, we have to
-+        // modify the EGLconfig's format before setting the native window's
-+        // format.
-+
-+        // by default, just pick RGBA_8888
-+        EGLint format = HAL_PIXEL_FORMAT_RGBA_8888;
-+        android_dataspace dataSpace = HAL_DATASPACE_UNKNOWN;
-+
-+        EGLint a = 0;
-+        cnx->egl.eglGetConfigAttrib(iDpy, config, EGL_ALPHA_SIZE, &a);
-+        if (a > 0) {
-+            // alpha-channel requested, there's really only one suitable format
-+            format = HAL_PIXEL_FORMAT_RGBA_8888;
-+        } else {
-+            EGLint r, g, b;
-+            r = g = b = 0;
-+            cnx->egl.eglGetConfigAttrib(iDpy, config, EGL_RED_SIZE,   &r);
-+            cnx->egl.eglGetConfigAttrib(iDpy, config, EGL_GREEN_SIZE, &g);
-+            cnx->egl.eglGetConfigAttrib(iDpy, config, EGL_BLUE_SIZE,  &b);
-+            EGLint colorDepth = r + g + b;
-+            if (colorDepth <= 16) {
-+                format = HAL_PIXEL_FORMAT_RGB_565;
-+            } else {
-+                format = HAL_PIXEL_FORMAT_RGBX_8888;
-+            }
-+        }
-+
-+        // now select a corresponding sRGB format if needed
-+        if (attrib_list && dp->haveExtension("EGL_KHR_gl_colorspace")) {
-+            for (const EGLint* attr = attrib_list; *attr != EGL_NONE; attr += 2) {
-+                if (*attr == EGL_GL_COLORSPACE_KHR) {
-+                    if (ENABLE_EGL_KHR_GL_COLORSPACE) {
-+                        dataSpace = modifyBufferDataspace(dataSpace, *(attr+1));
-+                    } else {
-+                        // Normally we'd pass through unhandled attributes to
-+                        // the driver. But in case the driver implements this
-+                        // extension but we're disabling it, we want to prevent
-+                        // it getting through -- support will be broken without
-+                        // our help.
-+                        ALOGE("sRGB window surfaces not supported");
-+                        return setError(EGL_BAD_ATTRIBUTE, EGL_NO_SURFACE);
-+                    }
-+                }
-+            }
-+        }
-+
-+        if (format != 0) {
-+            int err = native_window_set_buffers_format(window, format);
-+            if (err != 0) {
-+                ALOGE("error setting native window pixel format: %s (%d)",
-+                        strerror(-err), err);
-+                native_window_api_disconnect(window, NATIVE_WINDOW_API_EGL);
-+                return setError(EGL_BAD_NATIVE_WINDOW, EGL_NO_SURFACE);
-+            }
-+        }
-+
-+        if (dataSpace != 0) {
-+            int err = native_window_set_buffers_data_space(window, dataSpace);
-+            if (err != 0) {
-+                ALOGE("error setting native window pixel dataSpace: %s (%d)",
-+                        strerror(-err), err);
-+                native_window_api_disconnect(window, NATIVE_WINDOW_API_EGL);
-+                return setError(EGL_BAD_NATIVE_WINDOW, EGL_NO_SURFACE);
-+            }
-+        }
-+
-+        // the EGL spec requires that a new EGLSurface default to swap interval
-+        // 1, so explicitly set that on the window here.
-+        ANativeWindow* anw = reinterpret_cast<ANativeWindow*>(window);
-+        anw->setSwapInterval(anw, 1);
-+
-+        EGLSurface surface = cnx->egl.eglCreateWindowSurface(
-+                iDpy, config, window, attrib_list);
-+        if (surface != EGL_NO_SURFACE) {
-+            egl_surface_t* s = new egl_surface_t(dp.get(), config, window,
-+                    surface, cnx);
-+            return s;
-+        }
-+
-+        // EGLSurface creation failed
-+        native_window_set_buffers_format(window, 0);
-+        native_window_api_disconnect(window, NATIVE_WINDOW_API_EGL);
-+    }
-+    return EGL_NO_SURFACE;
-+}
-+
-+EGLSurface eglCreatePixmapSurface(  EGLDisplay dpy, EGLConfig config,
-+                                    NativePixmapType pixmap,
-+                                    const EGLint *attrib_list)
-+{
-+    clearError();
-+
-+    egl_connection_t* cnx = NULL;
-+    egl_display_ptr dp = validate_display_connection(dpy, cnx);
-+    if (dp) {
-+        EGLSurface surface = cnx->egl.eglCreatePixmapSurface(
-+                dp->disp.dpy, config, pixmap, attrib_list);
-+        if (surface != EGL_NO_SURFACE) {
-+            egl_surface_t* s = new egl_surface_t(dp.get(), config, NULL,
-+                    surface, cnx);
-+            return s;
-+        }
-+    }
-+    return EGL_NO_SURFACE;
-+}
-+
-+EGLSurface eglCreatePbufferSurface( EGLDisplay dpy, EGLConfig config,
-+                                    const EGLint *attrib_list)
-+{
-+    clearError();
-+
-+    egl_connection_t* cnx = NULL;
-+    egl_display_ptr dp = validate_display_connection(dpy, cnx);
-+    if (dp) {
-+        EGLSurface surface = cnx->egl.eglCreatePbufferSurface(
-+                dp->disp.dpy, config, attrib_list);
-+        if (surface != EGL_NO_SURFACE) {
-+            egl_surface_t* s = new egl_surface_t(dp.get(), config, NULL,
-+                    surface, cnx);
-+            return s;
-+        }
-+    }
-+    return EGL_NO_SURFACE;
-+}
-+
-+EGLBoolean eglDestroySurface(EGLDisplay dpy, EGLSurface surface)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    SurfaceRef _s(dp.get(), surface);
-+    if (!_s.get())
-+        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-+
-+    egl_surface_t * const s = get_surface(surface);
-+    EGLBoolean result = s->cnx->egl.eglDestroySurface(dp->disp.dpy, s->surface);
-+    if (result == EGL_TRUE) {
-+        _s.terminate();
-+    }
-+    return result;
-+}
-+
-+EGLBoolean eglQuerySurface( EGLDisplay dpy, EGLSurface surface,
-+                            EGLint attribute, EGLint *value)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    SurfaceRef _s(dp.get(), surface);
-+    if (!_s.get())
-+        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-+
-+    egl_surface_t const * const s = get_surface(surface);
-+    return s->cnx->egl.eglQuerySurface(
-+            dp->disp.dpy, s->surface, attribute, value);
-+}
-+
-+void EGLAPI eglBeginFrame(EGLDisplay dpy, EGLSurface surface) {
-+    ATRACE_CALL();
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) {
-+        return;
-+    }
-+
-+    SurfaceRef _s(dp.get(), surface);
-+    if (!_s.get()) {
-+        setError(EGL_BAD_SURFACE, EGL_FALSE);
-+        return;
-+    }
-+}
-+
-+// ----------------------------------------------------------------------------
-+// Contexts
-+// ----------------------------------------------------------------------------
-+
-+EGLContext eglCreateContext(EGLDisplay dpy, EGLConfig config,
-+                            EGLContext share_list, const EGLint *attrib_list)
-+{
-+    clearError();
-+
-+    egl_connection_t* cnx = NULL;
-+    const egl_display_ptr dp = validate_display_connection(dpy, cnx);
-+    if (dp) {
-+        if (share_list != EGL_NO_CONTEXT) {
-+            if (!ContextRef(dp.get(), share_list).get()) {
-+                return setError(EGL_BAD_CONTEXT, EGL_NO_CONTEXT);
-+            }
-+            egl_context_t* const c = get_context(share_list);
-+            share_list = c->context;
-+        }
-+        EGLContext context = cnx->egl.eglCreateContext(
-+                dp->disp.dpy, config, share_list, attrib_list);
-+        if (context != EGL_NO_CONTEXT) {
-+            // figure out if it's a GLESv1 or GLESv2
-+            int version = 0;
-+            if (attrib_list) {
-+                while (*attrib_list != EGL_NONE) {
-+                    GLint attr = *attrib_list++;
-+                    GLint value = *attrib_list++;
-+                    if (attr == EGL_CONTEXT_CLIENT_VERSION) {
-+                        if (value == 1) {
-+                            version = egl_connection_t::GLESv1_INDEX;
-+                        } else if (value == 2 || value == 3) {
-+                            version = egl_connection_t::GLESv2_INDEX;
-+                        }
-+                    }
-+                };
-+            }
-+            egl_context_t* c = new egl_context_t(dpy, context, config, cnx,
-+                    version);
-+            return c;
-+        }
-+    }
-+    return EGL_NO_CONTEXT;
-+}
-+
-+EGLBoolean eglDestroyContext(EGLDisplay dpy, EGLContext ctx)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp)
-+        return EGL_FALSE;
-+
-+    ContextRef _c(dp.get(), ctx);
-+    if (!_c.get())
-+        return setError(EGL_BAD_CONTEXT, EGL_FALSE);
-+
-+    egl_context_t * const c = get_context(ctx);
-+    EGLBoolean result = c->cnx->egl.eglDestroyContext(dp->disp.dpy, c->context);
-+    if (result == EGL_TRUE) {
-+        _c.terminate();
-+    }
-+    return result;
-+}
-+
-+EGLBoolean eglMakeCurrent(  EGLDisplay dpy, EGLSurface draw,
-+                            EGLSurface read, EGLContext ctx)
-+{
-+    clearError();
-+
-+    egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return setError(EGL_BAD_DISPLAY, EGL_FALSE);
-+
-+    // If ctx is not EGL_NO_CONTEXT, read is not EGL_NO_SURFACE, or draw is not
-+    // EGL_NO_SURFACE, then an EGL_NOT_INITIALIZED error is generated if dpy is
-+    // a valid but uninitialized display.
-+    if ( (ctx != EGL_NO_CONTEXT) || (read != EGL_NO_SURFACE) ||
-+         (draw != EGL_NO_SURFACE) ) {
-+        if (!dp->isReady()) return setError(EGL_NOT_INITIALIZED, EGL_FALSE);
-+    }
-+
-+    // get a reference to the object passed in
-+    ContextRef _c(dp.get(), ctx);
-+    SurfaceRef _d(dp.get(), draw);
-+    SurfaceRef _r(dp.get(), read);
-+
-+    // validate the context (if not EGL_NO_CONTEXT)
-+    if ((ctx != EGL_NO_CONTEXT) && !_c.get()) {
-+        // EGL_NO_CONTEXT is valid
-+        return setError(EGL_BAD_CONTEXT, EGL_FALSE);
-+    }
-+
-+    // these are the underlying implementation's object
-+    EGLContext impl_ctx  = EGL_NO_CONTEXT;
-+    EGLSurface impl_draw = EGL_NO_SURFACE;
-+    EGLSurface impl_read = EGL_NO_SURFACE;
-+
-+    // these are our objects structs passed in
-+    egl_context_t       * c = NULL;
-+    egl_surface_t const * d = NULL;
-+    egl_surface_t const * r = NULL;
-+
-+    // these are the current objects structs
-+    egl_context_t * cur_c = get_context(getContext());
-+
-+    if (ctx != EGL_NO_CONTEXT) {
-+        c = get_context(ctx);
-+        impl_ctx = c->context;
-+    } else {
-+        // no context given, use the implementation of the current context
-+        if (draw != EGL_NO_SURFACE || read != EGL_NO_SURFACE) {
-+            // calling eglMakeCurrent( ..., !=0, !=0, EGL_NO_CONTEXT);
-+            return setError(EGL_BAD_MATCH, EGL_FALSE);
-+        }
-+        if (cur_c == NULL) {
-+            // no current context
-+            // not an error, there is just no current context.
-+            return EGL_TRUE;
-+        }
-+    }
-+
-+    // retrieve the underlying implementation's draw EGLSurface
-+    if (draw != EGL_NO_SURFACE) {
-+        if (!_d.get()) return setError(EGL_BAD_SURFACE, EGL_FALSE);
-+        d = get_surface(draw);
-+        impl_draw = d->surface;
-+    }
-+
-+    // retrieve the underlying implementation's read EGLSurface
-+    if (read != EGL_NO_SURFACE) {
-+        if (!_r.get()) return setError(EGL_BAD_SURFACE, EGL_FALSE);
-+        r = get_surface(read);
-+        impl_read = r->surface;
-+    }
-+
-+
-+    EGLBoolean result = dp->makeCurrent(c, cur_c,
-+            draw, read, ctx,
-+            impl_draw, impl_read, impl_ctx);
-+
-+    if (result == EGL_TRUE) {
-+        if (c) {
-+            setGLHooksThreadSpecific(c->cnx->hooks[c->version]);
-+            egl_tls_t::setContext(ctx);
-+            _c.acquire();
-+            _r.acquire();
-+            _d.acquire();
-+        } else {
-+            setGLHooksThreadSpecific(&gHooksNoContext);
-+            egl_tls_t::setContext(EGL_NO_CONTEXT);
-+        }
-+    } else {
-+        // this will ALOGE the error
-+        egl_connection_t* const cnx = &gEGLImpl;
-+        result = setError(cnx->egl.eglGetError(), EGL_FALSE);
-+    }
-+    return result;
-+}
-+
-+
-+EGLBoolean eglQueryContext( EGLDisplay dpy, EGLContext ctx,
-+                            EGLint attribute, EGLint *value)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    ContextRef _c(dp.get(), ctx);
-+    if (!_c.get()) return setError(EGL_BAD_CONTEXT, EGL_FALSE);
-+
-+    egl_context_t * const c = get_context(ctx);
-+    return c->cnx->egl.eglQueryContext(
-+            dp->disp.dpy, c->context, attribute, value);
-+
-+}
-+
-+EGLContext eglGetCurrentContext(void)
-+{
-+    // could be called before eglInitialize(), but we wouldn't have a context
-+    // then, and this function would correctly return EGL_NO_CONTEXT.
-+
-+    clearError();
-+
-+    EGLContext ctx = getContext();
-+    return ctx;
-+}
-+
-+EGLSurface eglGetCurrentSurface(EGLint readdraw)
-+{
-+    // could be called before eglInitialize(), but we wouldn't have a context
-+    // then, and this function would correctly return EGL_NO_SURFACE.
-+
-+    clearError();
-+
-+    EGLContext ctx = getContext();
-+    if (ctx) {
-+        egl_context_t const * const c = get_context(ctx);
-+        if (!c) return setError(EGL_BAD_CONTEXT, EGL_NO_SURFACE);
-+        switch (readdraw) {
-+            case EGL_READ: return c->read;
-+            case EGL_DRAW: return c->draw;
-+            default: return setError(EGL_BAD_PARAMETER, EGL_NO_SURFACE);
-+        }
-+    }
-+    return EGL_NO_SURFACE;
-+}
-+
-+EGLDisplay eglGetCurrentDisplay(void)
-+{
-+    // could be called before eglInitialize(), but we wouldn't have a context
-+    // then, and this function would correctly return EGL_NO_DISPLAY.
-+
-+    clearError();
-+
-+    EGLContext ctx = getContext();
-+    if (ctx) {
-+        egl_context_t const * const c = get_context(ctx);
-+        if (!c) return setError(EGL_BAD_CONTEXT, EGL_NO_SURFACE);
-+        return c->dpy;
-+    }
-+    return EGL_NO_DISPLAY;
-+}
-+
-+EGLBoolean eglWaitGL(void)
-+{
-+    clearError();
-+
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (!cnx->dso)
-+        return setError(EGL_BAD_CONTEXT, EGL_FALSE);
-+
-+    return cnx->egl.eglWaitGL();
-+}
-+
-+EGLBoolean eglWaitNative(EGLint engine)
-+{
-+    clearError();
-+
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (!cnx->dso)
-+        return setError(EGL_BAD_CONTEXT, EGL_FALSE);
-+
-+    return cnx->egl.eglWaitNative(engine);
-+}
-+
-+EGLint eglGetError(void)
-+{
-+    EGLint err = EGL_SUCCESS;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso) {
-+        err = cnx->egl.eglGetError();
-+    }
-+    if (err == EGL_SUCCESS) {
-+        err = egl_tls_t::getError();
-+    }
-+    return err;
-+}
-+
-+static __eglMustCastToProperFunctionPointerType findBuiltinWrapper(
-+        const char* procname) {
-+    const egl_connection_t* cnx = &gEGLImpl;
-+    void* proc = NULL;
-+
-+    proc = dlsym(cnx->libEgl, procname);
-+    if (proc) return (__eglMustCastToProperFunctionPointerType)proc;
-+
-+    proc = dlsym(cnx->libGles2, procname);
-+    if (proc) return (__eglMustCastToProperFunctionPointerType)proc;
-+
-+    proc = dlsym(cnx->libGles1, procname);
-+    if (proc) return (__eglMustCastToProperFunctionPointerType)proc;
-+
-+    return NULL;
-+}
-+
-+__eglMustCastToProperFunctionPointerType eglGetProcAddress(const char *procname)
-+{
-+    // eglGetProcAddress() could be the very first function called
-+    // in which case we must make sure we've initialized ourselves, this
-+    // happens the first time egl_get_display() is called.
-+
-+    clearError();
-+
-+    if (egl_init_drivers() == EGL_FALSE) {
-+        setError(EGL_BAD_PARAMETER, NULL);
-+        return  NULL;
-+    }
-+
-+    if (FILTER_EXTENSIONS(procname)) {
-+        return NULL;
-+    }
-+
-+    __eglMustCastToProperFunctionPointerType addr;
-+    addr = findProcAddress(procname, sExtensionMap, NELEM(sExtensionMap));
-+    if (addr) return addr;
-+
-+    addr = findBuiltinWrapper(procname);
-+    if (addr) return addr;
-+
-+    // this protects accesses to sGLExtentionMap and sGLExtentionSlot
-+    pthread_mutex_lock(&sExtensionMapMutex);
-+
-+        /*
-+         * Since eglGetProcAddress() is not associated to anything, it needs
-+         * to return a function pointer that "works" regardless of what
-+         * the current context is.
-+         *
-+         * For this reason, we return a "forwarder", a small stub that takes
-+         * care of calling the function associated with the context
-+         * currently bound.
-+         *
-+         * We first look for extensions we've already resolved, if we're seeing
-+         * this extension for the first time, we go through all our
-+         * implementations and call eglGetProcAddress() and record the
-+         * result in the appropriate implementation hooks and return the
-+         * address of the forwarder corresponding to that hook set.
-+         *
-+         */
-+
-+        const String8 name(procname);
-+        addr = sGLExtentionMap.valueFor(name);
-+        const int slot = sGLExtentionSlot;
-+
-+        ALOGE_IF(slot >= MAX_NUMBER_OF_GL_EXTENSIONS,
-+                "no more slots for eglGetProcAddress(\"%s\")",
-+                procname);
-+
-+        if (!addr && (slot < MAX_NUMBER_OF_GL_EXTENSIONS)) {
-+            bool found = false;
-+
-+            egl_connection_t* const cnx = &gEGLImpl;
-+            if (cnx->dso && cnx->egl.eglGetProcAddress) {
-+                // Extensions are independent of the bound context
-+                addr =
-+                cnx->hooks[egl_connection_t::GLESv1_INDEX]->ext.extensions[slot] =
-+                cnx->hooks[egl_connection_t::GLESv2_INDEX]->ext.extensions[slot] =
-+                        cnx->egl.eglGetProcAddress(procname);
-+                if (addr) found = true;
-+            }
-+
-+            if (found) {
-+                addr = gExtensionForwarders[slot];
-+                sGLExtentionMap.add(name, addr);
-+                sGLExtentionSlot++;
-+            }
-+        }
-+
-+    pthread_mutex_unlock(&sExtensionMapMutex);
-+    return addr;
-+}
-+
-+class FrameCompletionThread : public Thread {
-+public:
-+
-+    static void queueSync(EGLSyncKHR sync) {
-+        static sp<FrameCompletionThread> thread(new FrameCompletionThread);
-+        static bool running = false;
-+        if (!running) {
-+            thread->run("GPUFrameCompletion");
-+            running = true;
-+        }
-+        {
-+            Mutex::Autolock lock(thread->mMutex);
-+            ScopedTrace st(ATRACE_TAG, String8::format("kicked off frame %d",
-+                    thread->mFramesQueued).string());
-+            thread->mQueue.push_back(sync);
-+            thread->mCondition.signal();
-+            thread->mFramesQueued++;
-+            ATRACE_INT("GPU Frames Outstanding", thread->mQueue.size());
-+        }
-+    }
-+
-+private:
-+    FrameCompletionThread() : mFramesQueued(0), mFramesCompleted(0) {}
-+
-+    virtual bool threadLoop() {
-+        EGLSyncKHR sync;
-+        uint32_t frameNum;
-+        {
-+            Mutex::Autolock lock(mMutex);
-+            while (mQueue.isEmpty()) {
-+                mCondition.wait(mMutex);
-+            }
-+            sync = mQueue[0];
-+            frameNum = mFramesCompleted;
-+        }
-+        EGLDisplay dpy = eglGetDisplay(EGL_DEFAULT_DISPLAY);
-+        {
-+            ScopedTrace st(ATRACE_TAG, String8::format("waiting for frame %d",
-+                    frameNum).string());
-+            EGLint result = eglClientWaitSyncKHR(dpy, sync, 0, EGL_FOREVER_KHR);
-+            if (result == EGL_FALSE) {
-+                ALOGE("FrameCompletion: error waiting for fence: %#x", eglGetError());
-+            } else if (result == EGL_TIMEOUT_EXPIRED_KHR) {
-+                ALOGE("FrameCompletion: timeout waiting for fence");
-+            }
-+            eglDestroySyncKHR(dpy, sync);
-+        }
-+        {
-+            Mutex::Autolock lock(mMutex);
-+            mQueue.removeAt(0);
-+            mFramesCompleted++;
-+            ATRACE_INT("GPU Frames Outstanding", mQueue.size());
-+        }
-+        return true;
-+    }
-+
-+    uint32_t mFramesQueued;
-+    uint32_t mFramesCompleted;
-+    Vector<EGLSyncKHR> mQueue;
-+    Condition mCondition;
-+    Mutex mMutex;
-+};
-+
-+EGLBoolean eglSwapBuffersWithDamageKHR(EGLDisplay dpy, EGLSurface draw,
-+        EGLint *rects, EGLint n_rects)
-+{
-+    ATRACE_CALL();
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    SurfaceRef _s(dp.get(), draw);
-+    if (!_s.get())
-+        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-+
-+    egl_surface_t const * const s = get_surface(draw);
-+
-+    if (CC_UNLIKELY(dp->traceGpuCompletion)) {
-+        EGLSyncKHR sync = eglCreateSyncKHR(dpy, EGL_SYNC_FENCE_KHR, NULL);
-+        if (sync != EGL_NO_SYNC_KHR) {
-+            FrameCompletionThread::queueSync(sync);
-+        }
-+    }
-+
-+    if (CC_UNLIKELY(dp->finishOnSwap)) {
-+        uint32_t pixel;
-+        egl_context_t * const c = get_context( egl_tls_t::getContext() );
-+        if (c) {
-+            // glReadPixels() ensures that the frame is complete
-+            s->cnx->hooks[c->version]->gl.glReadPixels(0,0,1,1,
-+                    GL_RGBA,GL_UNSIGNED_BYTE,&pixel);
-+        }
-+    }
-+
-+    if (n_rects == 0) {
-+        return s->cnx->egl.eglSwapBuffers(dp->disp.dpy, s->surface);
-+    }
-+
-+    Vector<android_native_rect_t> androidRects;
-+    for (int r = 0; r < n_rects; ++r) {
-+        int offset = r * 4;
-+        int x = rects[offset];
-+        int y = rects[offset + 1];
-+        int width = rects[offset + 2];
-+        int height = rects[offset + 3];
-+        android_native_rect_t androidRect;
-+        androidRect.left = x;
-+        androidRect.top = y + height;
-+        androidRect.right = x + width;
-+        androidRect.bottom = y;
-+        androidRects.push_back(androidRect);
-+    }
-+    native_window_set_surface_damage(s->win.get(), androidRects.array(),
-+            androidRects.size());
-+
-+    if (s->cnx->egl.eglSwapBuffersWithDamageKHR) {
-+        return s->cnx->egl.eglSwapBuffersWithDamageKHR(dp->disp.dpy, s->surface,
-+                rects, n_rects);
-+    } else {
-+        return s->cnx->egl.eglSwapBuffers(dp->disp.dpy, s->surface);
-+    }
-+}
-+
-+EGLBoolean eglSwapBuffers(EGLDisplay dpy, EGLSurface surface)
-+{
-+    return eglSwapBuffersWithDamageKHR(dpy, surface, NULL, 0);
-+}
-+
-+EGLBoolean eglCopyBuffers(  EGLDisplay dpy, EGLSurface surface,
-+                            NativePixmapType target)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    SurfaceRef _s(dp.get(), surface);
-+    if (!_s.get())
-+        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-+
-+    egl_surface_t const * const s = get_surface(surface);
-+    return s->cnx->egl.eglCopyBuffers(dp->disp.dpy, s->surface, target);
-+}
-+
-+const char* eglQueryString(EGLDisplay dpy, EGLint name)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return (const char *) NULL;
-+
-+    switch (name) {
-+        case EGL_VENDOR:
-+            return dp->getVendorString();
-+        case EGL_VERSION:
-+            return dp->getVersionString();
-+        case EGL_EXTENSIONS:
-+            return dp->getExtensionString();
-+        case EGL_CLIENT_APIS:
-+            return dp->getClientApiString();
-+    }
-+    return setError(EGL_BAD_PARAMETER, (const char *)0);
-+}
-+
-+EGLAPI const char* eglQueryStringImplementationANDROID(EGLDisplay dpy, EGLint name)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return (const char *) NULL;
-+
-+    switch (name) {
-+        case EGL_VENDOR:
-+            return dp->disp.queryString.vendor;
-+        case EGL_VERSION:
-+            return dp->disp.queryString.version;
-+        case EGL_EXTENSIONS:
-+            return dp->disp.queryString.extensions;
-+        case EGL_CLIENT_APIS:
-+            return dp->disp.queryString.clientApi;
-+    }
-+    return setError(EGL_BAD_PARAMETER, (const char *)0);
-+}
-+
-+// ----------------------------------------------------------------------------
-+// EGL 1.1
-+// ----------------------------------------------------------------------------
-+
-+EGLBoolean eglSurfaceAttrib(
-+        EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint value)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    SurfaceRef _s(dp.get(), surface);
-+    if (!_s.get())
-+        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-+
-+    egl_surface_t * const s = get_surface(surface);
-+
-+    if (attribute == EGL_FRONT_BUFFER_AUTO_REFRESH_ANDROID) {
-+        int err = native_window_set_auto_refresh(s->win.get(),
-+            value ? true : false);
-+        return (err == NO_ERROR) ? EGL_TRUE :
-+            setError(EGL_BAD_SURFACE, EGL_FALSE);
-+    }
-+
-+#if ENABLE_EGL_ANDROID_GET_FRAME_TIMESTAMPS
-+    if (attribute == EGL_TIMESTAMPS_ANDROID) {
-+        s->enableTimestamps = value;
-+        return EGL_TRUE;
-+    }
-+#endif
-+
-+    if (s->cnx->egl.eglSurfaceAttrib) {
-+        return s->cnx->egl.eglSurfaceAttrib(
-+                dp->disp.dpy, s->surface, attribute, value);
-+    }
-+    return setError(EGL_BAD_SURFACE, EGL_FALSE);
-+}
-+
-+EGLBoolean eglBindTexImage(
-+        EGLDisplay dpy, EGLSurface surface, EGLint buffer)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    SurfaceRef _s(dp.get(), surface);
-+    if (!_s.get())
-+        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-+
-+    egl_surface_t const * const s = get_surface(surface);
-+    if (s->cnx->egl.eglBindTexImage) {
-+        return s->cnx->egl.eglBindTexImage(
-+                dp->disp.dpy, s->surface, buffer);
-+    }
-+    return setError(EGL_BAD_SURFACE, EGL_FALSE);
-+}
-+
-+EGLBoolean eglReleaseTexImage(
-+        EGLDisplay dpy, EGLSurface surface, EGLint buffer)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    SurfaceRef _s(dp.get(), surface);
-+    if (!_s.get())
-+        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-+
-+    egl_surface_t const * const s = get_surface(surface);
-+    if (s->cnx->egl.eglReleaseTexImage) {
-+        return s->cnx->egl.eglReleaseTexImage(
-+                dp->disp.dpy, s->surface, buffer);
-+    }
-+    return setError(EGL_BAD_SURFACE, EGL_FALSE);
-+}
-+
-+EGLBoolean eglSwapInterval(EGLDisplay dpy, EGLint interval)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    EGLBoolean res = EGL_TRUE;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglSwapInterval) {
-+        res = cnx->egl.eglSwapInterval(dp->disp.dpy, interval);
-+    }
-+
-+    return res;
-+}
-+
-+
-+// ----------------------------------------------------------------------------
-+// EGL 1.2
-+// ----------------------------------------------------------------------------
-+
-+EGLBoolean eglWaitClient(void)
-+{
-+    clearError();
-+
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (!cnx->dso)
-+        return setError(EGL_BAD_CONTEXT, EGL_FALSE);
-+
-+    EGLBoolean res;
-+    if (cnx->egl.eglWaitClient) {
-+        res = cnx->egl.eglWaitClient();
-+    } else {
-+        res = cnx->egl.eglWaitGL();
-+    }
-+    return res;
-+}
-+
-+EGLBoolean eglBindAPI(EGLenum api)
-+{
-+    clearError();
-+
-+    if (egl_init_drivers() == EGL_FALSE) {
-+        return setError(EGL_BAD_PARAMETER, EGL_FALSE);
-+    }
-+
-+    // bind this API on all EGLs
-+    EGLBoolean res = EGL_TRUE;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglBindAPI) {
-+        res = cnx->egl.eglBindAPI(api);
-+    }
-+    return res;
-+}
-+
-+EGLenum eglQueryAPI(void)
-+{
-+    clearError();
-+
-+    if (egl_init_drivers() == EGL_FALSE) {
-+        return setError(EGL_BAD_PARAMETER, EGL_FALSE);
-+    }
-+
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglQueryAPI) {
-+        return cnx->egl.eglQueryAPI();
-+    }
-+
-+    // or, it can only be OpenGL ES
-+    return EGL_OPENGL_ES_API;
-+}
-+
-+EGLBoolean eglReleaseThread(void)
-+{
-+    clearError();
-+
-+    // If there is context bound to the thread, release it
-+    egl_display_t::loseCurrent(get_context(getContext()));
-+
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglReleaseThread) {
-+        cnx->egl.eglReleaseThread();
-+    }
-+    egl_tls_t::clearTLS();
-+    return EGL_TRUE;
-+}
-+
-+EGLSurface eglCreatePbufferFromClientBuffer(
-+          EGLDisplay dpy, EGLenum buftype, EGLClientBuffer buffer,
-+          EGLConfig config, const EGLint *attrib_list)
-+{
-+    clearError();
-+
-+    egl_connection_t* cnx = NULL;
-+    const egl_display_ptr dp = validate_display_connection(dpy, cnx);
-+    if (!dp) return EGL_FALSE;
-+    if (cnx->egl.eglCreatePbufferFromClientBuffer) {
-+        return cnx->egl.eglCreatePbufferFromClientBuffer(
-+                dp->disp.dpy, buftype, buffer, config, attrib_list);
-+    }
-+    return setError(EGL_BAD_CONFIG, EGL_NO_SURFACE);
-+}
-+
-+// ----------------------------------------------------------------------------
-+// EGL_EGLEXT_VERSION 3
-+// ----------------------------------------------------------------------------
-+
-+EGLBoolean eglLockSurfaceKHR(EGLDisplay dpy, EGLSurface surface,
-+        const EGLint *attrib_list)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    SurfaceRef _s(dp.get(), surface);
-+    if (!_s.get())
-+        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-+
-+    egl_surface_t const * const s = get_surface(surface);
-+    if (s->cnx->egl.eglLockSurfaceKHR) {
-+        return s->cnx->egl.eglLockSurfaceKHR(
-+                dp->disp.dpy, s->surface, attrib_list);
-+    }
-+    return setError(EGL_BAD_DISPLAY, EGL_FALSE);
-+}
-+
-+EGLBoolean eglUnlockSurfaceKHR(EGLDisplay dpy, EGLSurface surface)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    SurfaceRef _s(dp.get(), surface);
-+    if (!_s.get())
-+        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-+
-+    egl_surface_t const * const s = get_surface(surface);
-+    if (s->cnx->egl.eglUnlockSurfaceKHR) {
-+        return s->cnx->egl.eglUnlockSurfaceKHR(dp->disp.dpy, s->surface);
-+    }
-+    return setError(EGL_BAD_DISPLAY, EGL_FALSE);
-+}
-+
-+EGLImageKHR eglCreateImageKHR(EGLDisplay dpy, EGLContext ctx, EGLenum target,
-+        EGLClientBuffer buffer, const EGLint *attrib_list)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_NO_IMAGE_KHR;
-+
-+    ContextRef _c(dp.get(), ctx);
-+    egl_context_t * const c = _c.get();
-+
-+    EGLImageKHR result = EGL_NO_IMAGE_KHR;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglCreateImageKHR) {
-+        result = cnx->egl.eglCreateImageKHR(
-+                dp->disp.dpy,
-+                c ? c->context : EGL_NO_CONTEXT,
-+                target, buffer, attrib_list);
-+    }
-+    return result;
-+}
-+
-+EGLBoolean eglDestroyImageKHR(EGLDisplay dpy, EGLImageKHR img)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    EGLBoolean result = EGL_FALSE;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglDestroyImageKHR) {
-+        result = cnx->egl.eglDestroyImageKHR(dp->disp.dpy, img);
-+    }
-+    return result;
-+}
-+
-+// ----------------------------------------------------------------------------
-+// EGL_EGLEXT_VERSION 5
-+// ----------------------------------------------------------------------------
-+
-+
-+EGLSyncKHR eglCreateSyncKHR(EGLDisplay dpy, EGLenum type, const EGLint *attrib_list)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_NO_SYNC_KHR;
-+
-+    EGLSyncKHR result = EGL_NO_SYNC_KHR;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglCreateSyncKHR) {
-+        result = cnx->egl.eglCreateSyncKHR(dp->disp.dpy, type, attrib_list);
-+    }
-+    return result;
-+}
-+
-+EGLBoolean eglDestroySyncKHR(EGLDisplay dpy, EGLSyncKHR sync)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    EGLBoolean result = EGL_FALSE;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglDestroySyncKHR) {
-+        result = cnx->egl.eglDestroySyncKHR(dp->disp.dpy, sync);
-+    }
-+    return result;
-+}
-+
-+EGLBoolean eglSignalSyncKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLenum mode) {
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    EGLBoolean result = EGL_FALSE;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglSignalSyncKHR) {
-+        result = cnx->egl.eglSignalSyncKHR(
-+                dp->disp.dpy, sync, mode);
-+    }
-+    return result;
-+}
-+
-+EGLint eglClientWaitSyncKHR(EGLDisplay dpy, EGLSyncKHR sync,
-+        EGLint flags, EGLTimeKHR timeout)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    EGLBoolean result = EGL_FALSE;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglClientWaitSyncKHR) {
-+        result = cnx->egl.eglClientWaitSyncKHR(
-+                dp->disp.dpy, sync, flags, timeout);
-+    }
-+    return result;
-+}
-+
-+EGLBoolean eglGetSyncAttribKHR(EGLDisplay dpy, EGLSyncKHR sync,
-+        EGLint attribute, EGLint *value)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    EGLBoolean result = EGL_FALSE;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglGetSyncAttribKHR) {
-+        result = cnx->egl.eglGetSyncAttribKHR(
-+                dp->disp.dpy, sync, attribute, value);
-+    }
-+    return result;
-+}
-+
-+EGLStreamKHR eglCreateStreamKHR(EGLDisplay dpy, const EGLint *attrib_list)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_NO_STREAM_KHR;
-+
-+    EGLStreamKHR result = EGL_NO_STREAM_KHR;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglCreateStreamKHR) {
-+        result = cnx->egl.eglCreateStreamKHR(
-+                dp->disp.dpy, attrib_list);
-+    }
-+    return result;
-+}
-+
-+EGLBoolean eglDestroyStreamKHR(EGLDisplay dpy, EGLStreamKHR stream)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    EGLBoolean result = EGL_FALSE;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglDestroyStreamKHR) {
-+        result = cnx->egl.eglDestroyStreamKHR(
-+                dp->disp.dpy, stream);
-+    }
-+    return result;
-+}
-+
-+EGLBoolean eglStreamAttribKHR(EGLDisplay dpy, EGLStreamKHR stream,
-+        EGLenum attribute, EGLint value)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    EGLBoolean result = EGL_FALSE;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglStreamAttribKHR) {
-+        result = cnx->egl.eglStreamAttribKHR(
-+                dp->disp.dpy, stream, attribute, value);
-+    }
-+    return result;
-+}
-+
-+EGLBoolean eglQueryStreamKHR(EGLDisplay dpy, EGLStreamKHR stream,
-+        EGLenum attribute, EGLint *value)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    EGLBoolean result = EGL_FALSE;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglQueryStreamKHR) {
-+        result = cnx->egl.eglQueryStreamKHR(
-+                dp->disp.dpy, stream, attribute, value);
-+    }
-+    return result;
-+}
-+
-+EGLBoolean eglQueryStreamu64KHR(EGLDisplay dpy, EGLStreamKHR stream,
-+        EGLenum attribute, EGLuint64KHR *value)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    EGLBoolean result = EGL_FALSE;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglQueryStreamu64KHR) {
-+        result = cnx->egl.eglQueryStreamu64KHR(
-+                dp->disp.dpy, stream, attribute, value);
-+    }
-+    return result;
-+}
-+
-+EGLBoolean eglQueryStreamTimeKHR(EGLDisplay dpy, EGLStreamKHR stream,
-+        EGLenum attribute, EGLTimeKHR *value)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    EGLBoolean result = EGL_FALSE;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglQueryStreamTimeKHR) {
-+        result = cnx->egl.eglQueryStreamTimeKHR(
-+                dp->disp.dpy, stream, attribute, value);
-+    }
-+    return result;
-+}
-+
-+EGLSurface eglCreateStreamProducerSurfaceKHR(EGLDisplay dpy, EGLConfig config,
-+        EGLStreamKHR stream, const EGLint *attrib_list)
-+{
-+    clearError();
-+
-+    egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_NO_SURFACE;
-+
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglCreateStreamProducerSurfaceKHR) {
-+        EGLSurface surface = cnx->egl.eglCreateStreamProducerSurfaceKHR(
-+                dp->disp.dpy, config, stream, attrib_list);
-+        if (surface != EGL_NO_SURFACE) {
-+            egl_surface_t* s = new egl_surface_t(dp.get(), config, NULL,
-+                    surface, cnx);
-+            return s;
-+        }
-+    }
-+    return EGL_NO_SURFACE;
-+}
-+
-+EGLBoolean eglStreamConsumerGLTextureExternalKHR(EGLDisplay dpy,
-+        EGLStreamKHR stream)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    EGLBoolean result = EGL_FALSE;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglStreamConsumerGLTextureExternalKHR) {
-+        result = cnx->egl.eglStreamConsumerGLTextureExternalKHR(
-+                dp->disp.dpy, stream);
-+    }
-+    return result;
-+}
-+
-+EGLBoolean eglStreamConsumerAcquireKHR(EGLDisplay dpy,
-+        EGLStreamKHR stream)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    EGLBoolean result = EGL_FALSE;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglStreamConsumerAcquireKHR) {
-+        result = cnx->egl.eglStreamConsumerAcquireKHR(
-+                dp->disp.dpy, stream);
-+    }
-+    return result;
-+}
-+
-+EGLBoolean eglStreamConsumerReleaseKHR(EGLDisplay dpy,
-+        EGLStreamKHR stream)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    EGLBoolean result = EGL_FALSE;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglStreamConsumerReleaseKHR) {
-+        result = cnx->egl.eglStreamConsumerReleaseKHR(
-+                dp->disp.dpy, stream);
-+    }
-+    return result;
-+}
-+
-+EGLNativeFileDescriptorKHR eglGetStreamFileDescriptorKHR(
-+        EGLDisplay dpy, EGLStreamKHR stream)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_NO_FILE_DESCRIPTOR_KHR;
-+
-+    EGLNativeFileDescriptorKHR result = EGL_NO_FILE_DESCRIPTOR_KHR;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglGetStreamFileDescriptorKHR) {
-+        result = cnx->egl.eglGetStreamFileDescriptorKHR(
-+                dp->disp.dpy, stream);
-+    }
-+    return result;
-+}
-+
-+EGLStreamKHR eglCreateStreamFromFileDescriptorKHR(
-+        EGLDisplay dpy, EGLNativeFileDescriptorKHR file_descriptor)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_NO_STREAM_KHR;
-+
-+    EGLStreamKHR result = EGL_NO_STREAM_KHR;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglCreateStreamFromFileDescriptorKHR) {
-+        result = cnx->egl.eglCreateStreamFromFileDescriptorKHR(
-+                dp->disp.dpy, file_descriptor);
-+    }
-+    return result;
-+}
-+
-+// ----------------------------------------------------------------------------
-+// EGL_EGLEXT_VERSION 15
-+// ----------------------------------------------------------------------------
-+
-+EGLint eglWaitSyncKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLint flags) {
-+    clearError();
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+    EGLint result = EGL_FALSE;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglWaitSyncKHR) {
-+        result = cnx->egl.eglWaitSyncKHR(dp->disp.dpy, sync, flags);
-+    }
-+    return result;
-+}
-+
-+// ----------------------------------------------------------------------------
-+// ANDROID extensions
-+// ----------------------------------------------------------------------------
-+
-+EGLint eglDupNativeFenceFDANDROID(EGLDisplay dpy, EGLSyncKHR sync)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_NO_NATIVE_FENCE_FD_ANDROID;
-+
-+    EGLint result = EGL_NO_NATIVE_FENCE_FD_ANDROID;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglDupNativeFenceFDANDROID) {
-+        result = cnx->egl.eglDupNativeFenceFDANDROID(dp->disp.dpy, sync);
-+    }
-+    return result;
-+}
-+
-+EGLBoolean eglPresentationTimeANDROID(EGLDisplay dpy, EGLSurface surface,
-+        EGLnsecsANDROID time)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) {
-+        return EGL_FALSE;
-+    }
-+
-+    SurfaceRef _s(dp.get(), surface);
-+    if (!_s.get()) {
-+        setError(EGL_BAD_SURFACE, EGL_FALSE);
-+        return EGL_FALSE;
-+    }
-+
-+    egl_surface_t const * const s = get_surface(surface);
-+    native_window_set_buffers_timestamp(s->win.get(), time);
-+
-+    return EGL_TRUE;
-+}
-+
-+EGLClientBuffer eglCreateNativeClientBufferANDROID(const EGLint *attrib_list)
-+{
-+    clearError();
-+
-+    int usage = 0;
-+    uint32_t width = 0;
-+    uint32_t height = 0;
-+    uint32_t format = 0;
-+    uint32_t red_size = 0;
-+    uint32_t green_size = 0;
-+    uint32_t blue_size = 0;
-+    uint32_t alpha_size = 0;
-+
-+#define GET_NONNEGATIVE_VALUE(case_name, target) \
-+    case case_name: \
-+        if (value >= 0) { \
-+            target = value; \
-+        } else { \
-+            return setError(EGL_BAD_PARAMETER, (EGLClientBuffer)0); \
-+        } \
-+        break
-+
-+    if (attrib_list) {
-+        while (*attrib_list != EGL_NONE) {
-+            GLint attr = *attrib_list++;
-+            GLint value = *attrib_list++;
-+            switch (attr) {
-+                GET_NONNEGATIVE_VALUE(EGL_WIDTH, width);
-+                GET_NONNEGATIVE_VALUE(EGL_HEIGHT, height);
-+                GET_NONNEGATIVE_VALUE(EGL_RED_SIZE, red_size);
-+                GET_NONNEGATIVE_VALUE(EGL_GREEN_SIZE, green_size);
-+                GET_NONNEGATIVE_VALUE(EGL_BLUE_SIZE, blue_size);
-+                GET_NONNEGATIVE_VALUE(EGL_ALPHA_SIZE, alpha_size);
-+                case EGL_NATIVE_BUFFER_USAGE_ANDROID:
-+                    if (value & EGL_NATIVE_BUFFER_USAGE_PROTECTED_BIT_ANDROID) {
-+                        usage |= GRALLOC_USAGE_PROTECTED;
-+                    }
-+                    if (value & EGL_NATIVE_BUFFER_USAGE_RENDERBUFFER_BIT_ANDROID) {
-+                        usage |= GRALLOC_USAGE_HW_RENDER;
-+                    }
-+                    if (value & EGL_NATIVE_BUFFER_USAGE_TEXTURE_BIT_ANDROID) {
-+                        usage |= GRALLOC_USAGE_HW_TEXTURE;
-+                    }
-+                    break;
-+                default:
-+                    return setError(EGL_BAD_PARAMETER, (EGLClientBuffer)0);
-+            }
-+        }
-+    }
-+#undef GET_NONNEGATIVE_VALUE
-+
-+    // Validate format.
-+    if (red_size == 8 && green_size == 8 && blue_size == 8) {
-+        if (alpha_size == 8) {
-+            format = HAL_PIXEL_FORMAT_RGBA_8888;
-+        } else {
-+            format = HAL_PIXEL_FORMAT_RGB_888;
-+        }
-+    } else if (red_size == 5 && green_size == 6 && blue_size == 5 &&
-+               alpha_size == 0) {
-+        format = HAL_PIXEL_FORMAT_RGB_565;
-+    } else {
-+        ALOGE("Invalid native pixel format { r=%d, g=%d, b=%d, a=%d }",
-+                red_size, green_size, blue_size, alpha_size);
-+        return setError(EGL_BAD_PARAMETER, (EGLClientBuffer)0);
-+    }
-+
-+#define CHECK_ERROR_CONDITION(message) \
-+    if (err != NO_ERROR) { \
-+        ALOGE(message); \
-+        goto error_condition; \
-+    }
-+
-+    // The holder is used to destroy the buffer if an error occurs.
-+    GraphicBuffer* gBuffer = new GraphicBuffer();
-+    sp<IServiceManager> sm = defaultServiceManager();
-+    sp<IBinder> surfaceFlinger = sm->getService(String16("SurfaceFlinger"));
-+    sp<IBinder> allocator;
-+    Parcel sc_data, sc_reply, data, reply;
-+    status_t err = NO_ERROR;
-+    if (sm == NULL) {
-+        ALOGE("Unable to connect to ServiceManager");
-+        goto error_condition;
-+    }
-+
-+    // Obtain an allocator.
-+    if (surfaceFlinger == NULL) {
-+        ALOGE("Unable to connect to SurfaceFlinger");
-+        goto error_condition;
-+    }
-+    sc_data.writeInterfaceToken(String16("android.ui.ISurfaceComposer"));
-+    err = surfaceFlinger->transact(
-+            BnSurfaceComposer::CREATE_GRAPHIC_BUFFER_ALLOC, sc_data, &sc_reply);
-+    CHECK_ERROR_CONDITION("Unable to obtain allocator from SurfaceFlinger");
-+    allocator = sc_reply.readStrongBinder();
-+
-+    if (allocator == NULL) {
-+        ALOGE("Unable to obtain an ISurfaceComposer");
-+        goto error_condition;
-+    }
-+    data.writeInterfaceToken(String16("android.ui.IGraphicBufferAlloc"));
-+    err = data.writeUint32(width);
-+    CHECK_ERROR_CONDITION("Unable to write width");
-+    err = data.writeUint32(height);
-+    CHECK_ERROR_CONDITION("Unable to write height");
-+    err = data.writeInt32(static_cast<int32_t>(format));
-+    CHECK_ERROR_CONDITION("Unable to write format");
-+    err = data.writeUint32(usage);
-+    CHECK_ERROR_CONDITION("Unable to write usage");
-+    err = data.writeUtf8AsUtf16(
-+            std::string("[eglCreateNativeClientBufferANDROID pid ") +
-+            std::to_string(getpid()) + ']');
-+    CHECK_ERROR_CONDITION("Unable to write requestor name");
-+    err = allocator->transact(IBinder::FIRST_CALL_TRANSACTION, data,
-+            &reply);
-+    CHECK_ERROR_CONDITION(
-+            "Unable to request buffer allocation from surface composer");
-+    err = reply.readInt32();
-+    CHECK_ERROR_CONDITION("Unable to obtain buffer from surface composer");
-+    err = reply.read(*gBuffer);
-+    CHECK_ERROR_CONDITION("Unable to read buffer from surface composer");
-+
-+    err = gBuffer->initCheck();
-+    if (err != NO_ERROR) {
-+        ALOGE("Unable to create native buffer { w=%d, h=%d, f=%d, u=%#x }: %#x",
-+                width, height, format, usage, err);
-+        goto error_condition;
-+    }
-+    ALOGD("Created new native buffer %p { w=%d, h=%d, f=%d, u=%#x }",
-+            gBuffer, width, height, format, usage);
-+    return static_cast<EGLClientBuffer>(gBuffer->getNativeBuffer());
-+
-+#undef CHECK_ERROR_CONDITION
-+
-+error_condition:
-+    // Delete the buffer.
-+    sp<GraphicBuffer> holder(gBuffer);
-+    return setError(EGL_BAD_ALLOC, (EGLClientBuffer)0);
-+}
-+
-+// ----------------------------------------------------------------------------
-+// NVIDIA extensions
-+// ----------------------------------------------------------------------------
-+EGLuint64NV eglGetSystemTimeFrequencyNV()
-+{
-+    clearError();
-+
-+    if (egl_init_drivers() == EGL_FALSE) {
-+        return setError(EGL_BAD_PARAMETER, EGL_FALSE);
-+    }
-+
-+    EGLuint64NV ret = 0;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+
-+    if (cnx->dso && cnx->egl.eglGetSystemTimeFrequencyNV) {
-+        return cnx->egl.eglGetSystemTimeFrequencyNV();
-+    }
-+
-+    return setErrorQuiet(EGL_BAD_DISPLAY, 0);
-+}
-+
-+EGLuint64NV eglGetSystemTimeNV()
-+{
-+    clearError();
-+
-+    if (egl_init_drivers() == EGL_FALSE) {
-+        return setError(EGL_BAD_PARAMETER, EGL_FALSE);
-+    }
-+
-+    EGLuint64NV ret = 0;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+
-+    if (cnx->dso && cnx->egl.eglGetSystemTimeNV) {
-+        return cnx->egl.eglGetSystemTimeNV();
-+    }
-+
-+    return setErrorQuiet(EGL_BAD_DISPLAY, 0);
-+}
-+
-+// ----------------------------------------------------------------------------
-+// Partial update extension
-+// ----------------------------------------------------------------------------
-+EGLBoolean eglSetDamageRegionKHR(EGLDisplay dpy, EGLSurface surface,
-+        EGLint *rects, EGLint n_rects)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) {
-+        setError(EGL_BAD_DISPLAY, EGL_FALSE);
-+        return EGL_FALSE;
-+    }
-+
-+    SurfaceRef _s(dp.get(), surface);
-+    if (!_s.get()) {
-+        setError(EGL_BAD_SURFACE, EGL_FALSE);
-+        return EGL_FALSE;
-+    }
-+
-+    egl_surface_t const * const s = get_surface(surface);
-+    if (s->cnx->egl.eglSetDamageRegionKHR) {
-+        return s->cnx->egl.eglSetDamageRegionKHR(dp->disp.dpy, s->surface,
-+                rects, n_rects);
-+    }
-+
-+    return EGL_FALSE;
-+}
-+
-+EGLBoolean eglGetFrameTimestampsANDROID(EGLDisplay dpy, EGLSurface surface,
-+        EGLint framesAgo, EGLint numTimestamps, const EGLint *timestamps,
-+        EGLnsecsANDROID *values)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) {
-+        setError(EGL_BAD_DISPLAY, EGL_FALSE);
-+        return EGL_FALSE;
-+    }
-+
-+    SurfaceRef _s(dp.get(), surface);
-+    if (!_s.get()) {
-+        setError(EGL_BAD_SURFACE, EGL_FALSE);
-+        return EGL_FALSE;
-+    }
-+
-+    egl_surface_t const * const s = get_surface(surface);
-+
-+    if (!s->enableTimestamps) {
-+        setError(EGL_BAD_SURFACE, EGL_FALSE);
-+        return EGL_FALSE;
-+    }
-+
-+    nsecs_t* postedTime = nullptr;
-+    nsecs_t* acquireTime = nullptr;
-+    nsecs_t* refreshStartTime = nullptr;
-+    nsecs_t* GLCompositionDoneTime = nullptr;
-+    nsecs_t* displayRetireTime = nullptr;
-+    nsecs_t* releaseTime = nullptr;
-+
-+    for (int i = 0; i < numTimestamps; i++) {
-+        switch (timestamps[i]) {
-+            case EGL_QUEUE_TIME_ANDROID:
-+                postedTime = &values[i];
-+                break;
-+            case EGL_RENDERING_COMPLETE_TIME_ANDROID:
-+                acquireTime = &values[i];
-+                break;
-+            case EGL_COMPOSITION_START_TIME_ANDROID:
-+                refreshStartTime = &values[i];
-+                break;
-+            case EGL_COMPOSITION_FINISHED_TIME_ANDROID:
-+                GLCompositionDoneTime = &values[i];
-+                break;
-+            case EGL_DISPLAY_RETIRE_TIME_ANDROID:
-+                displayRetireTime = &values[i];
-+                break;
-+            case EGL_READS_DONE_TIME_ANDROID:
-+                releaseTime = &values[i];
-+                break;
-+            default:
-+                setError(EGL_BAD_PARAMETER, EGL_FALSE);
-+                return EGL_FALSE;
-+        }
-+    }
-+
-+    status_t ret = native_window_get_frame_timestamps(s->win.get(), framesAgo,
-+            postedTime, acquireTime, refreshStartTime, GLCompositionDoneTime,
-+            displayRetireTime, releaseTime);
-+
-+    if (ret != NO_ERROR) {
-+        setError(EGL_BAD_ACCESS, EGL_FALSE);
-+        return EGL_FALSE;
-+    }
-+
-+    return EGL_TRUE;
-+}
-+
-+EGLBoolean eglQueryTimestampSupportedANDROID(EGLDisplay dpy, EGLSurface surface,
-+        EGLint timestamp)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) {
-+        setError(EGL_BAD_DISPLAY, EGL_FALSE);
-+        return EGL_FALSE;
-+    }
-+
-+    SurfaceRef _s(dp.get(), surface);
-+    if (!_s.get()) {
-+        setError(EGL_BAD_SURFACE, EGL_FALSE);
-+        return EGL_FALSE;
-+    }
-+
-+    switch (timestamp) {
-+#if ENABLE_EGL_ANDROID_GET_FRAME_TIMESTAMPS
-+        case EGL_QUEUE_TIME_ANDROID:
-+        case EGL_RENDERING_COMPLETE_TIME_ANDROID:
-+        case EGL_COMPOSITION_START_TIME_ANDROID:
-+        case EGL_COMPOSITION_FINISHED_TIME_ANDROID:
-+        case EGL_DISPLAY_RETIRE_TIME_ANDROID:
-+        case EGL_READS_DONE_TIME_ANDROID:
-+            return EGL_TRUE;
-+#endif
-+        default:
-+            return EGL_FALSE;
-+    }
-+}
diff -Naur frameworksRaw/native/opengl/libs/EGL/eglApi.cpp.orig.rej frameworksModified/native/opengl/libs/EGL/eglApi.cpp.orig.rej
--- frameworksRaw/native/opengl/libs/EGL/eglApi.cpp.orig.rej	2017-07-06 15:34:21.314456285 +0530
+++ frameworksModified/native/opengl/libs/EGL/eglApi.cpp.orig.rej	1970-01-01 05:30:00.000000000 +0530
@@ -1,2120 +0,0 @@
---- native/opengl/libs/EGL/eglApi.cpp.orig	1970-01-01 05:30:00.000000000 +0530
-+++ native/opengl/libs/EGL/eglApi.cpp.orig	2017-07-06 13:50:15.207676932 +0530
-@@ -0,0 +1,2117 @@
-+/*
-+ ** Copyright 2007, The Android Open Source Project
-+ **
-+ ** Licensed under the Apache License, Version 2.0 (the "License");
-+ ** you may not use this file except in compliance with the License.
-+ ** You may obtain a copy of the License at
-+ **
-+ **     http://www.apache.org/licenses/LICENSE-2.0
-+ **
-+ ** Unless required by applicable law or agreed to in writing, software
-+ ** distributed under the License is distributed on an "AS IS" BASIS,
-+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-+ ** See the License for the specific language governing permissions and
-+ ** limitations under the License.
-+ */
-+
-+#define ATRACE_TAG ATRACE_TAG_GRAPHICS
-+
-+#include <dlfcn.h>
-+#include <ctype.h>
-+#include <stdlib.h>
-+#include <string.h>
-+
-+#include <hardware/gralloc.h>
-+#include <system/window.h>
-+
-+#include <EGL/egl.h>
-+#include <EGL/eglext.h>
-+
-+#include <cutils/log.h>
-+#include <cutils/atomic.h>
-+#include <cutils/compiler.h>
-+#include <cutils/properties.h>
-+#include <cutils/memory.h>
-+
-+#include <gui/ISurfaceComposer.h>
-+
-+#include <ui/GraphicBuffer.h>
-+
-+#include <utils/KeyedVector.h>
-+#include <utils/SortedVector.h>
-+#include <utils/String8.h>
-+#include <utils/Trace.h>
-+
-+#include "binder/Binder.h"
-+#include "binder/Parcel.h"
-+#include "binder/IServiceManager.h"
-+
-+#include "../egl_impl.h"
-+#include "../hooks.h"
-+
-+#include "egl_display.h"
-+#include "egl_object.h"
-+#include "egl_tls.h"
-+#include "egldefs.h"
-+
-+using namespace android;
-+
-+// This extension has not been ratified yet, so can't be shipped.
-+// Implementation is incomplete and untested.
-+#define ENABLE_EGL_KHR_GL_COLORSPACE 0
-+
-+#define ENABLE_EGL_ANDROID_GET_FRAME_TIMESTAMPS 0
-+
-+// ----------------------------------------------------------------------------
-+
-+namespace android {
-+
-+struct extention_map_t {
-+    const char* name;
-+    __eglMustCastToProperFunctionPointerType address;
-+};
-+
-+/*
-+ * This is the list of EGL extensions exposed to applications.
-+ *
-+ * Some of them (gBuiltinExtensionString) are implemented entirely in this EGL
-+ * wrapper and are always available.
-+ *
-+ * The rest (gExtensionString) depend on support in the EGL driver, and are
-+ * only available if the driver supports them. However, some of these must be
-+ * supported because they are used by the Android system itself; these are
-+ * listed as mandatory below and are required by the CDD. The system *assumes*
-+ * the mandatory extensions are present and may not function properly if some
-+ * are missing.
-+ *
-+ * NOTE: Both strings MUST have a single space as the last character.
-+ */
-+extern char const * const gBuiltinExtensionString =
-+        "EGL_KHR_get_all_proc_addresses "
-+        "EGL_ANDROID_presentation_time "
-+        "EGL_KHR_swap_buffers_with_damage "
-+        "EGL_ANDROID_create_native_client_buffer "
-+        "EGL_ANDROID_front_buffer_auto_refresh "
-+#if ENABLE_EGL_ANDROID_GET_FRAME_TIMESTAMPS
-+        "EGL_ANDROID_get_frame_timestamps "
-+#endif
-+        ;
-+extern char const * const gExtensionString  =
-+        "EGL_KHR_image "                        // mandatory
-+        "EGL_KHR_image_base "                   // mandatory
-+        "EGL_KHR_image_pixmap "
-+        "EGL_KHR_lock_surface "
-+#if (ENABLE_EGL_KHR_GL_COLORSPACE != 0)
-+        "EGL_KHR_gl_colorspace "
-+#endif
-+        "EGL_KHR_gl_texture_2D_image "
-+        "EGL_KHR_gl_texture_3D_image "
-+        "EGL_KHR_gl_texture_cubemap_image "
-+        "EGL_KHR_gl_renderbuffer_image "
-+        "EGL_KHR_reusable_sync "
-+        "EGL_KHR_fence_sync "
-+        "EGL_KHR_create_context "
-+        "EGL_KHR_config_attribs "
-+        "EGL_KHR_surfaceless_context "
-+        "EGL_KHR_stream "
-+        "EGL_KHR_stream_fifo "
-+        "EGL_KHR_stream_producer_eglsurface "
-+        "EGL_KHR_stream_consumer_gltexture "
-+        "EGL_KHR_stream_cross_process_fd "
-+        "EGL_EXT_create_context_robustness "
-+        "EGL_NV_system_time "
-+        "EGL_ANDROID_image_native_buffer "      // mandatory
-+        "EGL_KHR_wait_sync "                    // strongly recommended
-+        "EGL_ANDROID_recordable "               // mandatory
-+        "EGL_KHR_partial_update "               // strongly recommended
-+        "EGL_EXT_buffer_age "                   // strongly recommended with partial_update
-+        "EGL_KHR_create_context_no_error "
-+        "EGL_KHR_mutable_render_buffer "
-+        "EGL_EXT_yuv_surface "
-+        "EGL_EXT_protected_content "
-+        ;
-+
-+// extensions not exposed to applications but used by the ANDROID system
-+//      "EGL_ANDROID_blob_cache "               // strongly recommended
-+//      "EGL_IMG_hibernate_process "            // optional
-+//      "EGL_ANDROID_native_fence_sync "        // strongly recommended
-+//      "EGL_ANDROID_framebuffer_target "       // mandatory for HWC 1.1
-+//      "EGL_ANDROID_image_crop "               // optional
-+
-+/*
-+ * EGL Extensions entry-points exposed to 3rd party applications
-+ * (keep in sync with gExtensionString above)
-+ *
-+ */
-+static const extention_map_t sExtensionMap[] = {
-+    // EGL_KHR_lock_surface
-+    { "eglLockSurfaceKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglLockSurfaceKHR },
-+    { "eglUnlockSurfaceKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglUnlockSurfaceKHR },
-+
-+    // EGL_KHR_image, EGL_KHR_image_base
-+    { "eglCreateImageKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglCreateImageKHR },
-+    { "eglDestroyImageKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglDestroyImageKHR },
-+
-+    // EGL_KHR_reusable_sync, EGL_KHR_fence_sync
-+    { "eglCreateSyncKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglCreateSyncKHR },
-+    { "eglDestroySyncKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglDestroySyncKHR },
-+    { "eglClientWaitSyncKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglClientWaitSyncKHR },
-+    { "eglSignalSyncKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglSignalSyncKHR },
-+    { "eglGetSyncAttribKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglGetSyncAttribKHR },
-+
-+    // EGL_NV_system_time
-+    { "eglGetSystemTimeFrequencyNV",
-+            (__eglMustCastToProperFunctionPointerType)&eglGetSystemTimeFrequencyNV },
-+    { "eglGetSystemTimeNV",
-+            (__eglMustCastToProperFunctionPointerType)&eglGetSystemTimeNV },
-+
-+    // EGL_KHR_wait_sync
-+    { "eglWaitSyncKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglWaitSyncKHR },
-+
-+    // EGL_ANDROID_presentation_time
-+    { "eglPresentationTimeANDROID",
-+            (__eglMustCastToProperFunctionPointerType)&eglPresentationTimeANDROID },
-+
-+    // EGL_KHR_swap_buffers_with_damage
-+    { "eglSwapBuffersWithDamageKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglSwapBuffersWithDamageKHR },
-+
-+    // EGL_ANDROID_native_client_buffer
-+    { "eglCreateNativeClientBufferANDROID",
-+            (__eglMustCastToProperFunctionPointerType)&eglCreateNativeClientBufferANDROID },
-+
-+    // EGL_KHR_partial_update
-+    { "eglSetDamageRegionKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglSetDamageRegionKHR },
-+
-+    { "eglCreateStreamKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglCreateStreamKHR },
-+    { "eglDestroyStreamKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglDestroyStreamKHR },
-+    { "eglStreamAttribKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglStreamAttribKHR },
-+    { "eglQueryStreamKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglQueryStreamKHR },
-+    { "eglQueryStreamu64KHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglQueryStreamu64KHR },
-+    { "eglQueryStreamTimeKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglQueryStreamTimeKHR },
-+    { "eglCreateStreamProducerSurfaceKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglCreateStreamProducerSurfaceKHR },
-+    { "eglStreamConsumerGLTextureExternalKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglStreamConsumerGLTextureExternalKHR },
-+    { "eglStreamConsumerAcquireKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglStreamConsumerAcquireKHR },
-+    { "eglStreamConsumerReleaseKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglStreamConsumerReleaseKHR },
-+    { "eglGetStreamFileDescriptorKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglGetStreamFileDescriptorKHR },
-+    { "eglCreateStreamFromFileDescriptorKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglCreateStreamFromFileDescriptorKHR },
-+
-+    // EGL_ANDROID_get_frame_timestamps
-+    { "eglGetFrameTimestampsANDROID",
-+            (__eglMustCastToProperFunctionPointerType)&eglGetFrameTimestampsANDROID },
-+    { "eglQueryTimestampSupportedANDROID",
-+            (__eglMustCastToProperFunctionPointerType)&eglQueryTimestampSupportedANDROID },
-+};
-+
-+/*
-+ * These extensions entry-points should not be exposed to applications.
-+ * They're used internally by the Android EGL layer.
-+ */
-+#define FILTER_EXTENSIONS(procname) \
-+        (!strcmp((procname), "eglSetBlobCacheFuncsANDROID") ||    \
-+         !strcmp((procname), "eglHibernateProcessIMG")      ||    \
-+         !strcmp((procname), "eglAwakenProcessIMG")         ||    \
-+         !strcmp((procname), "eglDupNativeFenceFDANDROID"))
-+
-+
-+
-+// accesses protected by sExtensionMapMutex
-+static DefaultKeyedVector<String8, __eglMustCastToProperFunctionPointerType> sGLExtentionMap;
-+static int sGLExtentionSlot = 0;
-+static pthread_mutex_t sExtensionMapMutex = PTHREAD_MUTEX_INITIALIZER;
-+
-+static void(*findProcAddress(const char* name,
-+        const extention_map_t* map, size_t n))() {
-+    for (uint32_t i=0 ; i<n ; i++) {
-+        if (!strcmp(name, map[i].name)) {
-+            return map[i].address;
-+        }
-+    }
-+    return NULL;
-+}
-+
-+// ----------------------------------------------------------------------------
-+
-+extern void setGLHooksThreadSpecific(gl_hooks_t const *value);
-+extern EGLBoolean egl_init_drivers();
-+extern const __eglMustCastToProperFunctionPointerType gExtensionForwarders[MAX_NUMBER_OF_GL_EXTENSIONS];
-+extern gl_hooks_t gHooksTrace;
-+
-+} // namespace android;
-+
-+
-+// ----------------------------------------------------------------------------
-+
-+static inline void clearError() { egl_tls_t::clearError(); }
-+static inline EGLContext getContext() { return egl_tls_t::getContext(); }
-+
-+// ----------------------------------------------------------------------------
-+
-+EGLDisplay eglGetDisplay(EGLNativeDisplayType display)
-+{
-+    ATRACE_CALL();
-+    clearError();
-+
-+    uintptr_t index = reinterpret_cast<uintptr_t>(display);
-+    if (index >= NUM_DISPLAYS) {
-+        return setError(EGL_BAD_PARAMETER, EGL_NO_DISPLAY);
-+    }
-+
-+    if (egl_init_drivers() == EGL_FALSE) {
-+        return setError(EGL_BAD_PARAMETER, EGL_NO_DISPLAY);
-+    }
-+
-+    EGLDisplay dpy = egl_display_t::getFromNativeDisplay(display);
-+    return dpy;
-+}
-+
-+// ----------------------------------------------------------------------------
-+// Initialization
-+// ----------------------------------------------------------------------------
-+
-+EGLBoolean eglInitialize(EGLDisplay dpy, EGLint *major, EGLint *minor)
-+{
-+    clearError();
-+
-+    egl_display_ptr dp = get_display(dpy);
-+    if (!dp) return setError(EGL_BAD_DISPLAY, EGL_FALSE);
-+
-+    EGLBoolean res = dp->initialize(major, minor);
-+
-+    return res;
-+}
-+
-+EGLBoolean eglTerminate(EGLDisplay dpy)
-+{
-+    // NOTE: don't unload the drivers b/c some APIs can be called
-+    // after eglTerminate() has been called. eglTerminate() only
-+    // terminates an EGLDisplay, not a EGL itself.
-+
-+    clearError();
-+
-+    egl_display_ptr dp = get_display(dpy);
-+    if (!dp) return setError(EGL_BAD_DISPLAY, EGL_FALSE);
-+
-+    EGLBoolean res = dp->terminate();
-+
-+    return res;
-+}
-+
-+// ----------------------------------------------------------------------------
-+// configuration
-+// ----------------------------------------------------------------------------
-+
-+EGLBoolean eglGetConfigs(   EGLDisplay dpy,
-+                            EGLConfig *configs,
-+                            EGLint config_size, EGLint *num_config)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    if (num_config==0) {
-+        return setError(EGL_BAD_PARAMETER, EGL_FALSE);
-+    }
-+
-+    EGLBoolean res = EGL_FALSE;
-+    *num_config = 0;
-+
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso) {
-+        res = cnx->egl.eglGetConfigs(
-+                dp->disp.dpy, configs, config_size, num_config);
-+    }
-+
-+    return res;
-+}
-+
-+EGLBoolean eglChooseConfig( EGLDisplay dpy, const EGLint *attrib_list,
-+                            EGLConfig *configs, EGLint config_size,
-+                            EGLint *num_config)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    if (num_config==0) {
-+        return setError(EGL_BAD_PARAMETER, EGL_FALSE);
-+    }
-+
-+    EGLBoolean res = EGL_FALSE;
-+    *num_config = 0;
-+
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso) {
-+        if (attrib_list) {
-+            char value[PROPERTY_VALUE_MAX];
-+            property_get("debug.egl.force_msaa", value, "false");
-+
-+            if (!strcmp(value, "true")) {
-+                size_t attribCount = 0;
-+                EGLint attrib = attrib_list[0];
-+
-+                // Only enable MSAA if the context is OpenGL ES 2.0 and
-+                // if no caveat is requested
-+                const EGLint *attribRendererable = NULL;
-+                const EGLint *attribCaveat = NULL;
-+
-+                // Count the number of attributes and look for
-+                // EGL_RENDERABLE_TYPE and EGL_CONFIG_CAVEAT
-+                while (attrib != EGL_NONE) {
-+                    attrib = attrib_list[attribCount];
-+                    switch (attrib) {
-+                        case EGL_RENDERABLE_TYPE:
-+                            attribRendererable = &attrib_list[attribCount];
-+                            break;
-+                        case EGL_CONFIG_CAVEAT:
-+                            attribCaveat = &attrib_list[attribCount];
-+                            break;
-+                    }
-+                    attribCount++;
-+                }
-+
-+                if (attribRendererable && attribRendererable[1] == EGL_OPENGL_ES2_BIT &&
-+                        (!attribCaveat || attribCaveat[1] != EGL_NONE)) {
-+
-+                    // Insert 2 extra attributes to force-enable MSAA 4x
-+                    EGLint aaAttribs[attribCount + 4];
-+                    aaAttribs[0] = EGL_SAMPLE_BUFFERS;
-+                    aaAttribs[1] = 1;
-+                    aaAttribs[2] = EGL_SAMPLES;
-+                    aaAttribs[3] = 4;
-+
-+                    memcpy(&aaAttribs[4], attrib_list, attribCount * sizeof(EGLint));
-+
-+                    EGLint numConfigAA;
-+                    EGLBoolean resAA = cnx->egl.eglChooseConfig(
-+                            dp->disp.dpy, aaAttribs, configs, config_size, &numConfigAA);
-+
-+                    if (resAA == EGL_TRUE && numConfigAA > 0) {
-+                        ALOGD("Enabling MSAA 4x");
-+                        *num_config = numConfigAA;
-+                        return resAA;
-+                    }
-+                }
-+            }
-+        }
-+
-+        res = cnx->egl.eglChooseConfig(
-+                dp->disp.dpy, attrib_list, configs, config_size, num_config);
-+    }
-+    return res;
-+}
-+
-+EGLBoolean eglGetConfigAttrib(EGLDisplay dpy, EGLConfig config,
-+        EGLint attribute, EGLint *value)
-+{
-+    clearError();
-+
-+    egl_connection_t* cnx = NULL;
-+    const egl_display_ptr dp = validate_display_connection(dpy, cnx);
-+    if (!dp) return EGL_FALSE;
-+
-+    return cnx->egl.eglGetConfigAttrib(
-+            dp->disp.dpy, config, attribute, value);
-+}
-+
-+// ----------------------------------------------------------------------------
-+// surfaces
-+// ----------------------------------------------------------------------------
-+
-+// The EGL_KHR_gl_colorspace spec hasn't been ratified yet, so these haven't
-+// been added to the Khronos egl.h.
-+#define EGL_GL_COLORSPACE_KHR           EGL_VG_COLORSPACE
-+#define EGL_GL_COLORSPACE_SRGB_KHR      EGL_VG_COLORSPACE_sRGB
-+#define EGL_GL_COLORSPACE_LINEAR_KHR    EGL_VG_COLORSPACE_LINEAR
-+
-+// Turn linear formats into corresponding sRGB formats when colorspace is
-+// EGL_GL_COLORSPACE_SRGB_KHR, or turn sRGB formats into corresponding linear
-+// formats when colorspace is EGL_GL_COLORSPACE_LINEAR_KHR. In any cases where
-+// the modification isn't possible, the original dataSpace is returned.
-+static android_dataspace modifyBufferDataspace( android_dataspace dataSpace,
-+                                                EGLint colorspace) {
-+    if (colorspace == EGL_GL_COLORSPACE_LINEAR_KHR) {
-+        return HAL_DATASPACE_SRGB_LINEAR;
-+    } else if (colorspace == EGL_GL_COLORSPACE_SRGB_KHR) {
-+        return HAL_DATASPACE_SRGB;
-+    }
-+    return dataSpace;
-+}
-+
-+EGLSurface eglCreateWindowSurface(  EGLDisplay dpy, EGLConfig config,
-+                                    NativeWindowType window,
-+                                    const EGLint *attrib_list)
-+{
-+    clearError();
-+
-+    egl_connection_t* cnx = NULL;
-+    egl_display_ptr dp = validate_display_connection(dpy, cnx);
-+    if (dp) {
-+        EGLDisplay iDpy = dp->disp.dpy;
-+
-+        int result = native_window_api_connect(window, NATIVE_WINDOW_API_EGL);
-+        if (result != OK) {
-+            ALOGE("eglCreateWindowSurface: native_window_api_connect (win=%p) "
-+                    "failed (%#x) (already connected to another API?)",
-+                    window, result);
-+            return setError(EGL_BAD_ALLOC, EGL_NO_SURFACE);
-+        }
-+
-+        // Set the native window's buffers format to match what this config requests.
-+        // Whether to use sRGB gamma is not part of the EGLconfig, but is part
-+        // of our native format. So if sRGB gamma is requested, we have to
-+        // modify the EGLconfig's format before setting the native window's
-+        // format.
-+
-+        // by default, just pick RGBA_8888
-+        EGLint format = HAL_PIXEL_FORMAT_RGBA_8888;
-+        android_dataspace dataSpace = HAL_DATASPACE_UNKNOWN;
-+
-+        EGLint a = 0;
-+        cnx->egl.eglGetConfigAttrib(iDpy, config, EGL_ALPHA_SIZE, &a);
-+        if (a > 0) {
-+            // alpha-channel requested, there's really only one suitable format
-+            format = HAL_PIXEL_FORMAT_RGBA_8888;
-+        } else {
-+            EGLint r, g, b;
-+            r = g = b = 0;
-+            cnx->egl.eglGetConfigAttrib(iDpy, config, EGL_RED_SIZE,   &r);
-+            cnx->egl.eglGetConfigAttrib(iDpy, config, EGL_GREEN_SIZE, &g);
-+            cnx->egl.eglGetConfigAttrib(iDpy, config, EGL_BLUE_SIZE,  &b);
-+            EGLint colorDepth = r + g + b;
-+            if (colorDepth <= 16) {
-+                format = HAL_PIXEL_FORMAT_RGB_565;
-+            } else {
-+                format = HAL_PIXEL_FORMAT_RGBX_8888;
-+            }
-+        }
-+
-+        // now select a corresponding sRGB format if needed
-+        if (attrib_list && dp->haveExtension("EGL_KHR_gl_colorspace")) {
-+            for (const EGLint* attr = attrib_list; *attr != EGL_NONE; attr += 2) {
-+                if (*attr == EGL_GL_COLORSPACE_KHR) {
-+                    if (ENABLE_EGL_KHR_GL_COLORSPACE) {
-+                        dataSpace = modifyBufferDataspace(dataSpace, *(attr+1));
-+                    } else {
-+                        // Normally we'd pass through unhandled attributes to
-+                        // the driver. But in case the driver implements this
-+                        // extension but we're disabling it, we want to prevent
-+                        // it getting through -- support will be broken without
-+                        // our help.
-+                        ALOGE("sRGB window surfaces not supported");
-+                        return setError(EGL_BAD_ATTRIBUTE, EGL_NO_SURFACE);
-+                    }
-+                }
-+            }
-+        }
-+
-+        if (format != 0) {
-+            int err = native_window_set_buffers_format(window, format);
-+            if (err != 0) {
-+                ALOGE("error setting native window pixel format: %s (%d)",
-+                        strerror(-err), err);
-+                native_window_api_disconnect(window, NATIVE_WINDOW_API_EGL);
-+                return setError(EGL_BAD_NATIVE_WINDOW, EGL_NO_SURFACE);
-+            }
-+        }
-+
-+        if (dataSpace != 0) {
-+            int err = native_window_set_buffers_data_space(window, dataSpace);
-+            if (err != 0) {
-+                ALOGE("error setting native window pixel dataSpace: %s (%d)",
-+                        strerror(-err), err);
-+                native_window_api_disconnect(window, NATIVE_WINDOW_API_EGL);
-+                return setError(EGL_BAD_NATIVE_WINDOW, EGL_NO_SURFACE);
-+            }
-+        }
-+
-+        // the EGL spec requires that a new EGLSurface default to swap interval
-+        // 1, so explicitly set that on the window here.
-+        ANativeWindow* anw = reinterpret_cast<ANativeWindow*>(window);
-+        anw->setSwapInterval(anw, 1);
-+
-+        EGLSurface surface = cnx->egl.eglCreateWindowSurface(
-+                iDpy, config, window, attrib_list);
-+        if (surface != EGL_NO_SURFACE) {
-+            egl_surface_t* s = new egl_surface_t(dp.get(), config, window,
-+                    surface, cnx);
-+            return s;
-+        }
-+
-+        // EGLSurface creation failed
-+        native_window_set_buffers_format(window, 0);
-+        native_window_api_disconnect(window, NATIVE_WINDOW_API_EGL);
-+    }
-+    return EGL_NO_SURFACE;
-+}
-+
-+EGLSurface eglCreatePixmapSurface(  EGLDisplay dpy, EGLConfig config,
-+                                    NativePixmapType pixmap,
-+                                    const EGLint *attrib_list)
-+{
-+    clearError();
-+
-+    egl_connection_t* cnx = NULL;
-+    egl_display_ptr dp = validate_display_connection(dpy, cnx);
-+    if (dp) {
-+        EGLSurface surface = cnx->egl.eglCreatePixmapSurface(
-+                dp->disp.dpy, config, pixmap, attrib_list);
-+        if (surface != EGL_NO_SURFACE) {
-+            egl_surface_t* s = new egl_surface_t(dp.get(), config, NULL,
-+                    surface, cnx);
-+            return s;
-+        }
-+    }
-+    return EGL_NO_SURFACE;
-+}
-+
-+EGLSurface eglCreatePbufferSurface( EGLDisplay dpy, EGLConfig config,
-+                                    const EGLint *attrib_list)
-+{
-+    clearError();
-+
-+    egl_connection_t* cnx = NULL;
-+    egl_display_ptr dp = validate_display_connection(dpy, cnx);
-+    if (dp) {
-+        EGLSurface surface = cnx->egl.eglCreatePbufferSurface(
-+                dp->disp.dpy, config, attrib_list);
-+        if (surface != EGL_NO_SURFACE) {
-+            egl_surface_t* s = new egl_surface_t(dp.get(), config, NULL,
-+                    surface, cnx);
-+            return s;
-+        }
-+    }
-+    return EGL_NO_SURFACE;
-+}
-+
-+EGLBoolean eglDestroySurface(EGLDisplay dpy, EGLSurface surface)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    SurfaceRef _s(dp.get(), surface);
-+    if (!_s.get())
-+        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-+
-+    egl_surface_t * const s = get_surface(surface);
-+    EGLBoolean result = s->cnx->egl.eglDestroySurface(dp->disp.dpy, s->surface);
-+    if (result == EGL_TRUE) {
-+        _s.terminate();
-+    }
-+    return result;
-+}
-+
-+EGLBoolean eglQuerySurface( EGLDisplay dpy, EGLSurface surface,
-+                            EGLint attribute, EGLint *value)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    SurfaceRef _s(dp.get(), surface);
-+    if (!_s.get())
-+        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-+
-+    egl_surface_t const * const s = get_surface(surface);
-+    return s->cnx->egl.eglQuerySurface(
-+            dp->disp.dpy, s->surface, attribute, value);
-+}
-+
-+void EGLAPI eglBeginFrame(EGLDisplay dpy, EGLSurface surface) {
-+    ATRACE_CALL();
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) {
-+        return;
-+    }
-+
-+    SurfaceRef _s(dp.get(), surface);
-+    if (!_s.get()) {
-+        setError(EGL_BAD_SURFACE, EGL_FALSE);
-+        return;
-+    }
-+}
-+
-+// ----------------------------------------------------------------------------
-+// Contexts
-+// ----------------------------------------------------------------------------
-+
-+EGLContext eglCreateContext(EGLDisplay dpy, EGLConfig config,
-+                            EGLContext share_list, const EGLint *attrib_list)
-+{
-+    clearError();
-+
-+    egl_connection_t* cnx = NULL;
-+    const egl_display_ptr dp = validate_display_connection(dpy, cnx);
-+    if (dp) {
-+        if (share_list != EGL_NO_CONTEXT) {
-+            if (!ContextRef(dp.get(), share_list).get()) {
-+                return setError(EGL_BAD_CONTEXT, EGL_NO_CONTEXT);
-+            }
-+            egl_context_t* const c = get_context(share_list);
-+            share_list = c->context;
-+        }
-+        EGLContext context = cnx->egl.eglCreateContext(
-+                dp->disp.dpy, config, share_list, attrib_list);
-+        if (context != EGL_NO_CONTEXT) {
-+            // figure out if it's a GLESv1 or GLESv2
-+            int version = 0;
-+            if (attrib_list) {
-+                while (*attrib_list != EGL_NONE) {
-+                    GLint attr = *attrib_list++;
-+                    GLint value = *attrib_list++;
-+                    if (attr == EGL_CONTEXT_CLIENT_VERSION) {
-+                        if (value == 1) {
-+                            version = egl_connection_t::GLESv1_INDEX;
-+                        } else if (value == 2 || value == 3) {
-+                            version = egl_connection_t::GLESv2_INDEX;
-+                        }
-+                    }
-+                };
-+            }
-+            egl_context_t* c = new egl_context_t(dpy, context, config, cnx,
-+                    version);
-+            return c;
-+        }
-+    }
-+    return EGL_NO_CONTEXT;
-+}
-+
-+EGLBoolean eglDestroyContext(EGLDisplay dpy, EGLContext ctx)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp)
-+        return EGL_FALSE;
-+
-+    ContextRef _c(dp.get(), ctx);
-+    if (!_c.get())
-+        return setError(EGL_BAD_CONTEXT, EGL_FALSE);
-+
-+    egl_context_t * const c = get_context(ctx);
-+    EGLBoolean result = c->cnx->egl.eglDestroyContext(dp->disp.dpy, c->context);
-+    if (result == EGL_TRUE) {
-+        _c.terminate();
-+    }
-+    return result;
-+}
-+
-+EGLBoolean eglMakeCurrent(  EGLDisplay dpy, EGLSurface draw,
-+                            EGLSurface read, EGLContext ctx)
-+{
-+    clearError();
-+
-+    egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return setError(EGL_BAD_DISPLAY, EGL_FALSE);
-+
-+    // If ctx is not EGL_NO_CONTEXT, read is not EGL_NO_SURFACE, or draw is not
-+    // EGL_NO_SURFACE, then an EGL_NOT_INITIALIZED error is generated if dpy is
-+    // a valid but uninitialized display.
-+    if ( (ctx != EGL_NO_CONTEXT) || (read != EGL_NO_SURFACE) ||
-+         (draw != EGL_NO_SURFACE) ) {
-+        if (!dp->isReady()) return setError(EGL_NOT_INITIALIZED, EGL_FALSE);
-+    }
-+
-+    // get a reference to the object passed in
-+    ContextRef _c(dp.get(), ctx);
-+    SurfaceRef _d(dp.get(), draw);
-+    SurfaceRef _r(dp.get(), read);
-+
-+    // validate the context (if not EGL_NO_CONTEXT)
-+    if ((ctx != EGL_NO_CONTEXT) && !_c.get()) {
-+        // EGL_NO_CONTEXT is valid
-+        return setError(EGL_BAD_CONTEXT, EGL_FALSE);
-+    }
-+
-+    // these are the underlying implementation's object
-+    EGLContext impl_ctx  = EGL_NO_CONTEXT;
-+    EGLSurface impl_draw = EGL_NO_SURFACE;
-+    EGLSurface impl_read = EGL_NO_SURFACE;
-+
-+    // these are our objects structs passed in
-+    egl_context_t       * c = NULL;
-+    egl_surface_t const * d = NULL;
-+    egl_surface_t const * r = NULL;
-+
-+    // these are the current objects structs
-+    egl_context_t * cur_c = get_context(getContext());
-+
-+    if (ctx != EGL_NO_CONTEXT) {
-+        c = get_context(ctx);
-+        impl_ctx = c->context;
-+    } else {
-+        // no context given, use the implementation of the current context
-+        if (draw != EGL_NO_SURFACE || read != EGL_NO_SURFACE) {
-+            // calling eglMakeCurrent( ..., !=0, !=0, EGL_NO_CONTEXT);
-+            return setError(EGL_BAD_MATCH, EGL_FALSE);
-+        }
-+        if (cur_c == NULL) {
-+            // no current context
-+            // not an error, there is just no current context.
-+            return EGL_TRUE;
-+        }
-+    }
-+
-+    // retrieve the underlying implementation's draw EGLSurface
-+    if (draw != EGL_NO_SURFACE) {
-+        if (!_d.get()) return setError(EGL_BAD_SURFACE, EGL_FALSE);
-+        d = get_surface(draw);
-+        impl_draw = d->surface;
-+    }
-+
-+    // retrieve the underlying implementation's read EGLSurface
-+    if (read != EGL_NO_SURFACE) {
-+        if (!_r.get()) return setError(EGL_BAD_SURFACE, EGL_FALSE);
-+        r = get_surface(read);
-+        impl_read = r->surface;
-+    }
-+
-+
-+    EGLBoolean result = dp->makeCurrent(c, cur_c,
-+            draw, read, ctx,
-+            impl_draw, impl_read, impl_ctx);
-+
-+    if (result == EGL_TRUE) {
-+        if (c) {
-+            setGLHooksThreadSpecific(c->cnx->hooks[c->version]);
-+            egl_tls_t::setContext(ctx);
-+            _c.acquire();
-+            _r.acquire();
-+            _d.acquire();
-+        } else {
-+            setGLHooksThreadSpecific(&gHooksNoContext);
-+            egl_tls_t::setContext(EGL_NO_CONTEXT);
-+        }
-+    } else {
-+        // this will ALOGE the error
-+        egl_connection_t* const cnx = &gEGLImpl;
-+        result = setError(cnx->egl.eglGetError(), EGL_FALSE);
-+    }
-+    return result;
-+}
-+
-+
-+EGLBoolean eglQueryContext( EGLDisplay dpy, EGLContext ctx,
-+                            EGLint attribute, EGLint *value)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    ContextRef _c(dp.get(), ctx);
-+    if (!_c.get()) return setError(EGL_BAD_CONTEXT, EGL_FALSE);
-+
-+    egl_context_t * const c = get_context(ctx);
-+    return c->cnx->egl.eglQueryContext(
-+            dp->disp.dpy, c->context, attribute, value);
-+
-+}
-+
-+EGLContext eglGetCurrentContext(void)
-+{
-+    // could be called before eglInitialize(), but we wouldn't have a context
-+    // then, and this function would correctly return EGL_NO_CONTEXT.
-+
-+    clearError();
-+
-+    EGLContext ctx = getContext();
-+    return ctx;
-+}
-+
-+EGLSurface eglGetCurrentSurface(EGLint readdraw)
-+{
-+    // could be called before eglInitialize(), but we wouldn't have a context
-+    // then, and this function would correctly return EGL_NO_SURFACE.
-+
-+    clearError();
-+
-+    EGLContext ctx = getContext();
-+    if (ctx) {
-+        egl_context_t const * const c = get_context(ctx);
-+        if (!c) return setError(EGL_BAD_CONTEXT, EGL_NO_SURFACE);
-+        switch (readdraw) {
-+            case EGL_READ: return c->read;
-+            case EGL_DRAW: return c->draw;
-+            default: return setError(EGL_BAD_PARAMETER, EGL_NO_SURFACE);
-+        }
-+    }
-+    return EGL_NO_SURFACE;
-+}
-+
-+EGLDisplay eglGetCurrentDisplay(void)
-+{
-+    // could be called before eglInitialize(), but we wouldn't have a context
-+    // then, and this function would correctly return EGL_NO_DISPLAY.
-+
-+    clearError();
-+
-+    EGLContext ctx = getContext();
-+    if (ctx) {
-+        egl_context_t const * const c = get_context(ctx);
-+        if (!c) return setError(EGL_BAD_CONTEXT, EGL_NO_SURFACE);
-+        return c->dpy;
-+    }
-+    return EGL_NO_DISPLAY;
-+}
-+
-+EGLBoolean eglWaitGL(void)
-+{
-+    clearError();
-+
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (!cnx->dso)
-+        return setError(EGL_BAD_CONTEXT, EGL_FALSE);
-+
-+    return cnx->egl.eglWaitGL();
-+}
-+
-+EGLBoolean eglWaitNative(EGLint engine)
-+{
-+    clearError();
-+
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (!cnx->dso)
-+        return setError(EGL_BAD_CONTEXT, EGL_FALSE);
-+
-+    return cnx->egl.eglWaitNative(engine);
-+}
-+
-+EGLint eglGetError(void)
-+{
-+    EGLint err = EGL_SUCCESS;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso) {
-+        err = cnx->egl.eglGetError();
-+    }
-+    if (err == EGL_SUCCESS) {
-+        err = egl_tls_t::getError();
-+    }
-+    return err;
-+}
-+
-+static __eglMustCastToProperFunctionPointerType findBuiltinWrapper(
-+        const char* procname) {
-+    const egl_connection_t* cnx = &gEGLImpl;
-+    void* proc = NULL;
-+
-+    proc = dlsym(cnx->libEgl, procname);
-+    if (proc) return (__eglMustCastToProperFunctionPointerType)proc;
-+
-+    proc = dlsym(cnx->libGles2, procname);
-+    if (proc) return (__eglMustCastToProperFunctionPointerType)proc;
-+
-+    proc = dlsym(cnx->libGles1, procname);
-+    if (proc) return (__eglMustCastToProperFunctionPointerType)proc;
-+
-+    return NULL;
-+}
-+
-+__eglMustCastToProperFunctionPointerType eglGetProcAddress(const char *procname)
-+{
-+    // eglGetProcAddress() could be the very first function called
-+    // in which case we must make sure we've initialized ourselves, this
-+    // happens the first time egl_get_display() is called.
-+
-+    clearError();
-+
-+    if (egl_init_drivers() == EGL_FALSE) {
-+        setError(EGL_BAD_PARAMETER, NULL);
-+        return  NULL;
-+    }
-+
-+    if (FILTER_EXTENSIONS(procname)) {
-+        return NULL;
-+    }
-+
-+    __eglMustCastToProperFunctionPointerType addr;
-+    addr = findProcAddress(procname, sExtensionMap, NELEM(sExtensionMap));
-+    if (addr) return addr;
-+
-+    addr = findBuiltinWrapper(procname);
-+    if (addr) return addr;
-+
-+    // this protects accesses to sGLExtentionMap and sGLExtentionSlot
-+    pthread_mutex_lock(&sExtensionMapMutex);
-+
-+        /*
-+         * Since eglGetProcAddress() is not associated to anything, it needs
-+         * to return a function pointer that "works" regardless of what
-+         * the current context is.
-+         *
-+         * For this reason, we return a "forwarder", a small stub that takes
-+         * care of calling the function associated with the context
-+         * currently bound.
-+         *
-+         * We first look for extensions we've already resolved, if we're seeing
-+         * this extension for the first time, we go through all our
-+         * implementations and call eglGetProcAddress() and record the
-+         * result in the appropriate implementation hooks and return the
-+         * address of the forwarder corresponding to that hook set.
-+         *
-+         */
-+
-+        const String8 name(procname);
-+        addr = sGLExtentionMap.valueFor(name);
-+        const int slot = sGLExtentionSlot;
-+
-+        ALOGE_IF(slot >= MAX_NUMBER_OF_GL_EXTENSIONS,
-+                "no more slots for eglGetProcAddress(\"%s\")",
-+                procname);
-+
-+        if (!addr && (slot < MAX_NUMBER_OF_GL_EXTENSIONS)) {
-+            bool found = false;
-+
-+            egl_connection_t* const cnx = &gEGLImpl;
-+            if (cnx->dso && cnx->egl.eglGetProcAddress) {
-+                // Extensions are independent of the bound context
-+                addr =
-+                cnx->hooks[egl_connection_t::GLESv1_INDEX]->ext.extensions[slot] =
-+                cnx->hooks[egl_connection_t::GLESv2_INDEX]->ext.extensions[slot] =
-+                        cnx->egl.eglGetProcAddress(procname);
-+                if (addr) found = true;
-+            }
-+
-+            if (found) {
-+                addr = gExtensionForwarders[slot];
-+                sGLExtentionMap.add(name, addr);
-+                sGLExtentionSlot++;
-+            }
-+        }
-+
-+    pthread_mutex_unlock(&sExtensionMapMutex);
-+    return addr;
-+}
-+
-+class FrameCompletionThread : public Thread {
-+public:
-+
-+    static void queueSync(EGLSyncKHR sync) {
-+        static sp<FrameCompletionThread> thread(new FrameCompletionThread);
-+        static bool running = false;
-+        if (!running) {
-+            thread->run("GPUFrameCompletion");
-+            running = true;
-+        }
-+        {
-+            Mutex::Autolock lock(thread->mMutex);
-+            ScopedTrace st(ATRACE_TAG, String8::format("kicked off frame %d",
-+                    thread->mFramesQueued).string());
-+            thread->mQueue.push_back(sync);
-+            thread->mCondition.signal();
-+            thread->mFramesQueued++;
-+            ATRACE_INT("GPU Frames Outstanding", thread->mQueue.size());
-+        }
-+    }
-+
-+private:
-+    FrameCompletionThread() : mFramesQueued(0), mFramesCompleted(0) {}
-+
-+    virtual bool threadLoop() {
-+        EGLSyncKHR sync;
-+        uint32_t frameNum;
-+        {
-+            Mutex::Autolock lock(mMutex);
-+            while (mQueue.isEmpty()) {
-+                mCondition.wait(mMutex);
-+            }
-+            sync = mQueue[0];
-+            frameNum = mFramesCompleted;
-+        }
-+        EGLDisplay dpy = eglGetDisplay(EGL_DEFAULT_DISPLAY);
-+        {
-+            ScopedTrace st(ATRACE_TAG, String8::format("waiting for frame %d",
-+                    frameNum).string());
-+            EGLint result = eglClientWaitSyncKHR(dpy, sync, 0, EGL_FOREVER_KHR);
-+            if (result == EGL_FALSE) {
-+                ALOGE("FrameCompletion: error waiting for fence: %#x", eglGetError());
-+            } else if (result == EGL_TIMEOUT_EXPIRED_KHR) {
-+                ALOGE("FrameCompletion: timeout waiting for fence");
-+            }
-+            eglDestroySyncKHR(dpy, sync);
-+        }
-+        {
-+            Mutex::Autolock lock(mMutex);
-+            mQueue.removeAt(0);
-+            mFramesCompleted++;
-+            ATRACE_INT("GPU Frames Outstanding", mQueue.size());
-+        }
-+        return true;
-+    }
-+
-+    uint32_t mFramesQueued;
-+    uint32_t mFramesCompleted;
-+    Vector<EGLSyncKHR> mQueue;
-+    Condition mCondition;
-+    Mutex mMutex;
-+};
-+
-+EGLBoolean eglSwapBuffersWithDamageKHR(EGLDisplay dpy, EGLSurface draw,
-+        EGLint *rects, EGLint n_rects)
-+{
-+    ATRACE_CALL();
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    SurfaceRef _s(dp.get(), draw);
-+    if (!_s.get())
-+        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-+
-+    egl_surface_t const * const s = get_surface(draw);
-+
-+    if (CC_UNLIKELY(dp->traceGpuCompletion)) {
-+        EGLSyncKHR sync = eglCreateSyncKHR(dpy, EGL_SYNC_FENCE_KHR, NULL);
-+        if (sync != EGL_NO_SYNC_KHR) {
-+            FrameCompletionThread::queueSync(sync);
-+        }
-+    }
-+
-+    if (CC_UNLIKELY(dp->finishOnSwap)) {
-+        uint32_t pixel;
-+        egl_context_t * const c = get_context( egl_tls_t::getContext() );
-+        if (c) {
-+            // glReadPixels() ensures that the frame is complete
-+            s->cnx->hooks[c->version]->gl.glReadPixels(0,0,1,1,
-+                    GL_RGBA,GL_UNSIGNED_BYTE,&pixel);
-+        }
-+    }
-+
-+    if (n_rects == 0) {
-+        return s->cnx->egl.eglSwapBuffers(dp->disp.dpy, s->surface);
-+    }
-+
-+    Vector<android_native_rect_t> androidRects;
-+    for (int r = 0; r < n_rects; ++r) {
-+        int offset = r * 4;
-+        int x = rects[offset];
-+        int y = rects[offset + 1];
-+        int width = rects[offset + 2];
-+        int height = rects[offset + 3];
-+        android_native_rect_t androidRect;
-+        androidRect.left = x;
-+        androidRect.top = y + height;
-+        androidRect.right = x + width;
-+        androidRect.bottom = y;
-+        androidRects.push_back(androidRect);
-+    }
-+    native_window_set_surface_damage(s->win.get(), androidRects.array(),
-+            androidRects.size());
-+
-+    if (s->cnx->egl.eglSwapBuffersWithDamageKHR) {
-+        return s->cnx->egl.eglSwapBuffersWithDamageKHR(dp->disp.dpy, s->surface,
-+                rects, n_rects);
-+    } else {
-+        return s->cnx->egl.eglSwapBuffers(dp->disp.dpy, s->surface);
-+    }
-+}
-+
-+EGLBoolean eglSwapBuffers(EGLDisplay dpy, EGLSurface surface)
-+{
-+    return eglSwapBuffersWithDamageKHR(dpy, surface, NULL, 0);
-+}
-+
-+EGLBoolean eglCopyBuffers(  EGLDisplay dpy, EGLSurface surface,
-+                            NativePixmapType target)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    SurfaceRef _s(dp.get(), surface);
-+    if (!_s.get())
-+        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-+
-+    egl_surface_t const * const s = get_surface(surface);
-+    return s->cnx->egl.eglCopyBuffers(dp->disp.dpy, s->surface, target);
-+}
-+
-+const char* eglQueryString(EGLDisplay dpy, EGLint name)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return (const char *) NULL;
-+
-+    switch (name) {
-+        case EGL_VENDOR:
-+            return dp->getVendorString();
-+        case EGL_VERSION:
-+            return dp->getVersionString();
-+        case EGL_EXTENSIONS:
-+            return dp->getExtensionString();
-+        case EGL_CLIENT_APIS:
-+            return dp->getClientApiString();
-+    }
-+    return setError(EGL_BAD_PARAMETER, (const char *)0);
-+}
-+
-+EGLAPI const char* eglQueryStringImplementationANDROID(EGLDisplay dpy, EGLint name)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return (const char *) NULL;
-+
-+    switch (name) {
-+        case EGL_VENDOR:
-+            return dp->disp.queryString.vendor;
-+        case EGL_VERSION:
-+            return dp->disp.queryString.version;
-+        case EGL_EXTENSIONS:
-+            return dp->disp.queryString.extensions;
-+        case EGL_CLIENT_APIS:
-+            return dp->disp.queryString.clientApi;
-+    }
-+    return setError(EGL_BAD_PARAMETER, (const char *)0);
-+}
-+
-+// ----------------------------------------------------------------------------
-+// EGL 1.1
-+// ----------------------------------------------------------------------------
-+
-+EGLBoolean eglSurfaceAttrib(
-+        EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint value)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    SurfaceRef _s(dp.get(), surface);
-+    if (!_s.get())
-+        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-+
-+    egl_surface_t * const s = get_surface(surface);
-+
-+    if (attribute == EGL_FRONT_BUFFER_AUTO_REFRESH_ANDROID) {
-+        int err = native_window_set_auto_refresh(s->win.get(),
-+            value ? true : false);
-+        return (err == NO_ERROR) ? EGL_TRUE :
-+            setError(EGL_BAD_SURFACE, EGL_FALSE);
-+    }
-+
-+#if ENABLE_EGL_ANDROID_GET_FRAME_TIMESTAMPS
-+    if (attribute == EGL_TIMESTAMPS_ANDROID) {
-+        s->enableTimestamps = value;
-+        return EGL_TRUE;
-+    }
-+#endif
-+
-+    if (s->cnx->egl.eglSurfaceAttrib) {
-+        return s->cnx->egl.eglSurfaceAttrib(
-+                dp->disp.dpy, s->surface, attribute, value);
-+    }
-+    return setError(EGL_BAD_SURFACE, EGL_FALSE);
-+}
-+
-+EGLBoolean eglBindTexImage(
-+        EGLDisplay dpy, EGLSurface surface, EGLint buffer)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    SurfaceRef _s(dp.get(), surface);
-+    if (!_s.get())
-+        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-+
-+    egl_surface_t const * const s = get_surface(surface);
-+    if (s->cnx->egl.eglBindTexImage) {
-+        return s->cnx->egl.eglBindTexImage(
-+                dp->disp.dpy, s->surface, buffer);
-+    }
-+    return setError(EGL_BAD_SURFACE, EGL_FALSE);
-+}
-+
-+EGLBoolean eglReleaseTexImage(
-+        EGLDisplay dpy, EGLSurface surface, EGLint buffer)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    SurfaceRef _s(dp.get(), surface);
-+    if (!_s.get())
-+        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-+
-+    egl_surface_t const * const s = get_surface(surface);
-+    if (s->cnx->egl.eglReleaseTexImage) {
-+        return s->cnx->egl.eglReleaseTexImage(
-+                dp->disp.dpy, s->surface, buffer);
-+    }
-+    return setError(EGL_BAD_SURFACE, EGL_FALSE);
-+}
-+
-+EGLBoolean eglSwapInterval(EGLDisplay dpy, EGLint interval)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    EGLBoolean res = EGL_TRUE;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglSwapInterval) {
-+        res = cnx->egl.eglSwapInterval(dp->disp.dpy, interval);
-+    }
-+
-+    return res;
-+}
-+
-+
-+// ----------------------------------------------------------------------------
-+// EGL 1.2
-+// ----------------------------------------------------------------------------
-+
-+EGLBoolean eglWaitClient(void)
-+{
-+    clearError();
-+
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (!cnx->dso)
-+        return setError(EGL_BAD_CONTEXT, EGL_FALSE);
-+
-+    EGLBoolean res;
-+    if (cnx->egl.eglWaitClient) {
-+        res = cnx->egl.eglWaitClient();
-+    } else {
-+        res = cnx->egl.eglWaitGL();
-+    }
-+    return res;
-+}
-+
-+EGLBoolean eglBindAPI(EGLenum api)
-+{
-+    clearError();
-+
-+    if (egl_init_drivers() == EGL_FALSE) {
-+        return setError(EGL_BAD_PARAMETER, EGL_FALSE);
-+    }
-+
-+    // bind this API on all EGLs
-+    EGLBoolean res = EGL_TRUE;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglBindAPI) {
-+        res = cnx->egl.eglBindAPI(api);
-+    }
-+    return res;
-+}
-+
-+EGLenum eglQueryAPI(void)
-+{
-+    clearError();
-+
-+    if (egl_init_drivers() == EGL_FALSE) {
-+        return setError(EGL_BAD_PARAMETER, EGL_FALSE);
-+    }
-+
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglQueryAPI) {
-+        return cnx->egl.eglQueryAPI();
-+    }
-+
-+    // or, it can only be OpenGL ES
-+    return EGL_OPENGL_ES_API;
-+}
-+
-+EGLBoolean eglReleaseThread(void)
-+{
-+    clearError();
-+
-+    // If there is context bound to the thread, release it
-+    egl_display_t::loseCurrent(get_context(getContext()));
-+
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglReleaseThread) {
-+        cnx->egl.eglReleaseThread();
-+    }
-+    egl_tls_t::clearTLS();
-+    return EGL_TRUE;
-+}
-+
-+EGLSurface eglCreatePbufferFromClientBuffer(
-+          EGLDisplay dpy, EGLenum buftype, EGLClientBuffer buffer,
-+          EGLConfig config, const EGLint *attrib_list)
-+{
-+    clearError();
-+
-+    egl_connection_t* cnx = NULL;
-+    const egl_display_ptr dp = validate_display_connection(dpy, cnx);
-+    if (!dp) return EGL_FALSE;
-+    if (cnx->egl.eglCreatePbufferFromClientBuffer) {
-+        return cnx->egl.eglCreatePbufferFromClientBuffer(
-+                dp->disp.dpy, buftype, buffer, config, attrib_list);
-+    }
-+    return setError(EGL_BAD_CONFIG, EGL_NO_SURFACE);
-+}
-+
-+// ----------------------------------------------------------------------------
-+// EGL_EGLEXT_VERSION 3
-+// ----------------------------------------------------------------------------
-+
-+EGLBoolean eglLockSurfaceKHR(EGLDisplay dpy, EGLSurface surface,
-+        const EGLint *attrib_list)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    SurfaceRef _s(dp.get(), surface);
-+    if (!_s.get())
-+        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-+
-+    egl_surface_t const * const s = get_surface(surface);
-+    if (s->cnx->egl.eglLockSurfaceKHR) {
-+        return s->cnx->egl.eglLockSurfaceKHR(
-+                dp->disp.dpy, s->surface, attrib_list);
-+    }
-+    return setError(EGL_BAD_DISPLAY, EGL_FALSE);
-+}
-+
-+EGLBoolean eglUnlockSurfaceKHR(EGLDisplay dpy, EGLSurface surface)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    SurfaceRef _s(dp.get(), surface);
-+    if (!_s.get())
-+        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-+
-+    egl_surface_t const * const s = get_surface(surface);
-+    if (s->cnx->egl.eglUnlockSurfaceKHR) {
-+        return s->cnx->egl.eglUnlockSurfaceKHR(dp->disp.dpy, s->surface);
-+    }
-+    return setError(EGL_BAD_DISPLAY, EGL_FALSE);
-+}
-+
-+EGLImageKHR eglCreateImageKHR(EGLDisplay dpy, EGLContext ctx, EGLenum target,
-+        EGLClientBuffer buffer, const EGLint *attrib_list)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_NO_IMAGE_KHR;
-+
-+    ContextRef _c(dp.get(), ctx);
-+    egl_context_t * const c = _c.get();
-+
-+    EGLImageKHR result = EGL_NO_IMAGE_KHR;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglCreateImageKHR) {
-+        result = cnx->egl.eglCreateImageKHR(
-+                dp->disp.dpy,
-+                c ? c->context : EGL_NO_CONTEXT,
-+                target, buffer, attrib_list);
-+    }
-+    return result;
-+}
-+
-+EGLBoolean eglDestroyImageKHR(EGLDisplay dpy, EGLImageKHR img)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    EGLBoolean result = EGL_FALSE;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglDestroyImageKHR) {
-+        result = cnx->egl.eglDestroyImageKHR(dp->disp.dpy, img);
-+    }
-+    return result;
-+}
-+
-+// ----------------------------------------------------------------------------
-+// EGL_EGLEXT_VERSION 5
-+// ----------------------------------------------------------------------------
-+
-+
-+EGLSyncKHR eglCreateSyncKHR(EGLDisplay dpy, EGLenum type, const EGLint *attrib_list)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_NO_SYNC_KHR;
-+
-+    EGLSyncKHR result = EGL_NO_SYNC_KHR;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglCreateSyncKHR) {
-+        result = cnx->egl.eglCreateSyncKHR(dp->disp.dpy, type, attrib_list);
-+    }
-+    return result;
-+}
-+
-+EGLBoolean eglDestroySyncKHR(EGLDisplay dpy, EGLSyncKHR sync)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    EGLBoolean result = EGL_FALSE;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglDestroySyncKHR) {
-+        result = cnx->egl.eglDestroySyncKHR(dp->disp.dpy, sync);
-+    }
-+    return result;
-+}
-+
-+EGLBoolean eglSignalSyncKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLenum mode) {
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    EGLBoolean result = EGL_FALSE;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglSignalSyncKHR) {
-+        result = cnx->egl.eglSignalSyncKHR(
-+                dp->disp.dpy, sync, mode);
-+    }
-+    return result;
-+}
-+
-+EGLint eglClientWaitSyncKHR(EGLDisplay dpy, EGLSyncKHR sync,
-+        EGLint flags, EGLTimeKHR timeout)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    EGLBoolean result = EGL_FALSE;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglClientWaitSyncKHR) {
-+        result = cnx->egl.eglClientWaitSyncKHR(
-+                dp->disp.dpy, sync, flags, timeout);
-+    }
-+    return result;
-+}
-+
-+EGLBoolean eglGetSyncAttribKHR(EGLDisplay dpy, EGLSyncKHR sync,
-+        EGLint attribute, EGLint *value)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    EGLBoolean result = EGL_FALSE;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglGetSyncAttribKHR) {
-+        result = cnx->egl.eglGetSyncAttribKHR(
-+                dp->disp.dpy, sync, attribute, value);
-+    }
-+    return result;
-+}
-+
-+EGLStreamKHR eglCreateStreamKHR(EGLDisplay dpy, const EGLint *attrib_list)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_NO_STREAM_KHR;
-+
-+    EGLStreamKHR result = EGL_NO_STREAM_KHR;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglCreateStreamKHR) {
-+        result = cnx->egl.eglCreateStreamKHR(
-+                dp->disp.dpy, attrib_list);
-+    }
-+    return result;
-+}
-+
-+EGLBoolean eglDestroyStreamKHR(EGLDisplay dpy, EGLStreamKHR stream)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    EGLBoolean result = EGL_FALSE;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglDestroyStreamKHR) {
-+        result = cnx->egl.eglDestroyStreamKHR(
-+                dp->disp.dpy, stream);
-+    }
-+    return result;
-+}
-+
-+EGLBoolean eglStreamAttribKHR(EGLDisplay dpy, EGLStreamKHR stream,
-+        EGLenum attribute, EGLint value)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    EGLBoolean result = EGL_FALSE;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglStreamAttribKHR) {
-+        result = cnx->egl.eglStreamAttribKHR(
-+                dp->disp.dpy, stream, attribute, value);
-+    }
-+    return result;
-+}
-+
-+EGLBoolean eglQueryStreamKHR(EGLDisplay dpy, EGLStreamKHR stream,
-+        EGLenum attribute, EGLint *value)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    EGLBoolean result = EGL_FALSE;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglQueryStreamKHR) {
-+        result = cnx->egl.eglQueryStreamKHR(
-+                dp->disp.dpy, stream, attribute, value);
-+    }
-+    return result;
-+}
-+
-+EGLBoolean eglQueryStreamu64KHR(EGLDisplay dpy, EGLStreamKHR stream,
-+        EGLenum attribute, EGLuint64KHR *value)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    EGLBoolean result = EGL_FALSE;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglQueryStreamu64KHR) {
-+        result = cnx->egl.eglQueryStreamu64KHR(
-+                dp->disp.dpy, stream, attribute, value);
-+    }
-+    return result;
-+}
-+
-+EGLBoolean eglQueryStreamTimeKHR(EGLDisplay dpy, EGLStreamKHR stream,
-+        EGLenum attribute, EGLTimeKHR *value)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    EGLBoolean result = EGL_FALSE;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglQueryStreamTimeKHR) {
-+        result = cnx->egl.eglQueryStreamTimeKHR(
-+                dp->disp.dpy, stream, attribute, value);
-+    }
-+    return result;
-+}
-+
-+EGLSurface eglCreateStreamProducerSurfaceKHR(EGLDisplay dpy, EGLConfig config,
-+        EGLStreamKHR stream, const EGLint *attrib_list)
-+{
-+    clearError();
-+
-+    egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_NO_SURFACE;
-+
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglCreateStreamProducerSurfaceKHR) {
-+        EGLSurface surface = cnx->egl.eglCreateStreamProducerSurfaceKHR(
-+                dp->disp.dpy, config, stream, attrib_list);
-+        if (surface != EGL_NO_SURFACE) {
-+            egl_surface_t* s = new egl_surface_t(dp.get(), config, NULL,
-+                    surface, cnx);
-+            return s;
-+        }
-+    }
-+    return EGL_NO_SURFACE;
-+}
-+
-+EGLBoolean eglStreamConsumerGLTextureExternalKHR(EGLDisplay dpy,
-+        EGLStreamKHR stream)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    EGLBoolean result = EGL_FALSE;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglStreamConsumerGLTextureExternalKHR) {
-+        result = cnx->egl.eglStreamConsumerGLTextureExternalKHR(
-+                dp->disp.dpy, stream);
-+    }
-+    return result;
-+}
-+
-+EGLBoolean eglStreamConsumerAcquireKHR(EGLDisplay dpy,
-+        EGLStreamKHR stream)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    EGLBoolean result = EGL_FALSE;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglStreamConsumerAcquireKHR) {
-+        result = cnx->egl.eglStreamConsumerAcquireKHR(
-+                dp->disp.dpy, stream);
-+    }
-+    return result;
-+}
-+
-+EGLBoolean eglStreamConsumerReleaseKHR(EGLDisplay dpy,
-+        EGLStreamKHR stream)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    EGLBoolean result = EGL_FALSE;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglStreamConsumerReleaseKHR) {
-+        result = cnx->egl.eglStreamConsumerReleaseKHR(
-+                dp->disp.dpy, stream);
-+    }
-+    return result;
-+}
-+
-+EGLNativeFileDescriptorKHR eglGetStreamFileDescriptorKHR(
-+        EGLDisplay dpy, EGLStreamKHR stream)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_NO_FILE_DESCRIPTOR_KHR;
-+
-+    EGLNativeFileDescriptorKHR result = EGL_NO_FILE_DESCRIPTOR_KHR;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglGetStreamFileDescriptorKHR) {
-+        result = cnx->egl.eglGetStreamFileDescriptorKHR(
-+                dp->disp.dpy, stream);
-+    }
-+    return result;
-+}
-+
-+EGLStreamKHR eglCreateStreamFromFileDescriptorKHR(
-+        EGLDisplay dpy, EGLNativeFileDescriptorKHR file_descriptor)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_NO_STREAM_KHR;
-+
-+    EGLStreamKHR result = EGL_NO_STREAM_KHR;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglCreateStreamFromFileDescriptorKHR) {
-+        result = cnx->egl.eglCreateStreamFromFileDescriptorKHR(
-+                dp->disp.dpy, file_descriptor);
-+    }
-+    return result;
-+}
-+
-+// ----------------------------------------------------------------------------
-+// EGL_EGLEXT_VERSION 15
-+// ----------------------------------------------------------------------------
-+
-+EGLint eglWaitSyncKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLint flags) {
-+    clearError();
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+    EGLint result = EGL_FALSE;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglWaitSyncKHR) {
-+        result = cnx->egl.eglWaitSyncKHR(dp->disp.dpy, sync, flags);
-+    }
-+    return result;
-+}
-+
-+// ----------------------------------------------------------------------------
-+// ANDROID extensions
-+// ----------------------------------------------------------------------------
-+
-+EGLint eglDupNativeFenceFDANDROID(EGLDisplay dpy, EGLSyncKHR sync)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_NO_NATIVE_FENCE_FD_ANDROID;
-+
-+    EGLint result = EGL_NO_NATIVE_FENCE_FD_ANDROID;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglDupNativeFenceFDANDROID) {
-+        result = cnx->egl.eglDupNativeFenceFDANDROID(dp->disp.dpy, sync);
-+    }
-+    return result;
-+}
-+
-+EGLBoolean eglPresentationTimeANDROID(EGLDisplay dpy, EGLSurface surface,
-+        EGLnsecsANDROID time)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) {
-+        return EGL_FALSE;
-+    }
-+
-+    SurfaceRef _s(dp.get(), surface);
-+    if (!_s.get()) {
-+        setError(EGL_BAD_SURFACE, EGL_FALSE);
-+        return EGL_FALSE;
-+    }
-+
-+    egl_surface_t const * const s = get_surface(surface);
-+    native_window_set_buffers_timestamp(s->win.get(), time);
-+
-+    return EGL_TRUE;
-+}
-+
-+EGLClientBuffer eglCreateNativeClientBufferANDROID(const EGLint *attrib_list)
-+{
-+    clearError();
-+
-+    int usage = 0;
-+    uint32_t width = 0;
-+    uint32_t height = 0;
-+    uint32_t format = 0;
-+    uint32_t red_size = 0;
-+    uint32_t green_size = 0;
-+    uint32_t blue_size = 0;
-+    uint32_t alpha_size = 0;
-+
-+#define GET_NONNEGATIVE_VALUE(case_name, target) \
-+    case case_name: \
-+        if (value >= 0) { \
-+            target = value; \
-+        } else { \
-+            return setError(EGL_BAD_PARAMETER, (EGLClientBuffer)0); \
-+        } \
-+        break
-+
-+    if (attrib_list) {
-+        while (*attrib_list != EGL_NONE) {
-+            GLint attr = *attrib_list++;
-+            GLint value = *attrib_list++;
-+            switch (attr) {
-+                GET_NONNEGATIVE_VALUE(EGL_WIDTH, width);
-+                GET_NONNEGATIVE_VALUE(EGL_HEIGHT, height);
-+                GET_NONNEGATIVE_VALUE(EGL_RED_SIZE, red_size);
-+                GET_NONNEGATIVE_VALUE(EGL_GREEN_SIZE, green_size);
-+                GET_NONNEGATIVE_VALUE(EGL_BLUE_SIZE, blue_size);
-+                GET_NONNEGATIVE_VALUE(EGL_ALPHA_SIZE, alpha_size);
-+                case EGL_NATIVE_BUFFER_USAGE_ANDROID:
-+                    if (value & EGL_NATIVE_BUFFER_USAGE_PROTECTED_BIT_ANDROID) {
-+                        usage |= GRALLOC_USAGE_PROTECTED;
-+                    }
-+                    if (value & EGL_NATIVE_BUFFER_USAGE_RENDERBUFFER_BIT_ANDROID) {
-+                        usage |= GRALLOC_USAGE_HW_RENDER;
-+                    }
-+                    if (value & EGL_NATIVE_BUFFER_USAGE_TEXTURE_BIT_ANDROID) {
-+                        usage |= GRALLOC_USAGE_HW_TEXTURE;
-+                    }
-+                    break;
-+                default:
-+                    return setError(EGL_BAD_PARAMETER, (EGLClientBuffer)0);
-+            }
-+        }
-+    }
-+#undef GET_NONNEGATIVE_VALUE
-+
-+    // Validate format.
-+    if (red_size == 8 && green_size == 8 && blue_size == 8) {
-+        if (alpha_size == 8) {
-+            format = HAL_PIXEL_FORMAT_RGBA_8888;
-+        } else {
-+            format = HAL_PIXEL_FORMAT_RGB_888;
-+        }
-+    } else if (red_size == 5 && green_size == 6 && blue_size == 5 &&
-+               alpha_size == 0) {
-+        format = HAL_PIXEL_FORMAT_RGB_565;
-+    } else {
-+        ALOGE("Invalid native pixel format { r=%d, g=%d, b=%d, a=%d }",
-+                red_size, green_size, blue_size, alpha_size);
-+        return setError(EGL_BAD_PARAMETER, (EGLClientBuffer)0);
-+    }
-+
-+#define CHECK_ERROR_CONDITION(message) \
-+    if (err != NO_ERROR) { \
-+        ALOGE(message); \
-+        goto error_condition; \
-+    }
-+
-+    // The holder is used to destroy the buffer if an error occurs.
-+    GraphicBuffer* gBuffer = new GraphicBuffer();
-+    sp<IServiceManager> sm = defaultServiceManager();
-+    sp<IBinder> surfaceFlinger = sm->getService(String16("SurfaceFlinger"));
-+    sp<IBinder> allocator;
-+    Parcel sc_data, sc_reply, data, reply;
-+    status_t err = NO_ERROR;
-+    if (sm == NULL) {
-+        ALOGE("Unable to connect to ServiceManager");
-+        goto error_condition;
-+    }
-+
-+    // Obtain an allocator.
-+    if (surfaceFlinger == NULL) {
-+        ALOGE("Unable to connect to SurfaceFlinger");
-+        goto error_condition;
-+    }
-+    sc_data.writeInterfaceToken(String16("android.ui.ISurfaceComposer"));
-+    err = surfaceFlinger->transact(
-+            BnSurfaceComposer::CREATE_GRAPHIC_BUFFER_ALLOC, sc_data, &sc_reply);
-+    CHECK_ERROR_CONDITION("Unable to obtain allocator from SurfaceFlinger");
-+    allocator = sc_reply.readStrongBinder();
-+
-+    if (allocator == NULL) {
-+        ALOGE("Unable to obtain an ISurfaceComposer");
-+        goto error_condition;
-+    }
-+    data.writeInterfaceToken(String16("android.ui.IGraphicBufferAlloc"));
-+    err = data.writeUint32(width);
-+    CHECK_ERROR_CONDITION("Unable to write width");
-+    err = data.writeUint32(height);
-+    CHECK_ERROR_CONDITION("Unable to write height");
-+    err = data.writeInt32(static_cast<int32_t>(format));
-+    CHECK_ERROR_CONDITION("Unable to write format");
-+    err = data.writeUint32(usage);
-+    CHECK_ERROR_CONDITION("Unable to write usage");
-+    err = data.writeUtf8AsUtf16(
-+            std::string("[eglCreateNativeClientBufferANDROID pid ") +
-+            std::to_string(getpid()) + ']');
-+    CHECK_ERROR_CONDITION("Unable to write requestor name");
-+    err = allocator->transact(IBinder::FIRST_CALL_TRANSACTION, data,
-+            &reply);
-+    CHECK_ERROR_CONDITION(
-+            "Unable to request buffer allocation from surface composer");
-+    err = reply.readInt32();
-+    CHECK_ERROR_CONDITION("Unable to obtain buffer from surface composer");
-+    err = reply.read(*gBuffer);
-+    CHECK_ERROR_CONDITION("Unable to read buffer from surface composer");
-+
-+    err = gBuffer->initCheck();
-+    if (err != NO_ERROR) {
-+        ALOGE("Unable to create native buffer { w=%d, h=%d, f=%d, u=%#x }: %#x",
-+                width, height, format, usage, err);
-+        goto error_condition;
-+    }
-+    ALOGD("Created new native buffer %p { w=%d, h=%d, f=%d, u=%#x }",
-+            gBuffer, width, height, format, usage);
-+    return static_cast<EGLClientBuffer>(gBuffer->getNativeBuffer());
-+
-+#undef CHECK_ERROR_CONDITION
-+
-+error_condition:
-+    // Delete the buffer.
-+    sp<GraphicBuffer> holder(gBuffer);
-+    return setError(EGL_BAD_ALLOC, (EGLClientBuffer)0);
-+}
-+
-+// ----------------------------------------------------------------------------
-+// NVIDIA extensions
-+// ----------------------------------------------------------------------------
-+EGLuint64NV eglGetSystemTimeFrequencyNV()
-+{
-+    clearError();
-+
-+    if (egl_init_drivers() == EGL_FALSE) {
-+        return setError(EGL_BAD_PARAMETER, EGL_FALSE);
-+    }
-+
-+    EGLuint64NV ret = 0;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+
-+    if (cnx->dso && cnx->egl.eglGetSystemTimeFrequencyNV) {
-+        return cnx->egl.eglGetSystemTimeFrequencyNV();
-+    }
-+
-+    return setErrorQuiet(EGL_BAD_DISPLAY, 0);
-+}
-+
-+EGLuint64NV eglGetSystemTimeNV()
-+{
-+    clearError();
-+
-+    if (egl_init_drivers() == EGL_FALSE) {
-+        return setError(EGL_BAD_PARAMETER, EGL_FALSE);
-+    }
-+
-+    EGLuint64NV ret = 0;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+
-+    if (cnx->dso && cnx->egl.eglGetSystemTimeNV) {
-+        return cnx->egl.eglGetSystemTimeNV();
-+    }
-+
-+    return setErrorQuiet(EGL_BAD_DISPLAY, 0);
-+}
-+
-+// ----------------------------------------------------------------------------
-+// Partial update extension
-+// ----------------------------------------------------------------------------
-+EGLBoolean eglSetDamageRegionKHR(EGLDisplay dpy, EGLSurface surface,
-+        EGLint *rects, EGLint n_rects)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) {
-+        setError(EGL_BAD_DISPLAY, EGL_FALSE);
-+        return EGL_FALSE;
-+    }
-+
-+    SurfaceRef _s(dp.get(), surface);
-+    if (!_s.get()) {
-+        setError(EGL_BAD_SURFACE, EGL_FALSE);
-+        return EGL_FALSE;
-+    }
-+
-+    egl_surface_t const * const s = get_surface(surface);
-+    if (s->cnx->egl.eglSetDamageRegionKHR) {
-+        return s->cnx->egl.eglSetDamageRegionKHR(dp->disp.dpy, s->surface,
-+                rects, n_rects);
-+    }
-+
-+    return EGL_FALSE;
-+}
-+
-+EGLBoolean eglGetFrameTimestampsANDROID(EGLDisplay dpy, EGLSurface surface,
-+        EGLint framesAgo, EGLint numTimestamps, const EGLint *timestamps,
-+        EGLnsecsANDROID *values)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) {
-+        setError(EGL_BAD_DISPLAY, EGL_FALSE);
-+        return EGL_FALSE;
-+    }
-+
-+    SurfaceRef _s(dp.get(), surface);
-+    if (!_s.get()) {
-+        setError(EGL_BAD_SURFACE, EGL_FALSE);
-+        return EGL_FALSE;
-+    }
-+
-+    egl_surface_t const * const s = get_surface(surface);
-+
-+    if (!s->enableTimestamps) {
-+        setError(EGL_BAD_SURFACE, EGL_FALSE);
-+        return EGL_FALSE;
-+    }
-+
-+    nsecs_t* postedTime = nullptr;
-+    nsecs_t* acquireTime = nullptr;
-+    nsecs_t* refreshStartTime = nullptr;
-+    nsecs_t* GLCompositionDoneTime = nullptr;
-+    nsecs_t* displayRetireTime = nullptr;
-+    nsecs_t* releaseTime = nullptr;
-+
-+    for (int i = 0; i < numTimestamps; i++) {
-+        switch (timestamps[i]) {
-+            case EGL_QUEUE_TIME_ANDROID:
-+                postedTime = &values[i];
-+                break;
-+            case EGL_RENDERING_COMPLETE_TIME_ANDROID:
-+                acquireTime = &values[i];
-+                break;
-+            case EGL_COMPOSITION_START_TIME_ANDROID:
-+                refreshStartTime = &values[i];
-+                break;
-+            case EGL_COMPOSITION_FINISHED_TIME_ANDROID:
-+                GLCompositionDoneTime = &values[i];
-+                break;
-+            case EGL_DISPLAY_RETIRE_TIME_ANDROID:
-+                displayRetireTime = &values[i];
-+                break;
-+            case EGL_READS_DONE_TIME_ANDROID:
-+                releaseTime = &values[i];
-+                break;
-+            default:
-+                setError(EGL_BAD_PARAMETER, EGL_FALSE);
-+                return EGL_FALSE;
-+        }
-+    }
-+
-+    status_t ret = native_window_get_frame_timestamps(s->win.get(), framesAgo,
-+            postedTime, acquireTime, refreshStartTime, GLCompositionDoneTime,
-+            displayRetireTime, releaseTime);
-+
-+    if (ret != NO_ERROR) {
-+        setError(EGL_BAD_ACCESS, EGL_FALSE);
-+        return EGL_FALSE;
-+    }
-+
-+    return EGL_TRUE;
-+}
-+
-+EGLBoolean eglQueryTimestampSupportedANDROID(EGLDisplay dpy, EGLSurface surface,
-+        EGLint timestamp)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) {
-+        setError(EGL_BAD_DISPLAY, EGL_FALSE);
-+        return EGL_FALSE;
-+    }
-+
-+    SurfaceRef _s(dp.get(), surface);
-+    if (!_s.get()) {
-+        setError(EGL_BAD_SURFACE, EGL_FALSE);
-+        return EGL_FALSE;
-+    }
-+
-+    switch (timestamp) {
-+#if ENABLE_EGL_ANDROID_GET_FRAME_TIMESTAMPS
-+        case EGL_QUEUE_TIME_ANDROID:
-+        case EGL_RENDERING_COMPLETE_TIME_ANDROID:
-+        case EGL_COMPOSITION_START_TIME_ANDROID:
-+        case EGL_COMPOSITION_FINISHED_TIME_ANDROID:
-+        case EGL_DISPLAY_RETIRE_TIME_ANDROID:
-+        case EGL_READS_DONE_TIME_ANDROID:
-+            return EGL_TRUE;
-+#endif
-+        default:
-+            return EGL_FALSE;
-+    }
-+}
diff -Naur frameworksRaw/native/opengl/libs/EGL/eglApi.cpp.orig.rej.orig frameworksModified/native/opengl/libs/EGL/eglApi.cpp.orig.rej.orig
--- frameworksRaw/native/opengl/libs/EGL/eglApi.cpp.orig.rej.orig	2017-07-06 15:34:21.314456285 +0530
+++ frameworksModified/native/opengl/libs/EGL/eglApi.cpp.orig.rej.orig	1970-01-01 05:30:00.000000000 +0530
@@ -1,2120 +0,0 @@
---- native/opengl/libs/EGL/eglApi.cpp.orig	1970-01-01 05:30:00.000000000 +0530
-+++ native/opengl/libs/EGL/eglApi.cpp.orig	2017-07-06 13:50:15.207676932 +0530
-@@ -0,0 +1,2117 @@
-+/*
-+ ** Copyright 2007, The Android Open Source Project
-+ **
-+ ** Licensed under the Apache License, Version 2.0 (the "License");
-+ ** you may not use this file except in compliance with the License.
-+ ** You may obtain a copy of the License at
-+ **
-+ **     http://www.apache.org/licenses/LICENSE-2.0
-+ **
-+ ** Unless required by applicable law or agreed to in writing, software
-+ ** distributed under the License is distributed on an "AS IS" BASIS,
-+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-+ ** See the License for the specific language governing permissions and
-+ ** limitations under the License.
-+ */
-+
-+#define ATRACE_TAG ATRACE_TAG_GRAPHICS
-+
-+#include <dlfcn.h>
-+#include <ctype.h>
-+#include <stdlib.h>
-+#include <string.h>
-+
-+#include <hardware/gralloc.h>
-+#include <system/window.h>
-+
-+#include <EGL/egl.h>
-+#include <EGL/eglext.h>
-+
-+#include <cutils/log.h>
-+#include <cutils/atomic.h>
-+#include <cutils/compiler.h>
-+#include <cutils/properties.h>
-+#include <cutils/memory.h>
-+
-+#include <gui/ISurfaceComposer.h>
-+
-+#include <ui/GraphicBuffer.h>
-+
-+#include <utils/KeyedVector.h>
-+#include <utils/SortedVector.h>
-+#include <utils/String8.h>
-+#include <utils/Trace.h>
-+
-+#include "binder/Binder.h"
-+#include "binder/Parcel.h"
-+#include "binder/IServiceManager.h"
-+
-+#include "../egl_impl.h"
-+#include "../hooks.h"
-+
-+#include "egl_display.h"
-+#include "egl_object.h"
-+#include "egl_tls.h"
-+#include "egldefs.h"
-+
-+using namespace android;
-+
-+// This extension has not been ratified yet, so can't be shipped.
-+// Implementation is incomplete and untested.
-+#define ENABLE_EGL_KHR_GL_COLORSPACE 0
-+
-+#define ENABLE_EGL_ANDROID_GET_FRAME_TIMESTAMPS 0
-+
-+// ----------------------------------------------------------------------------
-+
-+namespace android {
-+
-+struct extention_map_t {
-+    const char* name;
-+    __eglMustCastToProperFunctionPointerType address;
-+};
-+
-+/*
-+ * This is the list of EGL extensions exposed to applications.
-+ *
-+ * Some of them (gBuiltinExtensionString) are implemented entirely in this EGL
-+ * wrapper and are always available.
-+ *
-+ * The rest (gExtensionString) depend on support in the EGL driver, and are
-+ * only available if the driver supports them. However, some of these must be
-+ * supported because they are used by the Android system itself; these are
-+ * listed as mandatory below and are required by the CDD. The system *assumes*
-+ * the mandatory extensions are present and may not function properly if some
-+ * are missing.
-+ *
-+ * NOTE: Both strings MUST have a single space as the last character.
-+ */
-+extern char const * const gBuiltinExtensionString =
-+        "EGL_KHR_get_all_proc_addresses "
-+        "EGL_ANDROID_presentation_time "
-+        "EGL_KHR_swap_buffers_with_damage "
-+        "EGL_ANDROID_create_native_client_buffer "
-+        "EGL_ANDROID_front_buffer_auto_refresh "
-+#if ENABLE_EGL_ANDROID_GET_FRAME_TIMESTAMPS
-+        "EGL_ANDROID_get_frame_timestamps "
-+#endif
-+        ;
-+extern char const * const gExtensionString  =
-+        "EGL_KHR_image "                        // mandatory
-+        "EGL_KHR_image_base "                   // mandatory
-+        "EGL_KHR_image_pixmap "
-+        "EGL_KHR_lock_surface "
-+#if (ENABLE_EGL_KHR_GL_COLORSPACE != 0)
-+        "EGL_KHR_gl_colorspace "
-+#endif
-+        "EGL_KHR_gl_texture_2D_image "
-+        "EGL_KHR_gl_texture_3D_image "
-+        "EGL_KHR_gl_texture_cubemap_image "
-+        "EGL_KHR_gl_renderbuffer_image "
-+        "EGL_KHR_reusable_sync "
-+        "EGL_KHR_fence_sync "
-+        "EGL_KHR_create_context "
-+        "EGL_KHR_config_attribs "
-+        "EGL_KHR_surfaceless_context "
-+        "EGL_KHR_stream "
-+        "EGL_KHR_stream_fifo "
-+        "EGL_KHR_stream_producer_eglsurface "
-+        "EGL_KHR_stream_consumer_gltexture "
-+        "EGL_KHR_stream_cross_process_fd "
-+        "EGL_EXT_create_context_robustness "
-+        "EGL_NV_system_time "
-+        "EGL_ANDROID_image_native_buffer "      // mandatory
-+        "EGL_KHR_wait_sync "                    // strongly recommended
-+        "EGL_ANDROID_recordable "               // mandatory
-+        "EGL_KHR_partial_update "               // strongly recommended
-+        "EGL_EXT_buffer_age "                   // strongly recommended with partial_update
-+        "EGL_KHR_create_context_no_error "
-+        "EGL_KHR_mutable_render_buffer "
-+        "EGL_EXT_yuv_surface "
-+        "EGL_EXT_protected_content "
-+        ;
-+
-+// extensions not exposed to applications but used by the ANDROID system
-+//      "EGL_ANDROID_blob_cache "               // strongly recommended
-+//      "EGL_IMG_hibernate_process "            // optional
-+//      "EGL_ANDROID_native_fence_sync "        // strongly recommended
-+//      "EGL_ANDROID_framebuffer_target "       // mandatory for HWC 1.1
-+//      "EGL_ANDROID_image_crop "               // optional
-+
-+/*
-+ * EGL Extensions entry-points exposed to 3rd party applications
-+ * (keep in sync with gExtensionString above)
-+ *
-+ */
-+static const extention_map_t sExtensionMap[] = {
-+    // EGL_KHR_lock_surface
-+    { "eglLockSurfaceKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglLockSurfaceKHR },
-+    { "eglUnlockSurfaceKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglUnlockSurfaceKHR },
-+
-+    // EGL_KHR_image, EGL_KHR_image_base
-+    { "eglCreateImageKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglCreateImageKHR },
-+    { "eglDestroyImageKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglDestroyImageKHR },
-+
-+    // EGL_KHR_reusable_sync, EGL_KHR_fence_sync
-+    { "eglCreateSyncKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglCreateSyncKHR },
-+    { "eglDestroySyncKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglDestroySyncKHR },
-+    { "eglClientWaitSyncKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglClientWaitSyncKHR },
-+    { "eglSignalSyncKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglSignalSyncKHR },
-+    { "eglGetSyncAttribKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglGetSyncAttribKHR },
-+
-+    // EGL_NV_system_time
-+    { "eglGetSystemTimeFrequencyNV",
-+            (__eglMustCastToProperFunctionPointerType)&eglGetSystemTimeFrequencyNV },
-+    { "eglGetSystemTimeNV",
-+            (__eglMustCastToProperFunctionPointerType)&eglGetSystemTimeNV },
-+
-+    // EGL_KHR_wait_sync
-+    { "eglWaitSyncKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglWaitSyncKHR },
-+
-+    // EGL_ANDROID_presentation_time
-+    { "eglPresentationTimeANDROID",
-+            (__eglMustCastToProperFunctionPointerType)&eglPresentationTimeANDROID },
-+
-+    // EGL_KHR_swap_buffers_with_damage
-+    { "eglSwapBuffersWithDamageKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglSwapBuffersWithDamageKHR },
-+
-+    // EGL_ANDROID_native_client_buffer
-+    { "eglCreateNativeClientBufferANDROID",
-+            (__eglMustCastToProperFunctionPointerType)&eglCreateNativeClientBufferANDROID },
-+
-+    // EGL_KHR_partial_update
-+    { "eglSetDamageRegionKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglSetDamageRegionKHR },
-+
-+    { "eglCreateStreamKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglCreateStreamKHR },
-+    { "eglDestroyStreamKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglDestroyStreamKHR },
-+    { "eglStreamAttribKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglStreamAttribKHR },
-+    { "eglQueryStreamKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglQueryStreamKHR },
-+    { "eglQueryStreamu64KHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglQueryStreamu64KHR },
-+    { "eglQueryStreamTimeKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglQueryStreamTimeKHR },
-+    { "eglCreateStreamProducerSurfaceKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglCreateStreamProducerSurfaceKHR },
-+    { "eglStreamConsumerGLTextureExternalKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglStreamConsumerGLTextureExternalKHR },
-+    { "eglStreamConsumerAcquireKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglStreamConsumerAcquireKHR },
-+    { "eglStreamConsumerReleaseKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglStreamConsumerReleaseKHR },
-+    { "eglGetStreamFileDescriptorKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglGetStreamFileDescriptorKHR },
-+    { "eglCreateStreamFromFileDescriptorKHR",
-+            (__eglMustCastToProperFunctionPointerType)&eglCreateStreamFromFileDescriptorKHR },
-+
-+    // EGL_ANDROID_get_frame_timestamps
-+    { "eglGetFrameTimestampsANDROID",
-+            (__eglMustCastToProperFunctionPointerType)&eglGetFrameTimestampsANDROID },
-+    { "eglQueryTimestampSupportedANDROID",
-+            (__eglMustCastToProperFunctionPointerType)&eglQueryTimestampSupportedANDROID },
-+};
-+
-+/*
-+ * These extensions entry-points should not be exposed to applications.
-+ * They're used internally by the Android EGL layer.
-+ */
-+#define FILTER_EXTENSIONS(procname) \
-+        (!strcmp((procname), "eglSetBlobCacheFuncsANDROID") ||    \
-+         !strcmp((procname), "eglHibernateProcessIMG")      ||    \
-+         !strcmp((procname), "eglAwakenProcessIMG")         ||    \
-+         !strcmp((procname), "eglDupNativeFenceFDANDROID"))
-+
-+
-+
-+// accesses protected by sExtensionMapMutex
-+static DefaultKeyedVector<String8, __eglMustCastToProperFunctionPointerType> sGLExtentionMap;
-+static int sGLExtentionSlot = 0;
-+static pthread_mutex_t sExtensionMapMutex = PTHREAD_MUTEX_INITIALIZER;
-+
-+static void(*findProcAddress(const char* name,
-+        const extention_map_t* map, size_t n))() {
-+    for (uint32_t i=0 ; i<n ; i++) {
-+        if (!strcmp(name, map[i].name)) {
-+            return map[i].address;
-+        }
-+    }
-+    return NULL;
-+}
-+
-+// ----------------------------------------------------------------------------
-+
-+extern void setGLHooksThreadSpecific(gl_hooks_t const *value);
-+extern EGLBoolean egl_init_drivers();
-+extern const __eglMustCastToProperFunctionPointerType gExtensionForwarders[MAX_NUMBER_OF_GL_EXTENSIONS];
-+extern gl_hooks_t gHooksTrace;
-+
-+} // namespace android;
-+
-+
-+// ----------------------------------------------------------------------------
-+
-+static inline void clearError() { egl_tls_t::clearError(); }
-+static inline EGLContext getContext() { return egl_tls_t::getContext(); }
-+
-+// ----------------------------------------------------------------------------
-+
-+EGLDisplay eglGetDisplay(EGLNativeDisplayType display)
-+{
-+    ATRACE_CALL();
-+    clearError();
-+
-+    uintptr_t index = reinterpret_cast<uintptr_t>(display);
-+    if (index >= NUM_DISPLAYS) {
-+        return setError(EGL_BAD_PARAMETER, EGL_NO_DISPLAY);
-+    }
-+
-+    if (egl_init_drivers() == EGL_FALSE) {
-+        return setError(EGL_BAD_PARAMETER, EGL_NO_DISPLAY);
-+    }
-+
-+    EGLDisplay dpy = egl_display_t::getFromNativeDisplay(display);
-+    return dpy;
-+}
-+
-+// ----------------------------------------------------------------------------
-+// Initialization
-+// ----------------------------------------------------------------------------
-+
-+EGLBoolean eglInitialize(EGLDisplay dpy, EGLint *major, EGLint *minor)
-+{
-+    clearError();
-+
-+    egl_display_ptr dp = get_display(dpy);
-+    if (!dp) return setError(EGL_BAD_DISPLAY, EGL_FALSE);
-+
-+    EGLBoolean res = dp->initialize(major, minor);
-+
-+    return res;
-+}
-+
-+EGLBoolean eglTerminate(EGLDisplay dpy)
-+{
-+    // NOTE: don't unload the drivers b/c some APIs can be called
-+    // after eglTerminate() has been called. eglTerminate() only
-+    // terminates an EGLDisplay, not a EGL itself.
-+
-+    clearError();
-+
-+    egl_display_ptr dp = get_display(dpy);
-+    if (!dp) return setError(EGL_BAD_DISPLAY, EGL_FALSE);
-+
-+    EGLBoolean res = dp->terminate();
-+
-+    return res;
-+}
-+
-+// ----------------------------------------------------------------------------
-+// configuration
-+// ----------------------------------------------------------------------------
-+
-+EGLBoolean eglGetConfigs(   EGLDisplay dpy,
-+                            EGLConfig *configs,
-+                            EGLint config_size, EGLint *num_config)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    if (num_config==0) {
-+        return setError(EGL_BAD_PARAMETER, EGL_FALSE);
-+    }
-+
-+    EGLBoolean res = EGL_FALSE;
-+    *num_config = 0;
-+
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso) {
-+        res = cnx->egl.eglGetConfigs(
-+                dp->disp.dpy, configs, config_size, num_config);
-+    }
-+
-+    return res;
-+}
-+
-+EGLBoolean eglChooseConfig( EGLDisplay dpy, const EGLint *attrib_list,
-+                            EGLConfig *configs, EGLint config_size,
-+                            EGLint *num_config)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    if (num_config==0) {
-+        return setError(EGL_BAD_PARAMETER, EGL_FALSE);
-+    }
-+
-+    EGLBoolean res = EGL_FALSE;
-+    *num_config = 0;
-+
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso) {
-+        if (attrib_list) {
-+            char value[PROPERTY_VALUE_MAX];
-+            property_get("debug.egl.force_msaa", value, "false");
-+
-+            if (!strcmp(value, "true")) {
-+                size_t attribCount = 0;
-+                EGLint attrib = attrib_list[0];
-+
-+                // Only enable MSAA if the context is OpenGL ES 2.0 and
-+                // if no caveat is requested
-+                const EGLint *attribRendererable = NULL;
-+                const EGLint *attribCaveat = NULL;
-+
-+                // Count the number of attributes and look for
-+                // EGL_RENDERABLE_TYPE and EGL_CONFIG_CAVEAT
-+                while (attrib != EGL_NONE) {
-+                    attrib = attrib_list[attribCount];
-+                    switch (attrib) {
-+                        case EGL_RENDERABLE_TYPE:
-+                            attribRendererable = &attrib_list[attribCount];
-+                            break;
-+                        case EGL_CONFIG_CAVEAT:
-+                            attribCaveat = &attrib_list[attribCount];
-+                            break;
-+                    }
-+                    attribCount++;
-+                }
-+
-+                if (attribRendererable && attribRendererable[1] == EGL_OPENGL_ES2_BIT &&
-+                        (!attribCaveat || attribCaveat[1] != EGL_NONE)) {
-+
-+                    // Insert 2 extra attributes to force-enable MSAA 4x
-+                    EGLint aaAttribs[attribCount + 4];
-+                    aaAttribs[0] = EGL_SAMPLE_BUFFERS;
-+                    aaAttribs[1] = 1;
-+                    aaAttribs[2] = EGL_SAMPLES;
-+                    aaAttribs[3] = 4;
-+
-+                    memcpy(&aaAttribs[4], attrib_list, attribCount * sizeof(EGLint));
-+
-+                    EGLint numConfigAA;
-+                    EGLBoolean resAA = cnx->egl.eglChooseConfig(
-+                            dp->disp.dpy, aaAttribs, configs, config_size, &numConfigAA);
-+
-+                    if (resAA == EGL_TRUE && numConfigAA > 0) {
-+                        ALOGD("Enabling MSAA 4x");
-+                        *num_config = numConfigAA;
-+                        return resAA;
-+                    }
-+                }
-+            }
-+        }
-+
-+        res = cnx->egl.eglChooseConfig(
-+                dp->disp.dpy, attrib_list, configs, config_size, num_config);
-+    }
-+    return res;
-+}
-+
-+EGLBoolean eglGetConfigAttrib(EGLDisplay dpy, EGLConfig config,
-+        EGLint attribute, EGLint *value)
-+{
-+    clearError();
-+
-+    egl_connection_t* cnx = NULL;
-+    const egl_display_ptr dp = validate_display_connection(dpy, cnx);
-+    if (!dp) return EGL_FALSE;
-+
-+    return cnx->egl.eglGetConfigAttrib(
-+            dp->disp.dpy, config, attribute, value);
-+}
-+
-+// ----------------------------------------------------------------------------
-+// surfaces
-+// ----------------------------------------------------------------------------
-+
-+// The EGL_KHR_gl_colorspace spec hasn't been ratified yet, so these haven't
-+// been added to the Khronos egl.h.
-+#define EGL_GL_COLORSPACE_KHR           EGL_VG_COLORSPACE
-+#define EGL_GL_COLORSPACE_SRGB_KHR      EGL_VG_COLORSPACE_sRGB
-+#define EGL_GL_COLORSPACE_LINEAR_KHR    EGL_VG_COLORSPACE_LINEAR
-+
-+// Turn linear formats into corresponding sRGB formats when colorspace is
-+// EGL_GL_COLORSPACE_SRGB_KHR, or turn sRGB formats into corresponding linear
-+// formats when colorspace is EGL_GL_COLORSPACE_LINEAR_KHR. In any cases where
-+// the modification isn't possible, the original dataSpace is returned.
-+static android_dataspace modifyBufferDataspace( android_dataspace dataSpace,
-+                                                EGLint colorspace) {
-+    if (colorspace == EGL_GL_COLORSPACE_LINEAR_KHR) {
-+        return HAL_DATASPACE_SRGB_LINEAR;
-+    } else if (colorspace == EGL_GL_COLORSPACE_SRGB_KHR) {
-+        return HAL_DATASPACE_SRGB;
-+    }
-+    return dataSpace;
-+}
-+
-+EGLSurface eglCreateWindowSurface(  EGLDisplay dpy, EGLConfig config,
-+                                    NativeWindowType window,
-+                                    const EGLint *attrib_list)
-+{
-+    clearError();
-+
-+    egl_connection_t* cnx = NULL;
-+    egl_display_ptr dp = validate_display_connection(dpy, cnx);
-+    if (dp) {
-+        EGLDisplay iDpy = dp->disp.dpy;
-+
-+        int result = native_window_api_connect(window, NATIVE_WINDOW_API_EGL);
-+        if (result != OK) {
-+            ALOGE("eglCreateWindowSurface: native_window_api_connect (win=%p) "
-+                    "failed (%#x) (already connected to another API?)",
-+                    window, result);
-+            return setError(EGL_BAD_ALLOC, EGL_NO_SURFACE);
-+        }
-+
-+        // Set the native window's buffers format to match what this config requests.
-+        // Whether to use sRGB gamma is not part of the EGLconfig, but is part
-+        // of our native format. So if sRGB gamma is requested, we have to
-+        // modify the EGLconfig's format before setting the native window's
-+        // format.
-+
-+        // by default, just pick RGBA_8888
-+        EGLint format = HAL_PIXEL_FORMAT_RGBA_8888;
-+        android_dataspace dataSpace = HAL_DATASPACE_UNKNOWN;
-+
-+        EGLint a = 0;
-+        cnx->egl.eglGetConfigAttrib(iDpy, config, EGL_ALPHA_SIZE, &a);
-+        if (a > 0) {
-+            // alpha-channel requested, there's really only one suitable format
-+            format = HAL_PIXEL_FORMAT_RGBA_8888;
-+        } else {
-+            EGLint r, g, b;
-+            r = g = b = 0;
-+            cnx->egl.eglGetConfigAttrib(iDpy, config, EGL_RED_SIZE,   &r);
-+            cnx->egl.eglGetConfigAttrib(iDpy, config, EGL_GREEN_SIZE, &g);
-+            cnx->egl.eglGetConfigAttrib(iDpy, config, EGL_BLUE_SIZE,  &b);
-+            EGLint colorDepth = r + g + b;
-+            if (colorDepth <= 16) {
-+                format = HAL_PIXEL_FORMAT_RGB_565;
-+            } else {
-+                format = HAL_PIXEL_FORMAT_RGBX_8888;
-+            }
-+        }
-+
-+        // now select a corresponding sRGB format if needed
-+        if (attrib_list && dp->haveExtension("EGL_KHR_gl_colorspace")) {
-+            for (const EGLint* attr = attrib_list; *attr != EGL_NONE; attr += 2) {
-+                if (*attr == EGL_GL_COLORSPACE_KHR) {
-+                    if (ENABLE_EGL_KHR_GL_COLORSPACE) {
-+                        dataSpace = modifyBufferDataspace(dataSpace, *(attr+1));
-+                    } else {
-+                        // Normally we'd pass through unhandled attributes to
-+                        // the driver. But in case the driver implements this
-+                        // extension but we're disabling it, we want to prevent
-+                        // it getting through -- support will be broken without
-+                        // our help.
-+                        ALOGE("sRGB window surfaces not supported");
-+                        return setError(EGL_BAD_ATTRIBUTE, EGL_NO_SURFACE);
-+                    }
-+                }
-+            }
-+        }
-+
-+        if (format != 0) {
-+            int err = native_window_set_buffers_format(window, format);
-+            if (err != 0) {
-+                ALOGE("error setting native window pixel format: %s (%d)",
-+                        strerror(-err), err);
-+                native_window_api_disconnect(window, NATIVE_WINDOW_API_EGL);
-+                return setError(EGL_BAD_NATIVE_WINDOW, EGL_NO_SURFACE);
-+            }
-+        }
-+
-+        if (dataSpace != 0) {
-+            int err = native_window_set_buffers_data_space(window, dataSpace);
-+            if (err != 0) {
-+                ALOGE("error setting native window pixel dataSpace: %s (%d)",
-+                        strerror(-err), err);
-+                native_window_api_disconnect(window, NATIVE_WINDOW_API_EGL);
-+                return setError(EGL_BAD_NATIVE_WINDOW, EGL_NO_SURFACE);
-+            }
-+        }
-+
-+        // the EGL spec requires that a new EGLSurface default to swap interval
-+        // 1, so explicitly set that on the window here.
-+        ANativeWindow* anw = reinterpret_cast<ANativeWindow*>(window);
-+        anw->setSwapInterval(anw, 1);
-+
-+        EGLSurface surface = cnx->egl.eglCreateWindowSurface(
-+                iDpy, config, window, attrib_list);
-+        if (surface != EGL_NO_SURFACE) {
-+            egl_surface_t* s = new egl_surface_t(dp.get(), config, window,
-+                    surface, cnx);
-+            return s;
-+        }
-+
-+        // EGLSurface creation failed
-+        native_window_set_buffers_format(window, 0);
-+        native_window_api_disconnect(window, NATIVE_WINDOW_API_EGL);
-+    }
-+    return EGL_NO_SURFACE;
-+}
-+
-+EGLSurface eglCreatePixmapSurface(  EGLDisplay dpy, EGLConfig config,
-+                                    NativePixmapType pixmap,
-+                                    const EGLint *attrib_list)
-+{
-+    clearError();
-+
-+    egl_connection_t* cnx = NULL;
-+    egl_display_ptr dp = validate_display_connection(dpy, cnx);
-+    if (dp) {
-+        EGLSurface surface = cnx->egl.eglCreatePixmapSurface(
-+                dp->disp.dpy, config, pixmap, attrib_list);
-+        if (surface != EGL_NO_SURFACE) {
-+            egl_surface_t* s = new egl_surface_t(dp.get(), config, NULL,
-+                    surface, cnx);
-+            return s;
-+        }
-+    }
-+    return EGL_NO_SURFACE;
-+}
-+
-+EGLSurface eglCreatePbufferSurface( EGLDisplay dpy, EGLConfig config,
-+                                    const EGLint *attrib_list)
-+{
-+    clearError();
-+
-+    egl_connection_t* cnx = NULL;
-+    egl_display_ptr dp = validate_display_connection(dpy, cnx);
-+    if (dp) {
-+        EGLSurface surface = cnx->egl.eglCreatePbufferSurface(
-+                dp->disp.dpy, config, attrib_list);
-+        if (surface != EGL_NO_SURFACE) {
-+            egl_surface_t* s = new egl_surface_t(dp.get(), config, NULL,
-+                    surface, cnx);
-+            return s;
-+        }
-+    }
-+    return EGL_NO_SURFACE;
-+}
-+
-+EGLBoolean eglDestroySurface(EGLDisplay dpy, EGLSurface surface)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    SurfaceRef _s(dp.get(), surface);
-+    if (!_s.get())
-+        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-+
-+    egl_surface_t * const s = get_surface(surface);
-+    EGLBoolean result = s->cnx->egl.eglDestroySurface(dp->disp.dpy, s->surface);
-+    if (result == EGL_TRUE) {
-+        _s.terminate();
-+    }
-+    return result;
-+}
-+
-+EGLBoolean eglQuerySurface( EGLDisplay dpy, EGLSurface surface,
-+                            EGLint attribute, EGLint *value)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    SurfaceRef _s(dp.get(), surface);
-+    if (!_s.get())
-+        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-+
-+    egl_surface_t const * const s = get_surface(surface);
-+    return s->cnx->egl.eglQuerySurface(
-+            dp->disp.dpy, s->surface, attribute, value);
-+}
-+
-+void EGLAPI eglBeginFrame(EGLDisplay dpy, EGLSurface surface) {
-+    ATRACE_CALL();
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) {
-+        return;
-+    }
-+
-+    SurfaceRef _s(dp.get(), surface);
-+    if (!_s.get()) {
-+        setError(EGL_BAD_SURFACE, EGL_FALSE);
-+        return;
-+    }
-+}
-+
-+// ----------------------------------------------------------------------------
-+// Contexts
-+// ----------------------------------------------------------------------------
-+
-+EGLContext eglCreateContext(EGLDisplay dpy, EGLConfig config,
-+                            EGLContext share_list, const EGLint *attrib_list)
-+{
-+    clearError();
-+
-+    egl_connection_t* cnx = NULL;
-+    const egl_display_ptr dp = validate_display_connection(dpy, cnx);
-+    if (dp) {
-+        if (share_list != EGL_NO_CONTEXT) {
-+            if (!ContextRef(dp.get(), share_list).get()) {
-+                return setError(EGL_BAD_CONTEXT, EGL_NO_CONTEXT);
-+            }
-+            egl_context_t* const c = get_context(share_list);
-+            share_list = c->context;
-+        }
-+        EGLContext context = cnx->egl.eglCreateContext(
-+                dp->disp.dpy, config, share_list, attrib_list);
-+        if (context != EGL_NO_CONTEXT) {
-+            // figure out if it's a GLESv1 or GLESv2
-+            int version = 0;
-+            if (attrib_list) {
-+                while (*attrib_list != EGL_NONE) {
-+                    GLint attr = *attrib_list++;
-+                    GLint value = *attrib_list++;
-+                    if (attr == EGL_CONTEXT_CLIENT_VERSION) {
-+                        if (value == 1) {
-+                            version = egl_connection_t::GLESv1_INDEX;
-+                        } else if (value == 2 || value == 3) {
-+                            version = egl_connection_t::GLESv2_INDEX;
-+                        }
-+                    }
-+                };
-+            }
-+            egl_context_t* c = new egl_context_t(dpy, context, config, cnx,
-+                    version);
-+            return c;
-+        }
-+    }
-+    return EGL_NO_CONTEXT;
-+}
-+
-+EGLBoolean eglDestroyContext(EGLDisplay dpy, EGLContext ctx)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp)
-+        return EGL_FALSE;
-+
-+    ContextRef _c(dp.get(), ctx);
-+    if (!_c.get())
-+        return setError(EGL_BAD_CONTEXT, EGL_FALSE);
-+
-+    egl_context_t * const c = get_context(ctx);
-+    EGLBoolean result = c->cnx->egl.eglDestroyContext(dp->disp.dpy, c->context);
-+    if (result == EGL_TRUE) {
-+        _c.terminate();
-+    }
-+    return result;
-+}
-+
-+EGLBoolean eglMakeCurrent(  EGLDisplay dpy, EGLSurface draw,
-+                            EGLSurface read, EGLContext ctx)
-+{
-+    clearError();
-+
-+    egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return setError(EGL_BAD_DISPLAY, EGL_FALSE);
-+
-+    // If ctx is not EGL_NO_CONTEXT, read is not EGL_NO_SURFACE, or draw is not
-+    // EGL_NO_SURFACE, then an EGL_NOT_INITIALIZED error is generated if dpy is
-+    // a valid but uninitialized display.
-+    if ( (ctx != EGL_NO_CONTEXT) || (read != EGL_NO_SURFACE) ||
-+         (draw != EGL_NO_SURFACE) ) {
-+        if (!dp->isReady()) return setError(EGL_NOT_INITIALIZED, EGL_FALSE);
-+    }
-+
-+    // get a reference to the object passed in
-+    ContextRef _c(dp.get(), ctx);
-+    SurfaceRef _d(dp.get(), draw);
-+    SurfaceRef _r(dp.get(), read);
-+
-+    // validate the context (if not EGL_NO_CONTEXT)
-+    if ((ctx != EGL_NO_CONTEXT) && !_c.get()) {
-+        // EGL_NO_CONTEXT is valid
-+        return setError(EGL_BAD_CONTEXT, EGL_FALSE);
-+    }
-+
-+    // these are the underlying implementation's object
-+    EGLContext impl_ctx  = EGL_NO_CONTEXT;
-+    EGLSurface impl_draw = EGL_NO_SURFACE;
-+    EGLSurface impl_read = EGL_NO_SURFACE;
-+
-+    // these are our objects structs passed in
-+    egl_context_t       * c = NULL;
-+    egl_surface_t const * d = NULL;
-+    egl_surface_t const * r = NULL;
-+
-+    // these are the current objects structs
-+    egl_context_t * cur_c = get_context(getContext());
-+
-+    if (ctx != EGL_NO_CONTEXT) {
-+        c = get_context(ctx);
-+        impl_ctx = c->context;
-+    } else {
-+        // no context given, use the implementation of the current context
-+        if (draw != EGL_NO_SURFACE || read != EGL_NO_SURFACE) {
-+            // calling eglMakeCurrent( ..., !=0, !=0, EGL_NO_CONTEXT);
-+            return setError(EGL_BAD_MATCH, EGL_FALSE);
-+        }
-+        if (cur_c == NULL) {
-+            // no current context
-+            // not an error, there is just no current context.
-+            return EGL_TRUE;
-+        }
-+    }
-+
-+    // retrieve the underlying implementation's draw EGLSurface
-+    if (draw != EGL_NO_SURFACE) {
-+        if (!_d.get()) return setError(EGL_BAD_SURFACE, EGL_FALSE);
-+        d = get_surface(draw);
-+        impl_draw = d->surface;
-+    }
-+
-+    // retrieve the underlying implementation's read EGLSurface
-+    if (read != EGL_NO_SURFACE) {
-+        if (!_r.get()) return setError(EGL_BAD_SURFACE, EGL_FALSE);
-+        r = get_surface(read);
-+        impl_read = r->surface;
-+    }
-+
-+
-+    EGLBoolean result = dp->makeCurrent(c, cur_c,
-+            draw, read, ctx,
-+            impl_draw, impl_read, impl_ctx);
-+
-+    if (result == EGL_TRUE) {
-+        if (c) {
-+            setGLHooksThreadSpecific(c->cnx->hooks[c->version]);
-+            egl_tls_t::setContext(ctx);
-+            _c.acquire();
-+            _r.acquire();
-+            _d.acquire();
-+        } else {
-+            setGLHooksThreadSpecific(&gHooksNoContext);
-+            egl_tls_t::setContext(EGL_NO_CONTEXT);
-+        }
-+    } else {
-+        // this will ALOGE the error
-+        egl_connection_t* const cnx = &gEGLImpl;
-+        result = setError(cnx->egl.eglGetError(), EGL_FALSE);
-+    }
-+    return result;
-+}
-+
-+
-+EGLBoolean eglQueryContext( EGLDisplay dpy, EGLContext ctx,
-+                            EGLint attribute, EGLint *value)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    ContextRef _c(dp.get(), ctx);
-+    if (!_c.get()) return setError(EGL_BAD_CONTEXT, EGL_FALSE);
-+
-+    egl_context_t * const c = get_context(ctx);
-+    return c->cnx->egl.eglQueryContext(
-+            dp->disp.dpy, c->context, attribute, value);
-+
-+}
-+
-+EGLContext eglGetCurrentContext(void)
-+{
-+    // could be called before eglInitialize(), but we wouldn't have a context
-+    // then, and this function would correctly return EGL_NO_CONTEXT.
-+
-+    clearError();
-+
-+    EGLContext ctx = getContext();
-+    return ctx;
-+}
-+
-+EGLSurface eglGetCurrentSurface(EGLint readdraw)
-+{
-+    // could be called before eglInitialize(), but we wouldn't have a context
-+    // then, and this function would correctly return EGL_NO_SURFACE.
-+
-+    clearError();
-+
-+    EGLContext ctx = getContext();
-+    if (ctx) {
-+        egl_context_t const * const c = get_context(ctx);
-+        if (!c) return setError(EGL_BAD_CONTEXT, EGL_NO_SURFACE);
-+        switch (readdraw) {
-+            case EGL_READ: return c->read;
-+            case EGL_DRAW: return c->draw;
-+            default: return setError(EGL_BAD_PARAMETER, EGL_NO_SURFACE);
-+        }
-+    }
-+    return EGL_NO_SURFACE;
-+}
-+
-+EGLDisplay eglGetCurrentDisplay(void)
-+{
-+    // could be called before eglInitialize(), but we wouldn't have a context
-+    // then, and this function would correctly return EGL_NO_DISPLAY.
-+
-+    clearError();
-+
-+    EGLContext ctx = getContext();
-+    if (ctx) {
-+        egl_context_t const * const c = get_context(ctx);
-+        if (!c) return setError(EGL_BAD_CONTEXT, EGL_NO_SURFACE);
-+        return c->dpy;
-+    }
-+    return EGL_NO_DISPLAY;
-+}
-+
-+EGLBoolean eglWaitGL(void)
-+{
-+    clearError();
-+
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (!cnx->dso)
-+        return setError(EGL_BAD_CONTEXT, EGL_FALSE);
-+
-+    return cnx->egl.eglWaitGL();
-+}
-+
-+EGLBoolean eglWaitNative(EGLint engine)
-+{
-+    clearError();
-+
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (!cnx->dso)
-+        return setError(EGL_BAD_CONTEXT, EGL_FALSE);
-+
-+    return cnx->egl.eglWaitNative(engine);
-+}
-+
-+EGLint eglGetError(void)
-+{
-+    EGLint err = EGL_SUCCESS;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso) {
-+        err = cnx->egl.eglGetError();
-+    }
-+    if (err == EGL_SUCCESS) {
-+        err = egl_tls_t::getError();
-+    }
-+    return err;
-+}
-+
-+static __eglMustCastToProperFunctionPointerType findBuiltinWrapper(
-+        const char* procname) {
-+    const egl_connection_t* cnx = &gEGLImpl;
-+    void* proc = NULL;
-+
-+    proc = dlsym(cnx->libEgl, procname);
-+    if (proc) return (__eglMustCastToProperFunctionPointerType)proc;
-+
-+    proc = dlsym(cnx->libGles2, procname);
-+    if (proc) return (__eglMustCastToProperFunctionPointerType)proc;
-+
-+    proc = dlsym(cnx->libGles1, procname);
-+    if (proc) return (__eglMustCastToProperFunctionPointerType)proc;
-+
-+    return NULL;
-+}
-+
-+__eglMustCastToProperFunctionPointerType eglGetProcAddress(const char *procname)
-+{
-+    // eglGetProcAddress() could be the very first function called
-+    // in which case we must make sure we've initialized ourselves, this
-+    // happens the first time egl_get_display() is called.
-+
-+    clearError();
-+
-+    if (egl_init_drivers() == EGL_FALSE) {
-+        setError(EGL_BAD_PARAMETER, NULL);
-+        return  NULL;
-+    }
-+
-+    if (FILTER_EXTENSIONS(procname)) {
-+        return NULL;
-+    }
-+
-+    __eglMustCastToProperFunctionPointerType addr;
-+    addr = findProcAddress(procname, sExtensionMap, NELEM(sExtensionMap));
-+    if (addr) return addr;
-+
-+    addr = findBuiltinWrapper(procname);
-+    if (addr) return addr;
-+
-+    // this protects accesses to sGLExtentionMap and sGLExtentionSlot
-+    pthread_mutex_lock(&sExtensionMapMutex);
-+
-+        /*
-+         * Since eglGetProcAddress() is not associated to anything, it needs
-+         * to return a function pointer that "works" regardless of what
-+         * the current context is.
-+         *
-+         * For this reason, we return a "forwarder", a small stub that takes
-+         * care of calling the function associated with the context
-+         * currently bound.
-+         *
-+         * We first look for extensions we've already resolved, if we're seeing
-+         * this extension for the first time, we go through all our
-+         * implementations and call eglGetProcAddress() and record the
-+         * result in the appropriate implementation hooks and return the
-+         * address of the forwarder corresponding to that hook set.
-+         *
-+         */
-+
-+        const String8 name(procname);
-+        addr = sGLExtentionMap.valueFor(name);
-+        const int slot = sGLExtentionSlot;
-+
-+        ALOGE_IF(slot >= MAX_NUMBER_OF_GL_EXTENSIONS,
-+                "no more slots for eglGetProcAddress(\"%s\")",
-+                procname);
-+
-+        if (!addr && (slot < MAX_NUMBER_OF_GL_EXTENSIONS)) {
-+            bool found = false;
-+
-+            egl_connection_t* const cnx = &gEGLImpl;
-+            if (cnx->dso && cnx->egl.eglGetProcAddress) {
-+                // Extensions are independent of the bound context
-+                addr =
-+                cnx->hooks[egl_connection_t::GLESv1_INDEX]->ext.extensions[slot] =
-+                cnx->hooks[egl_connection_t::GLESv2_INDEX]->ext.extensions[slot] =
-+                        cnx->egl.eglGetProcAddress(procname);
-+                if (addr) found = true;
-+            }
-+
-+            if (found) {
-+                addr = gExtensionForwarders[slot];
-+                sGLExtentionMap.add(name, addr);
-+                sGLExtentionSlot++;
-+            }
-+        }
-+
-+    pthread_mutex_unlock(&sExtensionMapMutex);
-+    return addr;
-+}
-+
-+class FrameCompletionThread : public Thread {
-+public:
-+
-+    static void queueSync(EGLSyncKHR sync) {
-+        static sp<FrameCompletionThread> thread(new FrameCompletionThread);
-+        static bool running = false;
-+        if (!running) {
-+            thread->run("GPUFrameCompletion");
-+            running = true;
-+        }
-+        {
-+            Mutex::Autolock lock(thread->mMutex);
-+            ScopedTrace st(ATRACE_TAG, String8::format("kicked off frame %d",
-+                    thread->mFramesQueued).string());
-+            thread->mQueue.push_back(sync);
-+            thread->mCondition.signal();
-+            thread->mFramesQueued++;
-+            ATRACE_INT("GPU Frames Outstanding", thread->mQueue.size());
-+        }
-+    }
-+
-+private:
-+    FrameCompletionThread() : mFramesQueued(0), mFramesCompleted(0) {}
-+
-+    virtual bool threadLoop() {
-+        EGLSyncKHR sync;
-+        uint32_t frameNum;
-+        {
-+            Mutex::Autolock lock(mMutex);
-+            while (mQueue.isEmpty()) {
-+                mCondition.wait(mMutex);
-+            }
-+            sync = mQueue[0];
-+            frameNum = mFramesCompleted;
-+        }
-+        EGLDisplay dpy = eglGetDisplay(EGL_DEFAULT_DISPLAY);
-+        {
-+            ScopedTrace st(ATRACE_TAG, String8::format("waiting for frame %d",
-+                    frameNum).string());
-+            EGLint result = eglClientWaitSyncKHR(dpy, sync, 0, EGL_FOREVER_KHR);
-+            if (result == EGL_FALSE) {
-+                ALOGE("FrameCompletion: error waiting for fence: %#x", eglGetError());
-+            } else if (result == EGL_TIMEOUT_EXPIRED_KHR) {
-+                ALOGE("FrameCompletion: timeout waiting for fence");
-+            }
-+            eglDestroySyncKHR(dpy, sync);
-+        }
-+        {
-+            Mutex::Autolock lock(mMutex);
-+            mQueue.removeAt(0);
-+            mFramesCompleted++;
-+            ATRACE_INT("GPU Frames Outstanding", mQueue.size());
-+        }
-+        return true;
-+    }
-+
-+    uint32_t mFramesQueued;
-+    uint32_t mFramesCompleted;
-+    Vector<EGLSyncKHR> mQueue;
-+    Condition mCondition;
-+    Mutex mMutex;
-+};
-+
-+EGLBoolean eglSwapBuffersWithDamageKHR(EGLDisplay dpy, EGLSurface draw,
-+        EGLint *rects, EGLint n_rects)
-+{
-+    ATRACE_CALL();
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    SurfaceRef _s(dp.get(), draw);
-+    if (!_s.get())
-+        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-+
-+    egl_surface_t const * const s = get_surface(draw);
-+
-+    if (CC_UNLIKELY(dp->traceGpuCompletion)) {
-+        EGLSyncKHR sync = eglCreateSyncKHR(dpy, EGL_SYNC_FENCE_KHR, NULL);
-+        if (sync != EGL_NO_SYNC_KHR) {
-+            FrameCompletionThread::queueSync(sync);
-+        }
-+    }
-+
-+    if (CC_UNLIKELY(dp->finishOnSwap)) {
-+        uint32_t pixel;
-+        egl_context_t * const c = get_context( egl_tls_t::getContext() );
-+        if (c) {
-+            // glReadPixels() ensures that the frame is complete
-+            s->cnx->hooks[c->version]->gl.glReadPixels(0,0,1,1,
-+                    GL_RGBA,GL_UNSIGNED_BYTE,&pixel);
-+        }
-+    }
-+
-+    if (n_rects == 0) {
-+        return s->cnx->egl.eglSwapBuffers(dp->disp.dpy, s->surface);
-+    }
-+
-+    Vector<android_native_rect_t> androidRects;
-+    for (int r = 0; r < n_rects; ++r) {
-+        int offset = r * 4;
-+        int x = rects[offset];
-+        int y = rects[offset + 1];
-+        int width = rects[offset + 2];
-+        int height = rects[offset + 3];
-+        android_native_rect_t androidRect;
-+        androidRect.left = x;
-+        androidRect.top = y + height;
-+        androidRect.right = x + width;
-+        androidRect.bottom = y;
-+        androidRects.push_back(androidRect);
-+    }
-+    native_window_set_surface_damage(s->win.get(), androidRects.array(),
-+            androidRects.size());
-+
-+    if (s->cnx->egl.eglSwapBuffersWithDamageKHR) {
-+        return s->cnx->egl.eglSwapBuffersWithDamageKHR(dp->disp.dpy, s->surface,
-+                rects, n_rects);
-+    } else {
-+        return s->cnx->egl.eglSwapBuffers(dp->disp.dpy, s->surface);
-+    }
-+}
-+
-+EGLBoolean eglSwapBuffers(EGLDisplay dpy, EGLSurface surface)
-+{
-+    return eglSwapBuffersWithDamageKHR(dpy, surface, NULL, 0);
-+}
-+
-+EGLBoolean eglCopyBuffers(  EGLDisplay dpy, EGLSurface surface,
-+                            NativePixmapType target)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    SurfaceRef _s(dp.get(), surface);
-+    if (!_s.get())
-+        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-+
-+    egl_surface_t const * const s = get_surface(surface);
-+    return s->cnx->egl.eglCopyBuffers(dp->disp.dpy, s->surface, target);
-+}
-+
-+const char* eglQueryString(EGLDisplay dpy, EGLint name)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return (const char *) NULL;
-+
-+    switch (name) {
-+        case EGL_VENDOR:
-+            return dp->getVendorString();
-+        case EGL_VERSION:
-+            return dp->getVersionString();
-+        case EGL_EXTENSIONS:
-+            return dp->getExtensionString();
-+        case EGL_CLIENT_APIS:
-+            return dp->getClientApiString();
-+    }
-+    return setError(EGL_BAD_PARAMETER, (const char *)0);
-+}
-+
-+EGLAPI const char* eglQueryStringImplementationANDROID(EGLDisplay dpy, EGLint name)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return (const char *) NULL;
-+
-+    switch (name) {
-+        case EGL_VENDOR:
-+            return dp->disp.queryString.vendor;
-+        case EGL_VERSION:
-+            return dp->disp.queryString.version;
-+        case EGL_EXTENSIONS:
-+            return dp->disp.queryString.extensions;
-+        case EGL_CLIENT_APIS:
-+            return dp->disp.queryString.clientApi;
-+    }
-+    return setError(EGL_BAD_PARAMETER, (const char *)0);
-+}
-+
-+// ----------------------------------------------------------------------------
-+// EGL 1.1
-+// ----------------------------------------------------------------------------
-+
-+EGLBoolean eglSurfaceAttrib(
-+        EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint value)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    SurfaceRef _s(dp.get(), surface);
-+    if (!_s.get())
-+        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-+
-+    egl_surface_t * const s = get_surface(surface);
-+
-+    if (attribute == EGL_FRONT_BUFFER_AUTO_REFRESH_ANDROID) {
-+        int err = native_window_set_auto_refresh(s->win.get(),
-+            value ? true : false);
-+        return (err == NO_ERROR) ? EGL_TRUE :
-+            setError(EGL_BAD_SURFACE, EGL_FALSE);
-+    }
-+
-+#if ENABLE_EGL_ANDROID_GET_FRAME_TIMESTAMPS
-+    if (attribute == EGL_TIMESTAMPS_ANDROID) {
-+        s->enableTimestamps = value;
-+        return EGL_TRUE;
-+    }
-+#endif
-+
-+    if (s->cnx->egl.eglSurfaceAttrib) {
-+        return s->cnx->egl.eglSurfaceAttrib(
-+                dp->disp.dpy, s->surface, attribute, value);
-+    }
-+    return setError(EGL_BAD_SURFACE, EGL_FALSE);
-+}
-+
-+EGLBoolean eglBindTexImage(
-+        EGLDisplay dpy, EGLSurface surface, EGLint buffer)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    SurfaceRef _s(dp.get(), surface);
-+    if (!_s.get())
-+        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-+
-+    egl_surface_t const * const s = get_surface(surface);
-+    if (s->cnx->egl.eglBindTexImage) {
-+        return s->cnx->egl.eglBindTexImage(
-+                dp->disp.dpy, s->surface, buffer);
-+    }
-+    return setError(EGL_BAD_SURFACE, EGL_FALSE);
-+}
-+
-+EGLBoolean eglReleaseTexImage(
-+        EGLDisplay dpy, EGLSurface surface, EGLint buffer)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    SurfaceRef _s(dp.get(), surface);
-+    if (!_s.get())
-+        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-+
-+    egl_surface_t const * const s = get_surface(surface);
-+    if (s->cnx->egl.eglReleaseTexImage) {
-+        return s->cnx->egl.eglReleaseTexImage(
-+                dp->disp.dpy, s->surface, buffer);
-+    }
-+    return setError(EGL_BAD_SURFACE, EGL_FALSE);
-+}
-+
-+EGLBoolean eglSwapInterval(EGLDisplay dpy, EGLint interval)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    EGLBoolean res = EGL_TRUE;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglSwapInterval) {
-+        res = cnx->egl.eglSwapInterval(dp->disp.dpy, interval);
-+    }
-+
-+    return res;
-+}
-+
-+
-+// ----------------------------------------------------------------------------
-+// EGL 1.2
-+// ----------------------------------------------------------------------------
-+
-+EGLBoolean eglWaitClient(void)
-+{
-+    clearError();
-+
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (!cnx->dso)
-+        return setError(EGL_BAD_CONTEXT, EGL_FALSE);
-+
-+    EGLBoolean res;
-+    if (cnx->egl.eglWaitClient) {
-+        res = cnx->egl.eglWaitClient();
-+    } else {
-+        res = cnx->egl.eglWaitGL();
-+    }
-+    return res;
-+}
-+
-+EGLBoolean eglBindAPI(EGLenum api)
-+{
-+    clearError();
-+
-+    if (egl_init_drivers() == EGL_FALSE) {
-+        return setError(EGL_BAD_PARAMETER, EGL_FALSE);
-+    }
-+
-+    // bind this API on all EGLs
-+    EGLBoolean res = EGL_TRUE;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglBindAPI) {
-+        res = cnx->egl.eglBindAPI(api);
-+    }
-+    return res;
-+}
-+
-+EGLenum eglQueryAPI(void)
-+{
-+    clearError();
-+
-+    if (egl_init_drivers() == EGL_FALSE) {
-+        return setError(EGL_BAD_PARAMETER, EGL_FALSE);
-+    }
-+
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglQueryAPI) {
-+        return cnx->egl.eglQueryAPI();
-+    }
-+
-+    // or, it can only be OpenGL ES
-+    return EGL_OPENGL_ES_API;
-+}
-+
-+EGLBoolean eglReleaseThread(void)
-+{
-+    clearError();
-+
-+    // If there is context bound to the thread, release it
-+    egl_display_t::loseCurrent(get_context(getContext()));
-+
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglReleaseThread) {
-+        cnx->egl.eglReleaseThread();
-+    }
-+    egl_tls_t::clearTLS();
-+    return EGL_TRUE;
-+}
-+
-+EGLSurface eglCreatePbufferFromClientBuffer(
-+          EGLDisplay dpy, EGLenum buftype, EGLClientBuffer buffer,
-+          EGLConfig config, const EGLint *attrib_list)
-+{
-+    clearError();
-+
-+    egl_connection_t* cnx = NULL;
-+    const egl_display_ptr dp = validate_display_connection(dpy, cnx);
-+    if (!dp) return EGL_FALSE;
-+    if (cnx->egl.eglCreatePbufferFromClientBuffer) {
-+        return cnx->egl.eglCreatePbufferFromClientBuffer(
-+                dp->disp.dpy, buftype, buffer, config, attrib_list);
-+    }
-+    return setError(EGL_BAD_CONFIG, EGL_NO_SURFACE);
-+}
-+
-+// ----------------------------------------------------------------------------
-+// EGL_EGLEXT_VERSION 3
-+// ----------------------------------------------------------------------------
-+
-+EGLBoolean eglLockSurfaceKHR(EGLDisplay dpy, EGLSurface surface,
-+        const EGLint *attrib_list)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    SurfaceRef _s(dp.get(), surface);
-+    if (!_s.get())
-+        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-+
-+    egl_surface_t const * const s = get_surface(surface);
-+    if (s->cnx->egl.eglLockSurfaceKHR) {
-+        return s->cnx->egl.eglLockSurfaceKHR(
-+                dp->disp.dpy, s->surface, attrib_list);
-+    }
-+    return setError(EGL_BAD_DISPLAY, EGL_FALSE);
-+}
-+
-+EGLBoolean eglUnlockSurfaceKHR(EGLDisplay dpy, EGLSurface surface)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    SurfaceRef _s(dp.get(), surface);
-+    if (!_s.get())
-+        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-+
-+    egl_surface_t const * const s = get_surface(surface);
-+    if (s->cnx->egl.eglUnlockSurfaceKHR) {
-+        return s->cnx->egl.eglUnlockSurfaceKHR(dp->disp.dpy, s->surface);
-+    }
-+    return setError(EGL_BAD_DISPLAY, EGL_FALSE);
-+}
-+
-+EGLImageKHR eglCreateImageKHR(EGLDisplay dpy, EGLContext ctx, EGLenum target,
-+        EGLClientBuffer buffer, const EGLint *attrib_list)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_NO_IMAGE_KHR;
-+
-+    ContextRef _c(dp.get(), ctx);
-+    egl_context_t * const c = _c.get();
-+
-+    EGLImageKHR result = EGL_NO_IMAGE_KHR;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglCreateImageKHR) {
-+        result = cnx->egl.eglCreateImageKHR(
-+                dp->disp.dpy,
-+                c ? c->context : EGL_NO_CONTEXT,
-+                target, buffer, attrib_list);
-+    }
-+    return result;
-+}
-+
-+EGLBoolean eglDestroyImageKHR(EGLDisplay dpy, EGLImageKHR img)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    EGLBoolean result = EGL_FALSE;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglDestroyImageKHR) {
-+        result = cnx->egl.eglDestroyImageKHR(dp->disp.dpy, img);
-+    }
-+    return result;
-+}
-+
-+// ----------------------------------------------------------------------------
-+// EGL_EGLEXT_VERSION 5
-+// ----------------------------------------------------------------------------
-+
-+
-+EGLSyncKHR eglCreateSyncKHR(EGLDisplay dpy, EGLenum type, const EGLint *attrib_list)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_NO_SYNC_KHR;
-+
-+    EGLSyncKHR result = EGL_NO_SYNC_KHR;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglCreateSyncKHR) {
-+        result = cnx->egl.eglCreateSyncKHR(dp->disp.dpy, type, attrib_list);
-+    }
-+    return result;
-+}
-+
-+EGLBoolean eglDestroySyncKHR(EGLDisplay dpy, EGLSyncKHR sync)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    EGLBoolean result = EGL_FALSE;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglDestroySyncKHR) {
-+        result = cnx->egl.eglDestroySyncKHR(dp->disp.dpy, sync);
-+    }
-+    return result;
-+}
-+
-+EGLBoolean eglSignalSyncKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLenum mode) {
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    EGLBoolean result = EGL_FALSE;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglSignalSyncKHR) {
-+        result = cnx->egl.eglSignalSyncKHR(
-+                dp->disp.dpy, sync, mode);
-+    }
-+    return result;
-+}
-+
-+EGLint eglClientWaitSyncKHR(EGLDisplay dpy, EGLSyncKHR sync,
-+        EGLint flags, EGLTimeKHR timeout)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    EGLBoolean result = EGL_FALSE;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglClientWaitSyncKHR) {
-+        result = cnx->egl.eglClientWaitSyncKHR(
-+                dp->disp.dpy, sync, flags, timeout);
-+    }
-+    return result;
-+}
-+
-+EGLBoolean eglGetSyncAttribKHR(EGLDisplay dpy, EGLSyncKHR sync,
-+        EGLint attribute, EGLint *value)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    EGLBoolean result = EGL_FALSE;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglGetSyncAttribKHR) {
-+        result = cnx->egl.eglGetSyncAttribKHR(
-+                dp->disp.dpy, sync, attribute, value);
-+    }
-+    return result;
-+}
-+
-+EGLStreamKHR eglCreateStreamKHR(EGLDisplay dpy, const EGLint *attrib_list)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_NO_STREAM_KHR;
-+
-+    EGLStreamKHR result = EGL_NO_STREAM_KHR;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglCreateStreamKHR) {
-+        result = cnx->egl.eglCreateStreamKHR(
-+                dp->disp.dpy, attrib_list);
-+    }
-+    return result;
-+}
-+
-+EGLBoolean eglDestroyStreamKHR(EGLDisplay dpy, EGLStreamKHR stream)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    EGLBoolean result = EGL_FALSE;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglDestroyStreamKHR) {
-+        result = cnx->egl.eglDestroyStreamKHR(
-+                dp->disp.dpy, stream);
-+    }
-+    return result;
-+}
-+
-+EGLBoolean eglStreamAttribKHR(EGLDisplay dpy, EGLStreamKHR stream,
-+        EGLenum attribute, EGLint value)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    EGLBoolean result = EGL_FALSE;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglStreamAttribKHR) {
-+        result = cnx->egl.eglStreamAttribKHR(
-+                dp->disp.dpy, stream, attribute, value);
-+    }
-+    return result;
-+}
-+
-+EGLBoolean eglQueryStreamKHR(EGLDisplay dpy, EGLStreamKHR stream,
-+        EGLenum attribute, EGLint *value)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    EGLBoolean result = EGL_FALSE;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglQueryStreamKHR) {
-+        result = cnx->egl.eglQueryStreamKHR(
-+                dp->disp.dpy, stream, attribute, value);
-+    }
-+    return result;
-+}
-+
-+EGLBoolean eglQueryStreamu64KHR(EGLDisplay dpy, EGLStreamKHR stream,
-+        EGLenum attribute, EGLuint64KHR *value)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    EGLBoolean result = EGL_FALSE;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglQueryStreamu64KHR) {
-+        result = cnx->egl.eglQueryStreamu64KHR(
-+                dp->disp.dpy, stream, attribute, value);
-+    }
-+    return result;
-+}
-+
-+EGLBoolean eglQueryStreamTimeKHR(EGLDisplay dpy, EGLStreamKHR stream,
-+        EGLenum attribute, EGLTimeKHR *value)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    EGLBoolean result = EGL_FALSE;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglQueryStreamTimeKHR) {
-+        result = cnx->egl.eglQueryStreamTimeKHR(
-+                dp->disp.dpy, stream, attribute, value);
-+    }
-+    return result;
-+}
-+
-+EGLSurface eglCreateStreamProducerSurfaceKHR(EGLDisplay dpy, EGLConfig config,
-+        EGLStreamKHR stream, const EGLint *attrib_list)
-+{
-+    clearError();
-+
-+    egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_NO_SURFACE;
-+
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglCreateStreamProducerSurfaceKHR) {
-+        EGLSurface surface = cnx->egl.eglCreateStreamProducerSurfaceKHR(
-+                dp->disp.dpy, config, stream, attrib_list);
-+        if (surface != EGL_NO_SURFACE) {
-+            egl_surface_t* s = new egl_surface_t(dp.get(), config, NULL,
-+                    surface, cnx);
-+            return s;
-+        }
-+    }
-+    return EGL_NO_SURFACE;
-+}
-+
-+EGLBoolean eglStreamConsumerGLTextureExternalKHR(EGLDisplay dpy,
-+        EGLStreamKHR stream)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    EGLBoolean result = EGL_FALSE;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglStreamConsumerGLTextureExternalKHR) {
-+        result = cnx->egl.eglStreamConsumerGLTextureExternalKHR(
-+                dp->disp.dpy, stream);
-+    }
-+    return result;
-+}
-+
-+EGLBoolean eglStreamConsumerAcquireKHR(EGLDisplay dpy,
-+        EGLStreamKHR stream)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    EGLBoolean result = EGL_FALSE;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglStreamConsumerAcquireKHR) {
-+        result = cnx->egl.eglStreamConsumerAcquireKHR(
-+                dp->disp.dpy, stream);
-+    }
-+    return result;
-+}
-+
-+EGLBoolean eglStreamConsumerReleaseKHR(EGLDisplay dpy,
-+        EGLStreamKHR stream)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+
-+    EGLBoolean result = EGL_FALSE;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglStreamConsumerReleaseKHR) {
-+        result = cnx->egl.eglStreamConsumerReleaseKHR(
-+                dp->disp.dpy, stream);
-+    }
-+    return result;
-+}
-+
-+EGLNativeFileDescriptorKHR eglGetStreamFileDescriptorKHR(
-+        EGLDisplay dpy, EGLStreamKHR stream)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_NO_FILE_DESCRIPTOR_KHR;
-+
-+    EGLNativeFileDescriptorKHR result = EGL_NO_FILE_DESCRIPTOR_KHR;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglGetStreamFileDescriptorKHR) {
-+        result = cnx->egl.eglGetStreamFileDescriptorKHR(
-+                dp->disp.dpy, stream);
-+    }
-+    return result;
-+}
-+
-+EGLStreamKHR eglCreateStreamFromFileDescriptorKHR(
-+        EGLDisplay dpy, EGLNativeFileDescriptorKHR file_descriptor)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_NO_STREAM_KHR;
-+
-+    EGLStreamKHR result = EGL_NO_STREAM_KHR;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglCreateStreamFromFileDescriptorKHR) {
-+        result = cnx->egl.eglCreateStreamFromFileDescriptorKHR(
-+                dp->disp.dpy, file_descriptor);
-+    }
-+    return result;
-+}
-+
-+// ----------------------------------------------------------------------------
-+// EGL_EGLEXT_VERSION 15
-+// ----------------------------------------------------------------------------
-+
-+EGLint eglWaitSyncKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLint flags) {
-+    clearError();
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_FALSE;
-+    EGLint result = EGL_FALSE;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglWaitSyncKHR) {
-+        result = cnx->egl.eglWaitSyncKHR(dp->disp.dpy, sync, flags);
-+    }
-+    return result;
-+}
-+
-+// ----------------------------------------------------------------------------
-+// ANDROID extensions
-+// ----------------------------------------------------------------------------
-+
-+EGLint eglDupNativeFenceFDANDROID(EGLDisplay dpy, EGLSyncKHR sync)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) return EGL_NO_NATIVE_FENCE_FD_ANDROID;
-+
-+    EGLint result = EGL_NO_NATIVE_FENCE_FD_ANDROID;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+    if (cnx->dso && cnx->egl.eglDupNativeFenceFDANDROID) {
-+        result = cnx->egl.eglDupNativeFenceFDANDROID(dp->disp.dpy, sync);
-+    }
-+    return result;
-+}
-+
-+EGLBoolean eglPresentationTimeANDROID(EGLDisplay dpy, EGLSurface surface,
-+        EGLnsecsANDROID time)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) {
-+        return EGL_FALSE;
-+    }
-+
-+    SurfaceRef _s(dp.get(), surface);
-+    if (!_s.get()) {
-+        setError(EGL_BAD_SURFACE, EGL_FALSE);
-+        return EGL_FALSE;
-+    }
-+
-+    egl_surface_t const * const s = get_surface(surface);
-+    native_window_set_buffers_timestamp(s->win.get(), time);
-+
-+    return EGL_TRUE;
-+}
-+
-+EGLClientBuffer eglCreateNativeClientBufferANDROID(const EGLint *attrib_list)
-+{
-+    clearError();
-+
-+    int usage = 0;
-+    uint32_t width = 0;
-+    uint32_t height = 0;
-+    uint32_t format = 0;
-+    uint32_t red_size = 0;
-+    uint32_t green_size = 0;
-+    uint32_t blue_size = 0;
-+    uint32_t alpha_size = 0;
-+
-+#define GET_NONNEGATIVE_VALUE(case_name, target) \
-+    case case_name: \
-+        if (value >= 0) { \
-+            target = value; \
-+        } else { \
-+            return setError(EGL_BAD_PARAMETER, (EGLClientBuffer)0); \
-+        } \
-+        break
-+
-+    if (attrib_list) {
-+        while (*attrib_list != EGL_NONE) {
-+            GLint attr = *attrib_list++;
-+            GLint value = *attrib_list++;
-+            switch (attr) {
-+                GET_NONNEGATIVE_VALUE(EGL_WIDTH, width);
-+                GET_NONNEGATIVE_VALUE(EGL_HEIGHT, height);
-+                GET_NONNEGATIVE_VALUE(EGL_RED_SIZE, red_size);
-+                GET_NONNEGATIVE_VALUE(EGL_GREEN_SIZE, green_size);
-+                GET_NONNEGATIVE_VALUE(EGL_BLUE_SIZE, blue_size);
-+                GET_NONNEGATIVE_VALUE(EGL_ALPHA_SIZE, alpha_size);
-+                case EGL_NATIVE_BUFFER_USAGE_ANDROID:
-+                    if (value & EGL_NATIVE_BUFFER_USAGE_PROTECTED_BIT_ANDROID) {
-+                        usage |= GRALLOC_USAGE_PROTECTED;
-+                    }
-+                    if (value & EGL_NATIVE_BUFFER_USAGE_RENDERBUFFER_BIT_ANDROID) {
-+                        usage |= GRALLOC_USAGE_HW_RENDER;
-+                    }
-+                    if (value & EGL_NATIVE_BUFFER_USAGE_TEXTURE_BIT_ANDROID) {
-+                        usage |= GRALLOC_USAGE_HW_TEXTURE;
-+                    }
-+                    break;
-+                default:
-+                    return setError(EGL_BAD_PARAMETER, (EGLClientBuffer)0);
-+            }
-+        }
-+    }
-+#undef GET_NONNEGATIVE_VALUE
-+
-+    // Validate format.
-+    if (red_size == 8 && green_size == 8 && blue_size == 8) {
-+        if (alpha_size == 8) {
-+            format = HAL_PIXEL_FORMAT_RGBA_8888;
-+        } else {
-+            format = HAL_PIXEL_FORMAT_RGB_888;
-+        }
-+    } else if (red_size == 5 && green_size == 6 && blue_size == 5 &&
-+               alpha_size == 0) {
-+        format = HAL_PIXEL_FORMAT_RGB_565;
-+    } else {
-+        ALOGE("Invalid native pixel format { r=%d, g=%d, b=%d, a=%d }",
-+                red_size, green_size, blue_size, alpha_size);
-+        return setError(EGL_BAD_PARAMETER, (EGLClientBuffer)0);
-+    }
-+
-+#define CHECK_ERROR_CONDITION(message) \
-+    if (err != NO_ERROR) { \
-+        ALOGE(message); \
-+        goto error_condition; \
-+    }
-+
-+    // The holder is used to destroy the buffer if an error occurs.
-+    GraphicBuffer* gBuffer = new GraphicBuffer();
-+    sp<IServiceManager> sm = defaultServiceManager();
-+    sp<IBinder> surfaceFlinger = sm->getService(String16("SurfaceFlinger"));
-+    sp<IBinder> allocator;
-+    Parcel sc_data, sc_reply, data, reply;
-+    status_t err = NO_ERROR;
-+    if (sm == NULL) {
-+        ALOGE("Unable to connect to ServiceManager");
-+        goto error_condition;
-+    }
-+
-+    // Obtain an allocator.
-+    if (surfaceFlinger == NULL) {
-+        ALOGE("Unable to connect to SurfaceFlinger");
-+        goto error_condition;
-+    }
-+    sc_data.writeInterfaceToken(String16("android.ui.ISurfaceComposer"));
-+    err = surfaceFlinger->transact(
-+            BnSurfaceComposer::CREATE_GRAPHIC_BUFFER_ALLOC, sc_data, &sc_reply);
-+    CHECK_ERROR_CONDITION("Unable to obtain allocator from SurfaceFlinger");
-+    allocator = sc_reply.readStrongBinder();
-+
-+    if (allocator == NULL) {
-+        ALOGE("Unable to obtain an ISurfaceComposer");
-+        goto error_condition;
-+    }
-+    data.writeInterfaceToken(String16("android.ui.IGraphicBufferAlloc"));
-+    err = data.writeUint32(width);
-+    CHECK_ERROR_CONDITION("Unable to write width");
-+    err = data.writeUint32(height);
-+    CHECK_ERROR_CONDITION("Unable to write height");
-+    err = data.writeInt32(static_cast<int32_t>(format));
-+    CHECK_ERROR_CONDITION("Unable to write format");
-+    err = data.writeUint32(usage);
-+    CHECK_ERROR_CONDITION("Unable to write usage");
-+    err = data.writeUtf8AsUtf16(
-+            std::string("[eglCreateNativeClientBufferANDROID pid ") +
-+            std::to_string(getpid()) + ']');
-+    CHECK_ERROR_CONDITION("Unable to write requestor name");
-+    err = allocator->transact(IBinder::FIRST_CALL_TRANSACTION, data,
-+            &reply);
-+    CHECK_ERROR_CONDITION(
-+            "Unable to request buffer allocation from surface composer");
-+    err = reply.readInt32();
-+    CHECK_ERROR_CONDITION("Unable to obtain buffer from surface composer");
-+    err = reply.read(*gBuffer);
-+    CHECK_ERROR_CONDITION("Unable to read buffer from surface composer");
-+
-+    err = gBuffer->initCheck();
-+    if (err != NO_ERROR) {
-+        ALOGE("Unable to create native buffer { w=%d, h=%d, f=%d, u=%#x }: %#x",
-+                width, height, format, usage, err);
-+        goto error_condition;
-+    }
-+    ALOGD("Created new native buffer %p { w=%d, h=%d, f=%d, u=%#x }",
-+            gBuffer, width, height, format, usage);
-+    return static_cast<EGLClientBuffer>(gBuffer->getNativeBuffer());
-+
-+#undef CHECK_ERROR_CONDITION
-+
-+error_condition:
-+    // Delete the buffer.
-+    sp<GraphicBuffer> holder(gBuffer);
-+    return setError(EGL_BAD_ALLOC, (EGLClientBuffer)0);
-+}
-+
-+// ----------------------------------------------------------------------------
-+// NVIDIA extensions
-+// ----------------------------------------------------------------------------
-+EGLuint64NV eglGetSystemTimeFrequencyNV()
-+{
-+    clearError();
-+
-+    if (egl_init_drivers() == EGL_FALSE) {
-+        return setError(EGL_BAD_PARAMETER, EGL_FALSE);
-+    }
-+
-+    EGLuint64NV ret = 0;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+
-+    if (cnx->dso && cnx->egl.eglGetSystemTimeFrequencyNV) {
-+        return cnx->egl.eglGetSystemTimeFrequencyNV();
-+    }
-+
-+    return setErrorQuiet(EGL_BAD_DISPLAY, 0);
-+}
-+
-+EGLuint64NV eglGetSystemTimeNV()
-+{
-+    clearError();
-+
-+    if (egl_init_drivers() == EGL_FALSE) {
-+        return setError(EGL_BAD_PARAMETER, EGL_FALSE);
-+    }
-+
-+    EGLuint64NV ret = 0;
-+    egl_connection_t* const cnx = &gEGLImpl;
-+
-+    if (cnx->dso && cnx->egl.eglGetSystemTimeNV) {
-+        return cnx->egl.eglGetSystemTimeNV();
-+    }
-+
-+    return setErrorQuiet(EGL_BAD_DISPLAY, 0);
-+}
-+
-+// ----------------------------------------------------------------------------
-+// Partial update extension
-+// ----------------------------------------------------------------------------
-+EGLBoolean eglSetDamageRegionKHR(EGLDisplay dpy, EGLSurface surface,
-+        EGLint *rects, EGLint n_rects)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) {
-+        setError(EGL_BAD_DISPLAY, EGL_FALSE);
-+        return EGL_FALSE;
-+    }
-+
-+    SurfaceRef _s(dp.get(), surface);
-+    if (!_s.get()) {
-+        setError(EGL_BAD_SURFACE, EGL_FALSE);
-+        return EGL_FALSE;
-+    }
-+
-+    egl_surface_t const * const s = get_surface(surface);
-+    if (s->cnx->egl.eglSetDamageRegionKHR) {
-+        return s->cnx->egl.eglSetDamageRegionKHR(dp->disp.dpy, s->surface,
-+                rects, n_rects);
-+    }
-+
-+    return EGL_FALSE;
-+}
-+
-+EGLBoolean eglGetFrameTimestampsANDROID(EGLDisplay dpy, EGLSurface surface,
-+        EGLint framesAgo, EGLint numTimestamps, const EGLint *timestamps,
-+        EGLnsecsANDROID *values)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) {
-+        setError(EGL_BAD_DISPLAY, EGL_FALSE);
-+        return EGL_FALSE;
-+    }
-+
-+    SurfaceRef _s(dp.get(), surface);
-+    if (!_s.get()) {
-+        setError(EGL_BAD_SURFACE, EGL_FALSE);
-+        return EGL_FALSE;
-+    }
-+
-+    egl_surface_t const * const s = get_surface(surface);
-+
-+    if (!s->enableTimestamps) {
-+        setError(EGL_BAD_SURFACE, EGL_FALSE);
-+        return EGL_FALSE;
-+    }
-+
-+    nsecs_t* postedTime = nullptr;
-+    nsecs_t* acquireTime = nullptr;
-+    nsecs_t* refreshStartTime = nullptr;
-+    nsecs_t* GLCompositionDoneTime = nullptr;
-+    nsecs_t* displayRetireTime = nullptr;
-+    nsecs_t* releaseTime = nullptr;
-+
-+    for (int i = 0; i < numTimestamps; i++) {
-+        switch (timestamps[i]) {
-+            case EGL_QUEUE_TIME_ANDROID:
-+                postedTime = &values[i];
-+                break;
-+            case EGL_RENDERING_COMPLETE_TIME_ANDROID:
-+                acquireTime = &values[i];
-+                break;
-+            case EGL_COMPOSITION_START_TIME_ANDROID:
-+                refreshStartTime = &values[i];
-+                break;
-+            case EGL_COMPOSITION_FINISHED_TIME_ANDROID:
-+                GLCompositionDoneTime = &values[i];
-+                break;
-+            case EGL_DISPLAY_RETIRE_TIME_ANDROID:
-+                displayRetireTime = &values[i];
-+                break;
-+            case EGL_READS_DONE_TIME_ANDROID:
-+                releaseTime = &values[i];
-+                break;
-+            default:
-+                setError(EGL_BAD_PARAMETER, EGL_FALSE);
-+                return EGL_FALSE;
-+        }
-+    }
-+
-+    status_t ret = native_window_get_frame_timestamps(s->win.get(), framesAgo,
-+            postedTime, acquireTime, refreshStartTime, GLCompositionDoneTime,
-+            displayRetireTime, releaseTime);
-+
-+    if (ret != NO_ERROR) {
-+        setError(EGL_BAD_ACCESS, EGL_FALSE);
-+        return EGL_FALSE;
-+    }
-+
-+    return EGL_TRUE;
-+}
-+
-+EGLBoolean eglQueryTimestampSupportedANDROID(EGLDisplay dpy, EGLSurface surface,
-+        EGLint timestamp)
-+{
-+    clearError();
-+
-+    const egl_display_ptr dp = validate_display(dpy);
-+    if (!dp) {
-+        setError(EGL_BAD_DISPLAY, EGL_FALSE);
-+        return EGL_FALSE;
-+    }
-+
-+    SurfaceRef _s(dp.get(), surface);
-+    if (!_s.get()) {
-+        setError(EGL_BAD_SURFACE, EGL_FALSE);
-+        return EGL_FALSE;
-+    }
-+
-+    switch (timestamp) {
-+#if ENABLE_EGL_ANDROID_GET_FRAME_TIMESTAMPS
-+        case EGL_QUEUE_TIME_ANDROID:
-+        case EGL_RENDERING_COMPLETE_TIME_ANDROID:
-+        case EGL_COMPOSITION_START_TIME_ANDROID:
-+        case EGL_COMPOSITION_FINISHED_TIME_ANDROID:
-+        case EGL_DISPLAY_RETIRE_TIME_ANDROID:
-+        case EGL_READS_DONE_TIME_ANDROID:
-+            return EGL_TRUE;
-+#endif
-+        default:
-+            return EGL_FALSE;
-+    }
-+}
diff -Naur frameworksRaw/native/opengl/libs/EGL/eglApi.cpp.orig.rej.rej frameworksModified/native/opengl/libs/EGL/eglApi.cpp.orig.rej.rej
--- frameworksRaw/native/opengl/libs/EGL/eglApi.cpp.orig.rej.rej	2017-07-06 15:34:21.314456285 +0530
+++ frameworksModified/native/opengl/libs/EGL/eglApi.cpp.orig.rej.rej	1970-01-01 05:30:00.000000000 +0530
@@ -1,2123 +0,0 @@
---- native/opengl/libs/EGL/eglApi.cpp.orig.rej	1970-01-01 05:30:00.000000000 +0530
-+++ native/opengl/libs/EGL/eglApi.cpp.orig.rej	2017-07-06 13:50:15.191676414 +0530
-@@ -0,0 +1,2120 @@
-+--- native/opengl/libs/EGL/eglApi.cpp.orig	1970-01-01 05:30:00.000000000 +0530
-++++ native/opengl/libs/EGL/eglApi.cpp.orig	2017-07-05 18:25:26.600577787 +0530
-+@@ -0,0 +1,2117 @@
-++/*
-++ ** Copyright 2007, The Android Open Source Project
-++ **
-++ ** Licensed under the Apache License, Version 2.0 (the "License");
-++ ** you may not use this file except in compliance with the License.
-++ ** You may obtain a copy of the License at
-++ **
-++ **     http://www.apache.org/licenses/LICENSE-2.0
-++ **
-++ ** Unless required by applicable law or agreed to in writing, software
-++ ** distributed under the License is distributed on an "AS IS" BASIS,
-++ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-++ ** See the License for the specific language governing permissions and
-++ ** limitations under the License.
-++ */
-++
-++#define ATRACE_TAG ATRACE_TAG_GRAPHICS
-++
-++#include <dlfcn.h>
-++#include <ctype.h>
-++#include <stdlib.h>
-++#include <string.h>
-++
-++#include <hardware/gralloc.h>
-++#include <system/window.h>
-++
-++#include <EGL/egl.h>
-++#include <EGL/eglext.h>
-++
-++#include <cutils/log.h>
-++#include <cutils/atomic.h>
-++#include <cutils/compiler.h>
-++#include <cutils/properties.h>
-++#include <cutils/memory.h>
-++
-++#include <gui/ISurfaceComposer.h>
-++
-++#include <ui/GraphicBuffer.h>
-++
-++#include <utils/KeyedVector.h>
-++#include <utils/SortedVector.h>
-++#include <utils/String8.h>
-++#include <utils/Trace.h>
-++
-++#include "binder/Binder.h"
-++#include "binder/Parcel.h"
-++#include "binder/IServiceManager.h"
-++
-++#include "../egl_impl.h"
-++#include "../hooks.h"
-++
-++#include "egl_display.h"
-++#include "egl_object.h"
-++#include "egl_tls.h"
-++#include "egldefs.h"
-++
-++using namespace android;
-++
-++// This extension has not been ratified yet, so can't be shipped.
-++// Implementation is incomplete and untested.
-++#define ENABLE_EGL_KHR_GL_COLORSPACE 0
-++
-++#define ENABLE_EGL_ANDROID_GET_FRAME_TIMESTAMPS 0
-++
-++// ----------------------------------------------------------------------------
-++
-++namespace android {
-++
-++struct extention_map_t {
-++    const char* name;
-++    __eglMustCastToProperFunctionPointerType address;
-++};
-++
-++/*
-++ * This is the list of EGL extensions exposed to applications.
-++ *
-++ * Some of them (gBuiltinExtensionString) are implemented entirely in this EGL
-++ * wrapper and are always available.
-++ *
-++ * The rest (gExtensionString) depend on support in the EGL driver, and are
-++ * only available if the driver supports them. However, some of these must be
-++ * supported because they are used by the Android system itself; these are
-++ * listed as mandatory below and are required by the CDD. The system *assumes*
-++ * the mandatory extensions are present and may not function properly if some
-++ * are missing.
-++ *
-++ * NOTE: Both strings MUST have a single space as the last character.
-++ */
-++extern char const * const gBuiltinExtensionString =
-++        "EGL_KHR_get_all_proc_addresses "
-++        "EGL_ANDROID_presentation_time "
-++        "EGL_KHR_swap_buffers_with_damage "
-++        "EGL_ANDROID_create_native_client_buffer "
-++        "EGL_ANDROID_front_buffer_auto_refresh "
-++#if ENABLE_EGL_ANDROID_GET_FRAME_TIMESTAMPS
-++        "EGL_ANDROID_get_frame_timestamps "
-++#endif
-++        ;
-++extern char const * const gExtensionString  =
-++        "EGL_KHR_image "                        // mandatory
-++        "EGL_KHR_image_base "                   // mandatory
-++        "EGL_KHR_image_pixmap "
-++        "EGL_KHR_lock_surface "
-++#if (ENABLE_EGL_KHR_GL_COLORSPACE != 0)
-++        "EGL_KHR_gl_colorspace "
-++#endif
-++        "EGL_KHR_gl_texture_2D_image "
-++        "EGL_KHR_gl_texture_3D_image "
-++        "EGL_KHR_gl_texture_cubemap_image "
-++        "EGL_KHR_gl_renderbuffer_image "
-++        "EGL_KHR_reusable_sync "
-++        "EGL_KHR_fence_sync "
-++        "EGL_KHR_create_context "
-++        "EGL_KHR_config_attribs "
-++        "EGL_KHR_surfaceless_context "
-++        "EGL_KHR_stream "
-++        "EGL_KHR_stream_fifo "
-++        "EGL_KHR_stream_producer_eglsurface "
-++        "EGL_KHR_stream_consumer_gltexture "
-++        "EGL_KHR_stream_cross_process_fd "
-++        "EGL_EXT_create_context_robustness "
-++        "EGL_NV_system_time "
-++        "EGL_ANDROID_image_native_buffer "      // mandatory
-++        "EGL_KHR_wait_sync "                    // strongly recommended
-++        "EGL_ANDROID_recordable "               // mandatory
-++        "EGL_KHR_partial_update "               // strongly recommended
-++        "EGL_EXT_buffer_age "                   // strongly recommended with partial_update
-++        "EGL_KHR_create_context_no_error "
-++        "EGL_KHR_mutable_render_buffer "
-++        "EGL_EXT_yuv_surface "
-++        "EGL_EXT_protected_content "
-++        ;
-++
-++// extensions not exposed to applications but used by the ANDROID system
-++//      "EGL_ANDROID_blob_cache "               // strongly recommended
-++//      "EGL_IMG_hibernate_process "            // optional
-++//      "EGL_ANDROID_native_fence_sync "        // strongly recommended
-++//      "EGL_ANDROID_framebuffer_target "       // mandatory for HWC 1.1
-++//      "EGL_ANDROID_image_crop "               // optional
-++
-++/*
-++ * EGL Extensions entry-points exposed to 3rd party applications
-++ * (keep in sync with gExtensionString above)
-++ *
-++ */
-++static const extention_map_t sExtensionMap[] = {
-++    // EGL_KHR_lock_surface
-++    { "eglLockSurfaceKHR",
-++            (__eglMustCastToProperFunctionPointerType)&eglLockSurfaceKHR },
-++    { "eglUnlockSurfaceKHR",
-++            (__eglMustCastToProperFunctionPointerType)&eglUnlockSurfaceKHR },
-++
-++    // EGL_KHR_image, EGL_KHR_image_base
-++    { "eglCreateImageKHR",
-++            (__eglMustCastToProperFunctionPointerType)&eglCreateImageKHR },
-++    { "eglDestroyImageKHR",
-++            (__eglMustCastToProperFunctionPointerType)&eglDestroyImageKHR },
-++
-++    // EGL_KHR_reusable_sync, EGL_KHR_fence_sync
-++    { "eglCreateSyncKHR",
-++            (__eglMustCastToProperFunctionPointerType)&eglCreateSyncKHR },
-++    { "eglDestroySyncKHR",
-++            (__eglMustCastToProperFunctionPointerType)&eglDestroySyncKHR },
-++    { "eglClientWaitSyncKHR",
-++            (__eglMustCastToProperFunctionPointerType)&eglClientWaitSyncKHR },
-++    { "eglSignalSyncKHR",
-++            (__eglMustCastToProperFunctionPointerType)&eglSignalSyncKHR },
-++    { "eglGetSyncAttribKHR",
-++            (__eglMustCastToProperFunctionPointerType)&eglGetSyncAttribKHR },
-++
-++    // EGL_NV_system_time
-++    { "eglGetSystemTimeFrequencyNV",
-++            (__eglMustCastToProperFunctionPointerType)&eglGetSystemTimeFrequencyNV },
-++    { "eglGetSystemTimeNV",
-++            (__eglMustCastToProperFunctionPointerType)&eglGetSystemTimeNV },
-++
-++    // EGL_KHR_wait_sync
-++    { "eglWaitSyncKHR",
-++            (__eglMustCastToProperFunctionPointerType)&eglWaitSyncKHR },
-++
-++    // EGL_ANDROID_presentation_time
-++    { "eglPresentationTimeANDROID",
-++            (__eglMustCastToProperFunctionPointerType)&eglPresentationTimeANDROID },
-++
-++    // EGL_KHR_swap_buffers_with_damage
-++    { "eglSwapBuffersWithDamageKHR",
-++            (__eglMustCastToProperFunctionPointerType)&eglSwapBuffersWithDamageKHR },
-++
-++    // EGL_ANDROID_native_client_buffer
-++    { "eglCreateNativeClientBufferANDROID",
-++            (__eglMustCastToProperFunctionPointerType)&eglCreateNativeClientBufferANDROID },
-++
-++    // EGL_KHR_partial_update
-++    { "eglSetDamageRegionKHR",
-++            (__eglMustCastToProperFunctionPointerType)&eglSetDamageRegionKHR },
-++
-++    { "eglCreateStreamKHR",
-++            (__eglMustCastToProperFunctionPointerType)&eglCreateStreamKHR },
-++    { "eglDestroyStreamKHR",
-++            (__eglMustCastToProperFunctionPointerType)&eglDestroyStreamKHR },
-++    { "eglStreamAttribKHR",
-++            (__eglMustCastToProperFunctionPointerType)&eglStreamAttribKHR },
-++    { "eglQueryStreamKHR",
-++            (__eglMustCastToProperFunctionPointerType)&eglQueryStreamKHR },
-++    { "eglQueryStreamu64KHR",
-++            (__eglMustCastToProperFunctionPointerType)&eglQueryStreamu64KHR },
-++    { "eglQueryStreamTimeKHR",
-++            (__eglMustCastToProperFunctionPointerType)&eglQueryStreamTimeKHR },
-++    { "eglCreateStreamProducerSurfaceKHR",
-++            (__eglMustCastToProperFunctionPointerType)&eglCreateStreamProducerSurfaceKHR },
-++    { "eglStreamConsumerGLTextureExternalKHR",
-++            (__eglMustCastToProperFunctionPointerType)&eglStreamConsumerGLTextureExternalKHR },
-++    { "eglStreamConsumerAcquireKHR",
-++            (__eglMustCastToProperFunctionPointerType)&eglStreamConsumerAcquireKHR },
-++    { "eglStreamConsumerReleaseKHR",
-++            (__eglMustCastToProperFunctionPointerType)&eglStreamConsumerReleaseKHR },
-++    { "eglGetStreamFileDescriptorKHR",
-++            (__eglMustCastToProperFunctionPointerType)&eglGetStreamFileDescriptorKHR },
-++    { "eglCreateStreamFromFileDescriptorKHR",
-++            (__eglMustCastToProperFunctionPointerType)&eglCreateStreamFromFileDescriptorKHR },
-++
-++    // EGL_ANDROID_get_frame_timestamps
-++    { "eglGetFrameTimestampsANDROID",
-++            (__eglMustCastToProperFunctionPointerType)&eglGetFrameTimestampsANDROID },
-++    { "eglQueryTimestampSupportedANDROID",
-++            (__eglMustCastToProperFunctionPointerType)&eglQueryTimestampSupportedANDROID },
-++};
-++
-++/*
-++ * These extensions entry-points should not be exposed to applications.
-++ * They're used internally by the Android EGL layer.
-++ */
-++#define FILTER_EXTENSIONS(procname) \
-++        (!strcmp((procname), "eglSetBlobCacheFuncsANDROID") ||    \
-++         !strcmp((procname), "eglHibernateProcessIMG")      ||    \
-++         !strcmp((procname), "eglAwakenProcessIMG")         ||    \
-++         !strcmp((procname), "eglDupNativeFenceFDANDROID"))
-++
-++
-++
-++// accesses protected by sExtensionMapMutex
-++static DefaultKeyedVector<String8, __eglMustCastToProperFunctionPointerType> sGLExtentionMap;
-++static int sGLExtentionSlot = 0;
-++static pthread_mutex_t sExtensionMapMutex = PTHREAD_MUTEX_INITIALIZER;
-++
-++static void(*findProcAddress(const char* name,
-++        const extention_map_t* map, size_t n))() {
-++    for (uint32_t i=0 ; i<n ; i++) {
-++        if (!strcmp(name, map[i].name)) {
-++            return map[i].address;
-++        }
-++    }
-++    return NULL;
-++}
-++
-++// ----------------------------------------------------------------------------
-++
-++extern void setGLHooksThreadSpecific(gl_hooks_t const *value);
-++extern EGLBoolean egl_init_drivers();
-++extern const __eglMustCastToProperFunctionPointerType gExtensionForwarders[MAX_NUMBER_OF_GL_EXTENSIONS];
-++extern gl_hooks_t gHooksTrace;
-++
-++} // namespace android;
-++
-++
-++// ----------------------------------------------------------------------------
-++
-++static inline void clearError() { egl_tls_t::clearError(); }
-++static inline EGLContext getContext() { return egl_tls_t::getContext(); }
-++
-++// ----------------------------------------------------------------------------
-++
-++EGLDisplay eglGetDisplay(EGLNativeDisplayType display)
-++{
-++    ATRACE_CALL();
-++    clearError();
-++
-++    uintptr_t index = reinterpret_cast<uintptr_t>(display);
-++    if (index >= NUM_DISPLAYS) {
-++        return setError(EGL_BAD_PARAMETER, EGL_NO_DISPLAY);
-++    }
-++
-++    if (egl_init_drivers() == EGL_FALSE) {
-++        return setError(EGL_BAD_PARAMETER, EGL_NO_DISPLAY);
-++    }
-++
-++    EGLDisplay dpy = egl_display_t::getFromNativeDisplay(display);
-++    return dpy;
-++}
-++
-++// ----------------------------------------------------------------------------
-++// Initialization
-++// ----------------------------------------------------------------------------
-++
-++EGLBoolean eglInitialize(EGLDisplay dpy, EGLint *major, EGLint *minor)
-++{
-++    clearError();
-++
-++    egl_display_ptr dp = get_display(dpy);
-++    if (!dp) return setError(EGL_BAD_DISPLAY, EGL_FALSE);
-++
-++    EGLBoolean res = dp->initialize(major, minor);
-++
-++    return res;
-++}
-++
-++EGLBoolean eglTerminate(EGLDisplay dpy)
-++{
-++    // NOTE: don't unload the drivers b/c some APIs can be called
-++    // after eglTerminate() has been called. eglTerminate() only
-++    // terminates an EGLDisplay, not a EGL itself.
-++
-++    clearError();
-++
-++    egl_display_ptr dp = get_display(dpy);
-++    if (!dp) return setError(EGL_BAD_DISPLAY, EGL_FALSE);
-++
-++    EGLBoolean res = dp->terminate();
-++
-++    return res;
-++}
-++
-++// ----------------------------------------------------------------------------
-++// configuration
-++// ----------------------------------------------------------------------------
-++
-++EGLBoolean eglGetConfigs(   EGLDisplay dpy,
-++                            EGLConfig *configs,
-++                            EGLint config_size, EGLint *num_config)
-++{
-++    clearError();
-++
-++    const egl_display_ptr dp = validate_display(dpy);
-++    if (!dp) return EGL_FALSE;
-++
-++    if (num_config==0) {
-++        return setError(EGL_BAD_PARAMETER, EGL_FALSE);
-++    }
-++
-++    EGLBoolean res = EGL_FALSE;
-++    *num_config = 0;
-++
-++    egl_connection_t* const cnx = &gEGLImpl;
-++    if (cnx->dso) {
-++        res = cnx->egl.eglGetConfigs(
-++                dp->disp.dpy, configs, config_size, num_config);
-++    }
-++
-++    return res;
-++}
-++
-++EGLBoolean eglChooseConfig( EGLDisplay dpy, const EGLint *attrib_list,
-++                            EGLConfig *configs, EGLint config_size,
-++                            EGLint *num_config)
-++{
-++    clearError();
-++
-++    const egl_display_ptr dp = validate_display(dpy);
-++    if (!dp) return EGL_FALSE;
-++
-++    if (num_config==0) {
-++        return setError(EGL_BAD_PARAMETER, EGL_FALSE);
-++    }
-++
-++    EGLBoolean res = EGL_FALSE;
-++    *num_config = 0;
-++
-++    egl_connection_t* const cnx = &gEGLImpl;
-++    if (cnx->dso) {
-++        if (attrib_list) {
-++            char value[PROPERTY_VALUE_MAX];
-++            property_get("debug.egl.force_msaa", value, "false");
-++
-++            if (!strcmp(value, "true")) {
-++                size_t attribCount = 0;
-++                EGLint attrib = attrib_list[0];
-++
-++                // Only enable MSAA if the context is OpenGL ES 2.0 and
-++                // if no caveat is requested
-++                const EGLint *attribRendererable = NULL;
-++                const EGLint *attribCaveat = NULL;
-++
-++                // Count the number of attributes and look for
-++                // EGL_RENDERABLE_TYPE and EGL_CONFIG_CAVEAT
-++                while (attrib != EGL_NONE) {
-++                    attrib = attrib_list[attribCount];
-++                    switch (attrib) {
-++                        case EGL_RENDERABLE_TYPE:
-++                            attribRendererable = &attrib_list[attribCount];
-++                            break;
-++                        case EGL_CONFIG_CAVEAT:
-++                            attribCaveat = &attrib_list[attribCount];
-++                            break;
-++                    }
-++                    attribCount++;
-++                }
-++
-++                if (attribRendererable && attribRendererable[1] == EGL_OPENGL_ES2_BIT &&
-++                        (!attribCaveat || attribCaveat[1] != EGL_NONE)) {
-++
-++                    // Insert 2 extra attributes to force-enable MSAA 4x
-++                    EGLint aaAttribs[attribCount + 4];
-++                    aaAttribs[0] = EGL_SAMPLE_BUFFERS;
-++                    aaAttribs[1] = 1;
-++                    aaAttribs[2] = EGL_SAMPLES;
-++                    aaAttribs[3] = 4;
-++
-++                    memcpy(&aaAttribs[4], attrib_list, attribCount * sizeof(EGLint));
-++
-++                    EGLint numConfigAA;
-++                    EGLBoolean resAA = cnx->egl.eglChooseConfig(
-++                            dp->disp.dpy, aaAttribs, configs, config_size, &numConfigAA);
-++
-++                    if (resAA == EGL_TRUE && numConfigAA > 0) {
-++                        ALOGD("Enabling MSAA 4x");
-++                        *num_config = numConfigAA;
-++                        return resAA;
-++                    }
-++                }
-++            }
-++        }
-++
-++        res = cnx->egl.eglChooseConfig(
-++                dp->disp.dpy, attrib_list, configs, config_size, num_config);
-++    }
-++    return res;
-++}
-++
-++EGLBoolean eglGetConfigAttrib(EGLDisplay dpy, EGLConfig config,
-++        EGLint attribute, EGLint *value)
-++{
-++    clearError();
-++
-++    egl_connection_t* cnx = NULL;
-++    const egl_display_ptr dp = validate_display_connection(dpy, cnx);
-++    if (!dp) return EGL_FALSE;
-++
-++    return cnx->egl.eglGetConfigAttrib(
-++            dp->disp.dpy, config, attribute, value);
-++}
-++
-++// ----------------------------------------------------------------------------
-++// surfaces
-++// ----------------------------------------------------------------------------
-++
-++// The EGL_KHR_gl_colorspace spec hasn't been ratified yet, so these haven't
-++// been added to the Khronos egl.h.
-++#define EGL_GL_COLORSPACE_KHR           EGL_VG_COLORSPACE
-++#define EGL_GL_COLORSPACE_SRGB_KHR      EGL_VG_COLORSPACE_sRGB
-++#define EGL_GL_COLORSPACE_LINEAR_KHR    EGL_VG_COLORSPACE_LINEAR
-++
-++// Turn linear formats into corresponding sRGB formats when colorspace is
-++// EGL_GL_COLORSPACE_SRGB_KHR, or turn sRGB formats into corresponding linear
-++// formats when colorspace is EGL_GL_COLORSPACE_LINEAR_KHR. In any cases where
-++// the modification isn't possible, the original dataSpace is returned.
-++static android_dataspace modifyBufferDataspace( android_dataspace dataSpace,
-++                                                EGLint colorspace) {
-++    if (colorspace == EGL_GL_COLORSPACE_LINEAR_KHR) {
-++        return HAL_DATASPACE_SRGB_LINEAR;
-++    } else if (colorspace == EGL_GL_COLORSPACE_SRGB_KHR) {
-++        return HAL_DATASPACE_SRGB;
-++    }
-++    return dataSpace;
-++}
-++
-++EGLSurface eglCreateWindowSurface(  EGLDisplay dpy, EGLConfig config,
-++                                    NativeWindowType window,
-++                                    const EGLint *attrib_list)
-++{
-++    clearError();
-++
-++    egl_connection_t* cnx = NULL;
-++    egl_display_ptr dp = validate_display_connection(dpy, cnx);
-++    if (dp) {
-++        EGLDisplay iDpy = dp->disp.dpy;
-++
-++        int result = native_window_api_connect(window, NATIVE_WINDOW_API_EGL);
-++        if (result != OK) {
-++            ALOGE("eglCreateWindowSurface: native_window_api_connect (win=%p) "
-++                    "failed (%#x) (already connected to another API?)",
-++                    window, result);
-++            return setError(EGL_BAD_ALLOC, EGL_NO_SURFACE);
-++        }
-++
-++        // Set the native window's buffers format to match what this config requests.
-++        // Whether to use sRGB gamma is not part of the EGLconfig, but is part
-++        // of our native format. So if sRGB gamma is requested, we have to
-++        // modify the EGLconfig's format before setting the native window's
-++        // format.
-++
-++        // by default, just pick RGBA_8888
-++        EGLint format = HAL_PIXEL_FORMAT_RGBA_8888;
-++        android_dataspace dataSpace = HAL_DATASPACE_UNKNOWN;
-++
-++        EGLint a = 0;
-++        cnx->egl.eglGetConfigAttrib(iDpy, config, EGL_ALPHA_SIZE, &a);
-++        if (a > 0) {
-++            // alpha-channel requested, there's really only one suitable format
-++            format = HAL_PIXEL_FORMAT_RGBA_8888;
-++        } else {
-++            EGLint r, g, b;
-++            r = g = b = 0;
-++            cnx->egl.eglGetConfigAttrib(iDpy, config, EGL_RED_SIZE,   &r);
-++            cnx->egl.eglGetConfigAttrib(iDpy, config, EGL_GREEN_SIZE, &g);
-++            cnx->egl.eglGetConfigAttrib(iDpy, config, EGL_BLUE_SIZE,  &b);
-++            EGLint colorDepth = r + g + b;
-++            if (colorDepth <= 16) {
-++                format = HAL_PIXEL_FORMAT_RGB_565;
-++            } else {
-++                format = HAL_PIXEL_FORMAT_RGBX_8888;
-++            }
-++        }
-++
-++        // now select a corresponding sRGB format if needed
-++        if (attrib_list && dp->haveExtension("EGL_KHR_gl_colorspace")) {
-++            for (const EGLint* attr = attrib_list; *attr != EGL_NONE; attr += 2) {
-++                if (*attr == EGL_GL_COLORSPACE_KHR) {
-++                    if (ENABLE_EGL_KHR_GL_COLORSPACE) {
-++                        dataSpace = modifyBufferDataspace(dataSpace, *(attr+1));
-++                    } else {
-++                        // Normally we'd pass through unhandled attributes to
-++                        // the driver. But in case the driver implements this
-++                        // extension but we're disabling it, we want to prevent
-++                        // it getting through -- support will be broken without
-++                        // our help.
-++                        ALOGE("sRGB window surfaces not supported");
-++                        return setError(EGL_BAD_ATTRIBUTE, EGL_NO_SURFACE);
-++                    }
-++                }
-++            }
-++        }
-++
-++        if (format != 0) {
-++            int err = native_window_set_buffers_format(window, format);
-++            if (err != 0) {
-++                ALOGE("error setting native window pixel format: %s (%d)",
-++                        strerror(-err), err);
-++                native_window_api_disconnect(window, NATIVE_WINDOW_API_EGL);
-++                return setError(EGL_BAD_NATIVE_WINDOW, EGL_NO_SURFACE);
-++            }
-++        }
-++
-++        if (dataSpace != 0) {
-++            int err = native_window_set_buffers_data_space(window, dataSpace);
-++            if (err != 0) {
-++                ALOGE("error setting native window pixel dataSpace: %s (%d)",
-++                        strerror(-err), err);
-++                native_window_api_disconnect(window, NATIVE_WINDOW_API_EGL);
-++                return setError(EGL_BAD_NATIVE_WINDOW, EGL_NO_SURFACE);
-++            }
-++        }
-++
-++        // the EGL spec requires that a new EGLSurface default to swap interval
-++        // 1, so explicitly set that on the window here.
-++        ANativeWindow* anw = reinterpret_cast<ANativeWindow*>(window);
-++        anw->setSwapInterval(anw, 1);
-++
-++        EGLSurface surface = cnx->egl.eglCreateWindowSurface(
-++                iDpy, config, window, attrib_list);
-++        if (surface != EGL_NO_SURFACE) {
-++            egl_surface_t* s = new egl_surface_t(dp.get(), config, window,
-++                    surface, cnx);
-++            return s;
-++        }
-++
-++        // EGLSurface creation failed
-++        native_window_set_buffers_format(window, 0);
-++        native_window_api_disconnect(window, NATIVE_WINDOW_API_EGL);
-++    }
-++    return EGL_NO_SURFACE;
-++}
-++
-++EGLSurface eglCreatePixmapSurface(  EGLDisplay dpy, EGLConfig config,
-++                                    NativePixmapType pixmap,
-++                                    const EGLint *attrib_list)
-++{
-++    clearError();
-++
-++    egl_connection_t* cnx = NULL;
-++    egl_display_ptr dp = validate_display_connection(dpy, cnx);
-++    if (dp) {
-++        EGLSurface surface = cnx->egl.eglCreatePixmapSurface(
-++                dp->disp.dpy, config, pixmap, attrib_list);
-++        if (surface != EGL_NO_SURFACE) {
-++            egl_surface_t* s = new egl_surface_t(dp.get(), config, NULL,
-++                    surface, cnx);
-++            return s;
-++        }
-++    }
-++    return EGL_NO_SURFACE;
-++}
-++
-++EGLSurface eglCreatePbufferSurface( EGLDisplay dpy, EGLConfig config,
-++                                    const EGLint *attrib_list)
-++{
-++    clearError();
-++
-++    egl_connection_t* cnx = NULL;
-++    egl_display_ptr dp = validate_display_connection(dpy, cnx);
-++    if (dp) {
-++        EGLSurface surface = cnx->egl.eglCreatePbufferSurface(
-++                dp->disp.dpy, config, attrib_list);
-++        if (surface != EGL_NO_SURFACE) {
-++            egl_surface_t* s = new egl_surface_t(dp.get(), config, NULL,
-++                    surface, cnx);
-++            return s;
-++        }
-++    }
-++    return EGL_NO_SURFACE;
-++}
-++
-++EGLBoolean eglDestroySurface(EGLDisplay dpy, EGLSurface surface)
-++{
-++    clearError();
-++
-++    const egl_display_ptr dp = validate_display(dpy);
-++    if (!dp) return EGL_FALSE;
-++
-++    SurfaceRef _s(dp.get(), surface);
-++    if (!_s.get())
-++        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-++
-++    egl_surface_t * const s = get_surface(surface);
-++    EGLBoolean result = s->cnx->egl.eglDestroySurface(dp->disp.dpy, s->surface);
-++    if (result == EGL_TRUE) {
-++        _s.terminate();
-++    }
-++    return result;
-++}
-++
-++EGLBoolean eglQuerySurface( EGLDisplay dpy, EGLSurface surface,
-++                            EGLint attribute, EGLint *value)
-++{
-++    clearError();
-++
-++    const egl_display_ptr dp = validate_display(dpy);
-++    if (!dp) return EGL_FALSE;
-++
-++    SurfaceRef _s(dp.get(), surface);
-++    if (!_s.get())
-++        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-++
-++    egl_surface_t const * const s = get_surface(surface);
-++    return s->cnx->egl.eglQuerySurface(
-++            dp->disp.dpy, s->surface, attribute, value);
-++}
-++
-++void EGLAPI eglBeginFrame(EGLDisplay dpy, EGLSurface surface) {
-++    ATRACE_CALL();
-++    clearError();
-++
-++    const egl_display_ptr dp = validate_display(dpy);
-++    if (!dp) {
-++        return;
-++    }
-++
-++    SurfaceRef _s(dp.get(), surface);
-++    if (!_s.get()) {
-++        setError(EGL_BAD_SURFACE, EGL_FALSE);
-++        return;
-++    }
-++}
-++
-++// ----------------------------------------------------------------------------
-++// Contexts
-++// ----------------------------------------------------------------------------
-++
-++EGLContext eglCreateContext(EGLDisplay dpy, EGLConfig config,
-++                            EGLContext share_list, const EGLint *attrib_list)
-++{
-++    clearError();
-++
-++    egl_connection_t* cnx = NULL;
-++    const egl_display_ptr dp = validate_display_connection(dpy, cnx);
-++    if (dp) {
-++        if (share_list != EGL_NO_CONTEXT) {
-++            if (!ContextRef(dp.get(), share_list).get()) {
-++                return setError(EGL_BAD_CONTEXT, EGL_NO_CONTEXT);
-++            }
-++            egl_context_t* const c = get_context(share_list);
-++            share_list = c->context;
-++        }
-++        EGLContext context = cnx->egl.eglCreateContext(
-++                dp->disp.dpy, config, share_list, attrib_list);
-++        if (context != EGL_NO_CONTEXT) {
-++            // figure out if it's a GLESv1 or GLESv2
-++            int version = 0;
-++            if (attrib_list) {
-++                while (*attrib_list != EGL_NONE) {
-++                    GLint attr = *attrib_list++;
-++                    GLint value = *attrib_list++;
-++                    if (attr == EGL_CONTEXT_CLIENT_VERSION) {
-++                        if (value == 1) {
-++                            version = egl_connection_t::GLESv1_INDEX;
-++                        } else if (value == 2 || value == 3) {
-++                            version = egl_connection_t::GLESv2_INDEX;
-++                        }
-++                    }
-++                };
-++            }
-++            egl_context_t* c = new egl_context_t(dpy, context, config, cnx,
-++                    version);
-++            return c;
-++        }
-++    }
-++    return EGL_NO_CONTEXT;
-++}
-++
-++EGLBoolean eglDestroyContext(EGLDisplay dpy, EGLContext ctx)
-++{
-++    clearError();
-++
-++    const egl_display_ptr dp = validate_display(dpy);
-++    if (!dp)
-++        return EGL_FALSE;
-++
-++    ContextRef _c(dp.get(), ctx);
-++    if (!_c.get())
-++        return setError(EGL_BAD_CONTEXT, EGL_FALSE);
-++
-++    egl_context_t * const c = get_context(ctx);
-++    EGLBoolean result = c->cnx->egl.eglDestroyContext(dp->disp.dpy, c->context);
-++    if (result == EGL_TRUE) {
-++        _c.terminate();
-++    }
-++    return result;
-++}
-++
-++EGLBoolean eglMakeCurrent(  EGLDisplay dpy, EGLSurface draw,
-++                            EGLSurface read, EGLContext ctx)
-++{
-++    clearError();
-++
-++    egl_display_ptr dp = validate_display(dpy);
-++    if (!dp) return setError(EGL_BAD_DISPLAY, EGL_FALSE);
-++
-++    // If ctx is not EGL_NO_CONTEXT, read is not EGL_NO_SURFACE, or draw is not
-++    // EGL_NO_SURFACE, then an EGL_NOT_INITIALIZED error is generated if dpy is
-++    // a valid but uninitialized display.
-++    if ( (ctx != EGL_NO_CONTEXT) || (read != EGL_NO_SURFACE) ||
-++         (draw != EGL_NO_SURFACE) ) {
-++        if (!dp->isReady()) return setError(EGL_NOT_INITIALIZED, EGL_FALSE);
-++    }
-++
-++    // get a reference to the object passed in
-++    ContextRef _c(dp.get(), ctx);
-++    SurfaceRef _d(dp.get(), draw);
-++    SurfaceRef _r(dp.get(), read);
-++
-++    // validate the context (if not EGL_NO_CONTEXT)
-++    if ((ctx != EGL_NO_CONTEXT) && !_c.get()) {
-++        // EGL_NO_CONTEXT is valid
-++        return setError(EGL_BAD_CONTEXT, EGL_FALSE);
-++    }
-++
-++    // these are the underlying implementation's object
-++    EGLContext impl_ctx  = EGL_NO_CONTEXT;
-++    EGLSurface impl_draw = EGL_NO_SURFACE;
-++    EGLSurface impl_read = EGL_NO_SURFACE;
-++
-++    // these are our objects structs passed in
-++    egl_context_t       * c = NULL;
-++    egl_surface_t const * d = NULL;
-++    egl_surface_t const * r = NULL;
-++
-++    // these are the current objects structs
-++    egl_context_t * cur_c = get_context(getContext());
-++
-++    if (ctx != EGL_NO_CONTEXT) {
-++        c = get_context(ctx);
-++        impl_ctx = c->context;
-++    } else {
-++        // no context given, use the implementation of the current context
-++        if (draw != EGL_NO_SURFACE || read != EGL_NO_SURFACE) {
-++            // calling eglMakeCurrent( ..., !=0, !=0, EGL_NO_CONTEXT);
-++            return setError(EGL_BAD_MATCH, EGL_FALSE);
-++        }
-++        if (cur_c == NULL) {
-++            // no current context
-++            // not an error, there is just no current context.
-++            return EGL_TRUE;
-++        }
-++    }
-++
-++    // retrieve the underlying implementation's draw EGLSurface
-++    if (draw != EGL_NO_SURFACE) {
-++        if (!_d.get()) return setError(EGL_BAD_SURFACE, EGL_FALSE);
-++        d = get_surface(draw);
-++        impl_draw = d->surface;
-++    }
-++
-++    // retrieve the underlying implementation's read EGLSurface
-++    if (read != EGL_NO_SURFACE) {
-++        if (!_r.get()) return setError(EGL_BAD_SURFACE, EGL_FALSE);
-++        r = get_surface(read);
-++        impl_read = r->surface;
-++    }
-++
-++
-++    EGLBoolean result = dp->makeCurrent(c, cur_c,
-++            draw, read, ctx,
-++            impl_draw, impl_read, impl_ctx);
-++
-++    if (result == EGL_TRUE) {
-++        if (c) {
-++            setGLHooksThreadSpecific(c->cnx->hooks[c->version]);
-++            egl_tls_t::setContext(ctx);
-++            _c.acquire();
-++            _r.acquire();
-++            _d.acquire();
-++        } else {
-++            setGLHooksThreadSpecific(&gHooksNoContext);
-++            egl_tls_t::setContext(EGL_NO_CONTEXT);
-++        }
-++    } else {
-++        // this will ALOGE the error
-++        egl_connection_t* const cnx = &gEGLImpl;
-++        result = setError(cnx->egl.eglGetError(), EGL_FALSE);
-++    }
-++    return result;
-++}
-++
-++
-++EGLBoolean eglQueryContext( EGLDisplay dpy, EGLContext ctx,
-++                            EGLint attribute, EGLint *value)
-++{
-++    clearError();
-++
-++    const egl_display_ptr dp = validate_display(dpy);
-++    if (!dp) return EGL_FALSE;
-++
-++    ContextRef _c(dp.get(), ctx);
-++    if (!_c.get()) return setError(EGL_BAD_CONTEXT, EGL_FALSE);
-++
-++    egl_context_t * const c = get_context(ctx);
-++    return c->cnx->egl.eglQueryContext(
-++            dp->disp.dpy, c->context, attribute, value);
-++
-++}
-++
-++EGLContext eglGetCurrentContext(void)
-++{
-++    // could be called before eglInitialize(), but we wouldn't have a context
-++    // then, and this function would correctly return EGL_NO_CONTEXT.
-++
-++    clearError();
-++
-++    EGLContext ctx = getContext();
-++    return ctx;
-++}
-++
-++EGLSurface eglGetCurrentSurface(EGLint readdraw)
-++{
-++    // could be called before eglInitialize(), but we wouldn't have a context
-++    // then, and this function would correctly return EGL_NO_SURFACE.
-++
-++    clearError();
-++
-++    EGLContext ctx = getContext();
-++    if (ctx) {
-++        egl_context_t const * const c = get_context(ctx);
-++        if (!c) return setError(EGL_BAD_CONTEXT, EGL_NO_SURFACE);
-++        switch (readdraw) {
-++            case EGL_READ: return c->read;
-++            case EGL_DRAW: return c->draw;
-++            default: return setError(EGL_BAD_PARAMETER, EGL_NO_SURFACE);
-++        }
-++    }
-++    return EGL_NO_SURFACE;
-++}
-++
-++EGLDisplay eglGetCurrentDisplay(void)
-++{
-++    // could be called before eglInitialize(), but we wouldn't have a context
-++    // then, and this function would correctly return EGL_NO_DISPLAY.
-++
-++    clearError();
-++
-++    EGLContext ctx = getContext();
-++    if (ctx) {
-++        egl_context_t const * const c = get_context(ctx);
-++        if (!c) return setError(EGL_BAD_CONTEXT, EGL_NO_SURFACE);
-++        return c->dpy;
-++    }
-++    return EGL_NO_DISPLAY;
-++}
-++
-++EGLBoolean eglWaitGL(void)
-++{
-++    clearError();
-++
-++    egl_connection_t* const cnx = &gEGLImpl;
-++    if (!cnx->dso)
-++        return setError(EGL_BAD_CONTEXT, EGL_FALSE);
-++
-++    return cnx->egl.eglWaitGL();
-++}
-++
-++EGLBoolean eglWaitNative(EGLint engine)
-++{
-++    clearError();
-++
-++    egl_connection_t* const cnx = &gEGLImpl;
-++    if (!cnx->dso)
-++        return setError(EGL_BAD_CONTEXT, EGL_FALSE);
-++
-++    return cnx->egl.eglWaitNative(engine);
-++}
-++
-++EGLint eglGetError(void)
-++{
-++    EGLint err = EGL_SUCCESS;
-++    egl_connection_t* const cnx = &gEGLImpl;
-++    if (cnx->dso) {
-++        err = cnx->egl.eglGetError();
-++    }
-++    if (err == EGL_SUCCESS) {
-++        err = egl_tls_t::getError();
-++    }
-++    return err;
-++}
-++
-++static __eglMustCastToProperFunctionPointerType findBuiltinWrapper(
-++        const char* procname) {
-++    const egl_connection_t* cnx = &gEGLImpl;
-++    void* proc = NULL;
-++
-++    proc = dlsym(cnx->libEgl, procname);
-++    if (proc) return (__eglMustCastToProperFunctionPointerType)proc;
-++
-++    proc = dlsym(cnx->libGles2, procname);
-++    if (proc) return (__eglMustCastToProperFunctionPointerType)proc;
-++
-++    proc = dlsym(cnx->libGles1, procname);
-++    if (proc) return (__eglMustCastToProperFunctionPointerType)proc;
-++
-++    return NULL;
-++}
-++
-++__eglMustCastToProperFunctionPointerType eglGetProcAddress(const char *procname)
-++{
-++    // eglGetProcAddress() could be the very first function called
-++    // in which case we must make sure we've initialized ourselves, this
-++    // happens the first time egl_get_display() is called.
-++
-++    clearError();
-++
-++    if (egl_init_drivers() == EGL_FALSE) {
-++        setError(EGL_BAD_PARAMETER, NULL);
-++        return  NULL;
-++    }
-++
-++    if (FILTER_EXTENSIONS(procname)) {
-++        return NULL;
-++    }
-++
-++    __eglMustCastToProperFunctionPointerType addr;
-++    addr = findProcAddress(procname, sExtensionMap, NELEM(sExtensionMap));
-++    if (addr) return addr;
-++
-++    addr = findBuiltinWrapper(procname);
-++    if (addr) return addr;
-++
-++    // this protects accesses to sGLExtentionMap and sGLExtentionSlot
-++    pthread_mutex_lock(&sExtensionMapMutex);
-++
-++        /*
-++         * Since eglGetProcAddress() is not associated to anything, it needs
-++         * to return a function pointer that "works" regardless of what
-++         * the current context is.
-++         *
-++         * For this reason, we return a "forwarder", a small stub that takes
-++         * care of calling the function associated with the context
-++         * currently bound.
-++         *
-++         * We first look for extensions we've already resolved, if we're seeing
-++         * this extension for the first time, we go through all our
-++         * implementations and call eglGetProcAddress() and record the
-++         * result in the appropriate implementation hooks and return the
-++         * address of the forwarder corresponding to that hook set.
-++         *
-++         */
-++
-++        const String8 name(procname);
-++        addr = sGLExtentionMap.valueFor(name);
-++        const int slot = sGLExtentionSlot;
-++
-++        ALOGE_IF(slot >= MAX_NUMBER_OF_GL_EXTENSIONS,
-++                "no more slots for eglGetProcAddress(\"%s\")",
-++                procname);
-++
-++        if (!addr && (slot < MAX_NUMBER_OF_GL_EXTENSIONS)) {
-++            bool found = false;
-++
-++            egl_connection_t* const cnx = &gEGLImpl;
-++            if (cnx->dso && cnx->egl.eglGetProcAddress) {
-++                // Extensions are independent of the bound context
-++                addr =
-++                cnx->hooks[egl_connection_t::GLESv1_INDEX]->ext.extensions[slot] =
-++                cnx->hooks[egl_connection_t::GLESv2_INDEX]->ext.extensions[slot] =
-++                        cnx->egl.eglGetProcAddress(procname);
-++                if (addr) found = true;
-++            }
-++
-++            if (found) {
-++                addr = gExtensionForwarders[slot];
-++                sGLExtentionMap.add(name, addr);
-++                sGLExtentionSlot++;
-++            }
-++        }
-++
-++    pthread_mutex_unlock(&sExtensionMapMutex);
-++    return addr;
-++}
-++
-++class FrameCompletionThread : public Thread {
-++public:
-++
-++    static void queueSync(EGLSyncKHR sync) {
-++        static sp<FrameCompletionThread> thread(new FrameCompletionThread);
-++        static bool running = false;
-++        if (!running) {
-++            thread->run("GPUFrameCompletion");
-++            running = true;
-++        }
-++        {
-++            Mutex::Autolock lock(thread->mMutex);
-++            ScopedTrace st(ATRACE_TAG, String8::format("kicked off frame %d",
-++                    thread->mFramesQueued).string());
-++            thread->mQueue.push_back(sync);
-++            thread->mCondition.signal();
-++            thread->mFramesQueued++;
-++            ATRACE_INT("GPU Frames Outstanding", thread->mQueue.size());
-++        }
-++    }
-++
-++private:
-++    FrameCompletionThread() : mFramesQueued(0), mFramesCompleted(0) {}
-++
-++    virtual bool threadLoop() {
-++        EGLSyncKHR sync;
-++        uint32_t frameNum;
-++        {
-++            Mutex::Autolock lock(mMutex);
-++            while (mQueue.isEmpty()) {
-++                mCondition.wait(mMutex);
-++            }
-++            sync = mQueue[0];
-++            frameNum = mFramesCompleted;
-++        }
-++        EGLDisplay dpy = eglGetDisplay(EGL_DEFAULT_DISPLAY);
-++        {
-++            ScopedTrace st(ATRACE_TAG, String8::format("waiting for frame %d",
-++                    frameNum).string());
-++            EGLint result = eglClientWaitSyncKHR(dpy, sync, 0, EGL_FOREVER_KHR);
-++            if (result == EGL_FALSE) {
-++                ALOGE("FrameCompletion: error waiting for fence: %#x", eglGetError());
-++            } else if (result == EGL_TIMEOUT_EXPIRED_KHR) {
-++                ALOGE("FrameCompletion: timeout waiting for fence");
-++            }
-++            eglDestroySyncKHR(dpy, sync);
-++        }
-++        {
-++            Mutex::Autolock lock(mMutex);
-++            mQueue.removeAt(0);
-++            mFramesCompleted++;
-++            ATRACE_INT("GPU Frames Outstanding", mQueue.size());
-++        }
-++        return true;
-++    }
-++
-++    uint32_t mFramesQueued;
-++    uint32_t mFramesCompleted;
-++    Vector<EGLSyncKHR> mQueue;
-++    Condition mCondition;
-++    Mutex mMutex;
-++};
-++
-++EGLBoolean eglSwapBuffersWithDamageKHR(EGLDisplay dpy, EGLSurface draw,
-++        EGLint *rects, EGLint n_rects)
-++{
-++    ATRACE_CALL();
-++    clearError();
-++
-++    const egl_display_ptr dp = validate_display(dpy);
-++    if (!dp) return EGL_FALSE;
-++
-++    SurfaceRef _s(dp.get(), draw);
-++    if (!_s.get())
-++        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-++
-++    egl_surface_t const * const s = get_surface(draw);
-++
-++    if (CC_UNLIKELY(dp->traceGpuCompletion)) {
-++        EGLSyncKHR sync = eglCreateSyncKHR(dpy, EGL_SYNC_FENCE_KHR, NULL);
-++        if (sync != EGL_NO_SYNC_KHR) {
-++            FrameCompletionThread::queueSync(sync);
-++        }
-++    }
-++
-++    if (CC_UNLIKELY(dp->finishOnSwap)) {
-++        uint32_t pixel;
-++        egl_context_t * const c = get_context( egl_tls_t::getContext() );
-++        if (c) {
-++            // glReadPixels() ensures that the frame is complete
-++            s->cnx->hooks[c->version]->gl.glReadPixels(0,0,1,1,
-++                    GL_RGBA,GL_UNSIGNED_BYTE,&pixel);
-++        }
-++    }
-++
-++    if (n_rects == 0) {
-++        return s->cnx->egl.eglSwapBuffers(dp->disp.dpy, s->surface);
-++    }
-++
-++    Vector<android_native_rect_t> androidRects;
-++    for (int r = 0; r < n_rects; ++r) {
-++        int offset = r * 4;
-++        int x = rects[offset];
-++        int y = rects[offset + 1];
-++        int width = rects[offset + 2];
-++        int height = rects[offset + 3];
-++        android_native_rect_t androidRect;
-++        androidRect.left = x;
-++        androidRect.top = y + height;
-++        androidRect.right = x + width;
-++        androidRect.bottom = y;
-++        androidRects.push_back(androidRect);
-++    }
-++    native_window_set_surface_damage(s->win.get(), androidRects.array(),
-++            androidRects.size());
-++
-++    if (s->cnx->egl.eglSwapBuffersWithDamageKHR) {
-++        return s->cnx->egl.eglSwapBuffersWithDamageKHR(dp->disp.dpy, s->surface,
-++                rects, n_rects);
-++    } else {
-++        return s->cnx->egl.eglSwapBuffers(dp->disp.dpy, s->surface);
-++    }
-++}
-++
-++EGLBoolean eglSwapBuffers(EGLDisplay dpy, EGLSurface surface)
-++{
-++    return eglSwapBuffersWithDamageKHR(dpy, surface, NULL, 0);
-++}
-++
-++EGLBoolean eglCopyBuffers(  EGLDisplay dpy, EGLSurface surface,
-++                            NativePixmapType target)
-++{
-++    clearError();
-++
-++    const egl_display_ptr dp = validate_display(dpy);
-++    if (!dp) return EGL_FALSE;
-++
-++    SurfaceRef _s(dp.get(), surface);
-++    if (!_s.get())
-++        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-++
-++    egl_surface_t const * const s = get_surface(surface);
-++    return s->cnx->egl.eglCopyBuffers(dp->disp.dpy, s->surface, target);
-++}
-++
-++const char* eglQueryString(EGLDisplay dpy, EGLint name)
-++{
-++    clearError();
-++
-++    const egl_display_ptr dp = validate_display(dpy);
-++    if (!dp) return (const char *) NULL;
-++
-++    switch (name) {
-++        case EGL_VENDOR:
-++            return dp->getVendorString();
-++        case EGL_VERSION:
-++            return dp->getVersionString();
-++        case EGL_EXTENSIONS:
-++            return dp->getExtensionString();
-++        case EGL_CLIENT_APIS:
-++            return dp->getClientApiString();
-++    }
-++    return setError(EGL_BAD_PARAMETER, (const char *)0);
-++}
-++
-++EGLAPI const char* eglQueryStringImplementationANDROID(EGLDisplay dpy, EGLint name)
-++{
-++    clearError();
-++
-++    const egl_display_ptr dp = validate_display(dpy);
-++    if (!dp) return (const char *) NULL;
-++
-++    switch (name) {
-++        case EGL_VENDOR:
-++            return dp->disp.queryString.vendor;
-++        case EGL_VERSION:
-++            return dp->disp.queryString.version;
-++        case EGL_EXTENSIONS:
-++            return dp->disp.queryString.extensions;
-++        case EGL_CLIENT_APIS:
-++            return dp->disp.queryString.clientApi;
-++    }
-++    return setError(EGL_BAD_PARAMETER, (const char *)0);
-++}
-++
-++// ----------------------------------------------------------------------------
-++// EGL 1.1
-++// ----------------------------------------------------------------------------
-++
-++EGLBoolean eglSurfaceAttrib(
-++        EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint value)
-++{
-++    clearError();
-++
-++    const egl_display_ptr dp = validate_display(dpy);
-++    if (!dp) return EGL_FALSE;
-++
-++    SurfaceRef _s(dp.get(), surface);
-++    if (!_s.get())
-++        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-++
-++    egl_surface_t * const s = get_surface(surface);
-++
-++    if (attribute == EGL_FRONT_BUFFER_AUTO_REFRESH_ANDROID) {
-++        int err = native_window_set_auto_refresh(s->win.get(),
-++            value ? true : false);
-++        return (err == NO_ERROR) ? EGL_TRUE :
-++            setError(EGL_BAD_SURFACE, EGL_FALSE);
-++    }
-++
-++#if ENABLE_EGL_ANDROID_GET_FRAME_TIMESTAMPS
-++    if (attribute == EGL_TIMESTAMPS_ANDROID) {
-++        s->enableTimestamps = value;
-++        return EGL_TRUE;
-++    }
-++#endif
-++
-++    if (s->cnx->egl.eglSurfaceAttrib) {
-++        return s->cnx->egl.eglSurfaceAttrib(
-++                dp->disp.dpy, s->surface, attribute, value);
-++    }
-++    return setError(EGL_BAD_SURFACE, EGL_FALSE);
-++}
-++
-++EGLBoolean eglBindTexImage(
-++        EGLDisplay dpy, EGLSurface surface, EGLint buffer)
-++{
-++    clearError();
-++
-++    const egl_display_ptr dp = validate_display(dpy);
-++    if (!dp) return EGL_FALSE;
-++
-++    SurfaceRef _s(dp.get(), surface);
-++    if (!_s.get())
-++        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-++
-++    egl_surface_t const * const s = get_surface(surface);
-++    if (s->cnx->egl.eglBindTexImage) {
-++        return s->cnx->egl.eglBindTexImage(
-++                dp->disp.dpy, s->surface, buffer);
-++    }
-++    return setError(EGL_BAD_SURFACE, EGL_FALSE);
-++}
-++
-++EGLBoolean eglReleaseTexImage(
-++        EGLDisplay dpy, EGLSurface surface, EGLint buffer)
-++{
-++    clearError();
-++
-++    const egl_display_ptr dp = validate_display(dpy);
-++    if (!dp) return EGL_FALSE;
-++
-++    SurfaceRef _s(dp.get(), surface);
-++    if (!_s.get())
-++        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-++
-++    egl_surface_t const * const s = get_surface(surface);
-++    if (s->cnx->egl.eglReleaseTexImage) {
-++        return s->cnx->egl.eglReleaseTexImage(
-++                dp->disp.dpy, s->surface, buffer);
-++    }
-++    return setError(EGL_BAD_SURFACE, EGL_FALSE);
-++}
-++
-++EGLBoolean eglSwapInterval(EGLDisplay dpy, EGLint interval)
-++{
-++    clearError();
-++
-++    const egl_display_ptr dp = validate_display(dpy);
-++    if (!dp) return EGL_FALSE;
-++
-++    EGLBoolean res = EGL_TRUE;
-++    egl_connection_t* const cnx = &gEGLImpl;
-++    if (cnx->dso && cnx->egl.eglSwapInterval) {
-++        res = cnx->egl.eglSwapInterval(dp->disp.dpy, interval);
-++    }
-++
-++    return res;
-++}
-++
-++
-++// ----------------------------------------------------------------------------
-++// EGL 1.2
-++// ----------------------------------------------------------------------------
-++
-++EGLBoolean eglWaitClient(void)
-++{
-++    clearError();
-++
-++    egl_connection_t* const cnx = &gEGLImpl;
-++    if (!cnx->dso)
-++        return setError(EGL_BAD_CONTEXT, EGL_FALSE);
-++
-++    EGLBoolean res;
-++    if (cnx->egl.eglWaitClient) {
-++        res = cnx->egl.eglWaitClient();
-++    } else {
-++        res = cnx->egl.eglWaitGL();
-++    }
-++    return res;
-++}
-++
-++EGLBoolean eglBindAPI(EGLenum api)
-++{
-++    clearError();
-++
-++    if (egl_init_drivers() == EGL_FALSE) {
-++        return setError(EGL_BAD_PARAMETER, EGL_FALSE);
-++    }
-++
-++    // bind this API on all EGLs
-++    EGLBoolean res = EGL_TRUE;
-++    egl_connection_t* const cnx = &gEGLImpl;
-++    if (cnx->dso && cnx->egl.eglBindAPI) {
-++        res = cnx->egl.eglBindAPI(api);
-++    }
-++    return res;
-++}
-++
-++EGLenum eglQueryAPI(void)
-++{
-++    clearError();
-++
-++    if (egl_init_drivers() == EGL_FALSE) {
-++        return setError(EGL_BAD_PARAMETER, EGL_FALSE);
-++    }
-++
-++    egl_connection_t* const cnx = &gEGLImpl;
-++    if (cnx->dso && cnx->egl.eglQueryAPI) {
-++        return cnx->egl.eglQueryAPI();
-++    }
-++
-++    // or, it can only be OpenGL ES
-++    return EGL_OPENGL_ES_API;
-++}
-++
-++EGLBoolean eglReleaseThread(void)
-++{
-++    clearError();
-++
-++    // If there is context bound to the thread, release it
-++    egl_display_t::loseCurrent(get_context(getContext()));
-++
-++    egl_connection_t* const cnx = &gEGLImpl;
-++    if (cnx->dso && cnx->egl.eglReleaseThread) {
-++        cnx->egl.eglReleaseThread();
-++    }
-++    egl_tls_t::clearTLS();
-++    return EGL_TRUE;
-++}
-++
-++EGLSurface eglCreatePbufferFromClientBuffer(
-++          EGLDisplay dpy, EGLenum buftype, EGLClientBuffer buffer,
-++          EGLConfig config, const EGLint *attrib_list)
-++{
-++    clearError();
-++
-++    egl_connection_t* cnx = NULL;
-++    const egl_display_ptr dp = validate_display_connection(dpy, cnx);
-++    if (!dp) return EGL_FALSE;
-++    if (cnx->egl.eglCreatePbufferFromClientBuffer) {
-++        return cnx->egl.eglCreatePbufferFromClientBuffer(
-++                dp->disp.dpy, buftype, buffer, config, attrib_list);
-++    }
-++    return setError(EGL_BAD_CONFIG, EGL_NO_SURFACE);
-++}
-++
-++// ----------------------------------------------------------------------------
-++// EGL_EGLEXT_VERSION 3
-++// ----------------------------------------------------------------------------
-++
-++EGLBoolean eglLockSurfaceKHR(EGLDisplay dpy, EGLSurface surface,
-++        const EGLint *attrib_list)
-++{
-++    clearError();
-++
-++    const egl_display_ptr dp = validate_display(dpy);
-++    if (!dp) return EGL_FALSE;
-++
-++    SurfaceRef _s(dp.get(), surface);
-++    if (!_s.get())
-++        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-++
-++    egl_surface_t const * const s = get_surface(surface);
-++    if (s->cnx->egl.eglLockSurfaceKHR) {
-++        return s->cnx->egl.eglLockSurfaceKHR(
-++                dp->disp.dpy, s->surface, attrib_list);
-++    }
-++    return setError(EGL_BAD_DISPLAY, EGL_FALSE);
-++}
-++
-++EGLBoolean eglUnlockSurfaceKHR(EGLDisplay dpy, EGLSurface surface)
-++{
-++    clearError();
-++
-++    const egl_display_ptr dp = validate_display(dpy);
-++    if (!dp) return EGL_FALSE;
-++
-++    SurfaceRef _s(dp.get(), surface);
-++    if (!_s.get())
-++        return setError(EGL_BAD_SURFACE, EGL_FALSE);
-++
-++    egl_surface_t const * const s = get_surface(surface);
-++    if (s->cnx->egl.eglUnlockSurfaceKHR) {
-++        return s->cnx->egl.eglUnlockSurfaceKHR(dp->disp.dpy, s->surface);
-++    }
-++    return setError(EGL_BAD_DISPLAY, EGL_FALSE);
-++}
-++
-++EGLImageKHR eglCreateImageKHR(EGLDisplay dpy, EGLContext ctx, EGLenum target,
-++        EGLClientBuffer buffer, const EGLint *attrib_list)
-++{
-++    clearError();
-++
-++    const egl_display_ptr dp = validate_display(dpy);
-++    if (!dp) return EGL_NO_IMAGE_KHR;
-++
-++    ContextRef _c(dp.get(), ctx);
-++    egl_context_t * const c = _c.get();
-++
-++    EGLImageKHR result = EGL_NO_IMAGE_KHR;
-++    egl_connection_t* const cnx = &gEGLImpl;
-++    if (cnx->dso && cnx->egl.eglCreateImageKHR) {
-++        result = cnx->egl.eglCreateImageKHR(
-++                dp->disp.dpy,
-++                c ? c->context : EGL_NO_CONTEXT,
-++                target, buffer, attrib_list);
-++    }
-++    return result;
-++}
-++
-++EGLBoolean eglDestroyImageKHR(EGLDisplay dpy, EGLImageKHR img)
-++{
-++    clearError();
-++
-++    const egl_display_ptr dp = validate_display(dpy);
-++    if (!dp) return EGL_FALSE;
-++
-++    EGLBoolean result = EGL_FALSE;
-++    egl_connection_t* const cnx = &gEGLImpl;
-++    if (cnx->dso && cnx->egl.eglDestroyImageKHR) {
-++        result = cnx->egl.eglDestroyImageKHR(dp->disp.dpy, img);
-++    }
-++    return result;
-++}
-++
-++// ----------------------------------------------------------------------------
-++// EGL_EGLEXT_VERSION 5
-++// ----------------------------------------------------------------------------
-++
-++
-++EGLSyncKHR eglCreateSyncKHR(EGLDisplay dpy, EGLenum type, const EGLint *attrib_list)
-++{
-++    clearError();
-++
-++    const egl_display_ptr dp = validate_display(dpy);
-++    if (!dp) return EGL_NO_SYNC_KHR;
-++
-++    EGLSyncKHR result = EGL_NO_SYNC_KHR;
-++    egl_connection_t* const cnx = &gEGLImpl;
-++    if (cnx->dso && cnx->egl.eglCreateSyncKHR) {
-++        result = cnx->egl.eglCreateSyncKHR(dp->disp.dpy, type, attrib_list);
-++    }
-++    return result;
-++}
-++
-++EGLBoolean eglDestroySyncKHR(EGLDisplay dpy, EGLSyncKHR sync)
-++{
-++    clearError();
-++
-++    const egl_display_ptr dp = validate_display(dpy);
-++    if (!dp) return EGL_FALSE;
-++
-++    EGLBoolean result = EGL_FALSE;
-++    egl_connection_t* const cnx = &gEGLImpl;
-++    if (cnx->dso && cnx->egl.eglDestroySyncKHR) {
-++        result = cnx->egl.eglDestroySyncKHR(dp->disp.dpy, sync);
-++    }
-++    return result;
-++}
-++
-++EGLBoolean eglSignalSyncKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLenum mode) {
-++    clearError();
-++
-++    const egl_display_ptr dp = validate_display(dpy);
-++    if (!dp) return EGL_FALSE;
-++
-++    EGLBoolean result = EGL_FALSE;
-++    egl_connection_t* const cnx = &gEGLImpl;
-++    if (cnx->dso && cnx->egl.eglSignalSyncKHR) {
-++        result = cnx->egl.eglSignalSyncKHR(
-++                dp->disp.dpy, sync, mode);
-++    }
-++    return result;
-++}
-++
-++EGLint eglClientWaitSyncKHR(EGLDisplay dpy, EGLSyncKHR sync,
-++        EGLint flags, EGLTimeKHR timeout)
-++{
-++    clearError();
-++
-++    const egl_display_ptr dp = validate_display(dpy);
-++    if (!dp) return EGL_FALSE;
-++
-++    EGLBoolean result = EGL_FALSE;
-++    egl_connection_t* const cnx = &gEGLImpl;
-++    if (cnx->dso && cnx->egl.eglClientWaitSyncKHR) {
-++        result = cnx->egl.eglClientWaitSyncKHR(
-++                dp->disp.dpy, sync, flags, timeout);
-++    }
-++    return result;
-++}
-++
-++EGLBoolean eglGetSyncAttribKHR(EGLDisplay dpy, EGLSyncKHR sync,
-++        EGLint attribute, EGLint *value)
-++{
-++    clearError();
-++
-++    const egl_display_ptr dp = validate_display(dpy);
-++    if (!dp) return EGL_FALSE;
-++
-++    EGLBoolean result = EGL_FALSE;
-++    egl_connection_t* const cnx = &gEGLImpl;
-++    if (cnx->dso && cnx->egl.eglGetSyncAttribKHR) {
-++        result = cnx->egl.eglGetSyncAttribKHR(
-++                dp->disp.dpy, sync, attribute, value);
-++    }
-++    return result;
-++}
-++
-++EGLStreamKHR eglCreateStreamKHR(EGLDisplay dpy, const EGLint *attrib_list)
-++{
-++    clearError();
-++
-++    const egl_display_ptr dp = validate_display(dpy);
-++    if (!dp) return EGL_NO_STREAM_KHR;
-++
-++    EGLStreamKHR result = EGL_NO_STREAM_KHR;
-++    egl_connection_t* const cnx = &gEGLImpl;
-++    if (cnx->dso && cnx->egl.eglCreateStreamKHR) {
-++        result = cnx->egl.eglCreateStreamKHR(
-++                dp->disp.dpy, attrib_list);
-++    }
-++    return result;
-++}
-++
-++EGLBoolean eglDestroyStreamKHR(EGLDisplay dpy, EGLStreamKHR stream)
-++{
-++    clearError();
-++
-++    const egl_display_ptr dp = validate_display(dpy);
-++    if (!dp) return EGL_FALSE;
-++
-++    EGLBoolean result = EGL_FALSE;
-++    egl_connection_t* const cnx = &gEGLImpl;
-++    if (cnx->dso && cnx->egl.eglDestroyStreamKHR) {
-++        result = cnx->egl.eglDestroyStreamKHR(
-++                dp->disp.dpy, stream);
-++    }
-++    return result;
-++}
-++
-++EGLBoolean eglStreamAttribKHR(EGLDisplay dpy, EGLStreamKHR stream,
-++        EGLenum attribute, EGLint value)
-++{
-++    clearError();
-++
-++    const egl_display_ptr dp = validate_display(dpy);
-++    if (!dp) return EGL_FALSE;
-++
-++    EGLBoolean result = EGL_FALSE;
-++    egl_connection_t* const cnx = &gEGLImpl;
-++    if (cnx->dso && cnx->egl.eglStreamAttribKHR) {
-++        result = cnx->egl.eglStreamAttribKHR(
-++                dp->disp.dpy, stream, attribute, value);
-++    }
-++    return result;
-++}
-++
-++EGLBoolean eglQueryStreamKHR(EGLDisplay dpy, EGLStreamKHR stream,
-++        EGLenum attribute, EGLint *value)
-++{
-++    clearError();
-++
-++    const egl_display_ptr dp = validate_display(dpy);
-++    if (!dp) return EGL_FALSE;
-++
-++    EGLBoolean result = EGL_FALSE;
-++    egl_connection_t* const cnx = &gEGLImpl;
-++    if (cnx->dso && cnx->egl.eglQueryStreamKHR) {
-++        result = cnx->egl.eglQueryStreamKHR(
-++                dp->disp.dpy, stream, attribute, value);
-++    }
-++    return result;
-++}
-++
-++EGLBoolean eglQueryStreamu64KHR(EGLDisplay dpy, EGLStreamKHR stream,
-++        EGLenum attribute, EGLuint64KHR *value)
-++{
-++    clearError();
-++
-++    const egl_display_ptr dp = validate_display(dpy);
-++    if (!dp) return EGL_FALSE;
-++
-++    EGLBoolean result = EGL_FALSE;
-++    egl_connection_t* const cnx = &gEGLImpl;
-++    if (cnx->dso && cnx->egl.eglQueryStreamu64KHR) {
-++        result = cnx->egl.eglQueryStreamu64KHR(
-++                dp->disp.dpy, stream, attribute, value);
-++    }
-++    return result;
-++}
-++
-++EGLBoolean eglQueryStreamTimeKHR(EGLDisplay dpy, EGLStreamKHR stream,
-++        EGLenum attribute, EGLTimeKHR *value)
-++{
-++    clearError();
-++
-++    const egl_display_ptr dp = validate_display(dpy);
-++    if (!dp) return EGL_FALSE;
-++
-++    EGLBoolean result = EGL_FALSE;
-++    egl_connection_t* const cnx = &gEGLImpl;
-++    if (cnx->dso && cnx->egl.eglQueryStreamTimeKHR) {
-++        result = cnx->egl.eglQueryStreamTimeKHR(
-++                dp->disp.dpy, stream, attribute, value);
-++    }
-++    return result;
-++}
-++
-++EGLSurface eglCreateStreamProducerSurfaceKHR(EGLDisplay dpy, EGLConfig config,
-++        EGLStreamKHR stream, const EGLint *attrib_list)
-++{
-++    clearError();
-++
-++    egl_display_ptr dp = validate_display(dpy);
-++    if (!dp) return EGL_NO_SURFACE;
-++
-++    egl_connection_t* const cnx = &gEGLImpl;
-++    if (cnx->dso && cnx->egl.eglCreateStreamProducerSurfaceKHR) {
-++        EGLSurface surface = cnx->egl.eglCreateStreamProducerSurfaceKHR(
-++                dp->disp.dpy, config, stream, attrib_list);
-++        if (surface != EGL_NO_SURFACE) {
-++            egl_surface_t* s = new egl_surface_t(dp.get(), config, NULL,
-++                    surface, cnx);
-++            return s;
-++        }
-++    }
-++    return EGL_NO_SURFACE;
-++}
-++
-++EGLBoolean eglStreamConsumerGLTextureExternalKHR(EGLDisplay dpy,
-++        EGLStreamKHR stream)
-++{
-++    clearError();
-++
-++    const egl_display_ptr dp = validate_display(dpy);
-++    if (!dp) return EGL_FALSE;
-++
-++    EGLBoolean result = EGL_FALSE;
-++    egl_connection_t* const cnx = &gEGLImpl;
-++    if (cnx->dso && cnx->egl.eglStreamConsumerGLTextureExternalKHR) {
-++        result = cnx->egl.eglStreamConsumerGLTextureExternalKHR(
-++                dp->disp.dpy, stream);
-++    }
-++    return result;
-++}
-++
-++EGLBoolean eglStreamConsumerAcquireKHR(EGLDisplay dpy,
-++        EGLStreamKHR stream)
-++{
-++    clearError();
-++
-++    const egl_display_ptr dp = validate_display(dpy);
-++    if (!dp) return EGL_FALSE;
-++
-++    EGLBoolean result = EGL_FALSE;
-++    egl_connection_t* const cnx = &gEGLImpl;
-++    if (cnx->dso && cnx->egl.eglStreamConsumerAcquireKHR) {
-++        result = cnx->egl.eglStreamConsumerAcquireKHR(
-++                dp->disp.dpy, stream);
-++    }
-++    return result;
-++}
-++
-++EGLBoolean eglStreamConsumerReleaseKHR(EGLDisplay dpy,
-++        EGLStreamKHR stream)
-++{
-++    clearError();
-++
-++    const egl_display_ptr dp = validate_display(dpy);
-++    if (!dp) return EGL_FALSE;
-++
-++    EGLBoolean result = EGL_FALSE;
-++    egl_connection_t* const cnx = &gEGLImpl;
-++    if (cnx->dso && cnx->egl.eglStreamConsumerReleaseKHR) {
-++        result = cnx->egl.eglStreamConsumerReleaseKHR(
-++                dp->disp.dpy, stream);
-++    }
-++    return result;
-++}
-++
-++EGLNativeFileDescriptorKHR eglGetStreamFileDescriptorKHR(
-++        EGLDisplay dpy, EGLStreamKHR stream)
-++{
-++    clearError();
-++
-++    const egl_display_ptr dp = validate_display(dpy);
-++    if (!dp) return EGL_NO_FILE_DESCRIPTOR_KHR;
-++
-++    EGLNativeFileDescriptorKHR result = EGL_NO_FILE_DESCRIPTOR_KHR;
-++    egl_connection_t* const cnx = &gEGLImpl;
-++    if (cnx->dso && cnx->egl.eglGetStreamFileDescriptorKHR) {
-++        result = cnx->egl.eglGetStreamFileDescriptorKHR(
-++                dp->disp.dpy, stream);
-++    }
-++    return result;
-++}
-++
-++EGLStreamKHR eglCreateStreamFromFileDescriptorKHR(
-++        EGLDisplay dpy, EGLNativeFileDescriptorKHR file_descriptor)
-++{
-++    clearError();
-++
-++    const egl_display_ptr dp = validate_display(dpy);
-++    if (!dp) return EGL_NO_STREAM_KHR;
-++
-++    EGLStreamKHR result = EGL_NO_STREAM_KHR;
-++    egl_connection_t* const cnx = &gEGLImpl;
-++    if (cnx->dso && cnx->egl.eglCreateStreamFromFileDescriptorKHR) {
-++        result = cnx->egl.eglCreateStreamFromFileDescriptorKHR(
-++                dp->disp.dpy, file_descriptor);
-++    }
-++    return result;
-++}
-++
-++// ----------------------------------------------------------------------------
-++// EGL_EGLEXT_VERSION 15
-++// ----------------------------------------------------------------------------
-++
-++EGLint eglWaitSyncKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLint flags) {
-++    clearError();
-++    const egl_display_ptr dp = validate_display(dpy);
-++    if (!dp) return EGL_FALSE;
-++    EGLint result = EGL_FALSE;
-++    egl_connection_t* const cnx = &gEGLImpl;
-++    if (cnx->dso && cnx->egl.eglWaitSyncKHR) {
-++        result = cnx->egl.eglWaitSyncKHR(dp->disp.dpy, sync, flags);
-++    }
-++    return result;
-++}
-++
-++// ----------------------------------------------------------------------------
-++// ANDROID extensions
-++// ----------------------------------------------------------------------------
-++
-++EGLint eglDupNativeFenceFDANDROID(EGLDisplay dpy, EGLSyncKHR sync)
-++{
-++    clearError();
-++
-++    const egl_display_ptr dp = validate_display(dpy);
-++    if (!dp) return EGL_NO_NATIVE_FENCE_FD_ANDROID;
-++
-++    EGLint result = EGL_NO_NATIVE_FENCE_FD_ANDROID;
-++    egl_connection_t* const cnx = &gEGLImpl;
-++    if (cnx->dso && cnx->egl.eglDupNativeFenceFDANDROID) {
-++        result = cnx->egl.eglDupNativeFenceFDANDROID(dp->disp.dpy, sync);
-++    }
-++    return result;
-++}
-++
-++EGLBoolean eglPresentationTimeANDROID(EGLDisplay dpy, EGLSurface surface,
-++        EGLnsecsANDROID time)
-++{
-++    clearError();
-++
-++    const egl_display_ptr dp = validate_display(dpy);
-++    if (!dp) {
-++        return EGL_FALSE;
-++    }
-++
-++    SurfaceRef _s(dp.get(), surface);
-++    if (!_s.get()) {
-++        setError(EGL_BAD_SURFACE, EGL_FALSE);
-++        return EGL_FALSE;
-++    }
-++
-++    egl_surface_t const * const s = get_surface(surface);
-++    native_window_set_buffers_timestamp(s->win.get(), time);
-++
-++    return EGL_TRUE;
-++}
-++
-++EGLClientBuffer eglCreateNativeClientBufferANDROID(const EGLint *attrib_list)
-++{
-++    clearError();
-++
-++    int usage = 0;
-++    uint32_t width = 0;
-++    uint32_t height = 0;
-++    uint32_t format = 0;
-++    uint32_t red_size = 0;
-++    uint32_t green_size = 0;
-++    uint32_t blue_size = 0;
-++    uint32_t alpha_size = 0;
-++
-++#define GET_NONNEGATIVE_VALUE(case_name, target) \
-++    case case_name: \
-++        if (value >= 0) { \
-++            target = value; \
-++        } else { \
-++            return setError(EGL_BAD_PARAMETER, (EGLClientBuffer)0); \
-++        } \
-++        break
-++
-++    if (attrib_list) {
-++        while (*attrib_list != EGL_NONE) {
-++            GLint attr = *attrib_list++;
-++            GLint value = *attrib_list++;
-++            switch (attr) {
-++                GET_NONNEGATIVE_VALUE(EGL_WIDTH, width);
-++                GET_NONNEGATIVE_VALUE(EGL_HEIGHT, height);
-++                GET_NONNEGATIVE_VALUE(EGL_RED_SIZE, red_size);
-++                GET_NONNEGATIVE_VALUE(EGL_GREEN_SIZE, green_size);
-++                GET_NONNEGATIVE_VALUE(EGL_BLUE_SIZE, blue_size);
-++                GET_NONNEGATIVE_VALUE(EGL_ALPHA_SIZE, alpha_size);
-++                case EGL_NATIVE_BUFFER_USAGE_ANDROID:
-++                    if (value & EGL_NATIVE_BUFFER_USAGE_PROTECTED_BIT_ANDROID) {
-++                        usage |= GRALLOC_USAGE_PROTECTED;
-++                    }
-++                    if (value & EGL_NATIVE_BUFFER_USAGE_RENDERBUFFER_BIT_ANDROID) {
-++                        usage |= GRALLOC_USAGE_HW_RENDER;
-++                    }
-++                    if (value & EGL_NATIVE_BUFFER_USAGE_TEXTURE_BIT_ANDROID) {
-++                        usage |= GRALLOC_USAGE_HW_TEXTURE;
-++                    }
-++                    break;
-++                default:
-++                    return setError(EGL_BAD_PARAMETER, (EGLClientBuffer)0);
-++            }
-++        }
-++    }
-++#undef GET_NONNEGATIVE_VALUE
-++
-++    // Validate format.
-++    if (red_size == 8 && green_size == 8 && blue_size == 8) {
-++        if (alpha_size == 8) {
-++            format = HAL_PIXEL_FORMAT_RGBA_8888;
-++        } else {
-++            format = HAL_PIXEL_FORMAT_RGB_888;
-++        }
-++    } else if (red_size == 5 && green_size == 6 && blue_size == 5 &&
-++               alpha_size == 0) {
-++        format = HAL_PIXEL_FORMAT_RGB_565;
-++    } else {
-++        ALOGE("Invalid native pixel format { r=%d, g=%d, b=%d, a=%d }",
-++                red_size, green_size, blue_size, alpha_size);
-++        return setError(EGL_BAD_PARAMETER, (EGLClientBuffer)0);
-++    }
-++
-++#define CHECK_ERROR_CONDITION(message) \
-++    if (err != NO_ERROR) { \
-++        ALOGE(message); \
-++        goto error_condition; \
-++    }
-++
-++    // The holder is used to destroy the buffer if an error occurs.
-++    GraphicBuffer* gBuffer = new GraphicBuffer();
-++    sp<IServiceManager> sm = defaultServiceManager();
-++    sp<IBinder> surfaceFlinger = sm->getService(String16("SurfaceFlinger"));
-++    sp<IBinder> allocator;
-++    Parcel sc_data, sc_reply, data, reply;
-++    status_t err = NO_ERROR;
-++    if (sm == NULL) {
-++        ALOGE("Unable to connect to ServiceManager");
-++        goto error_condition;
-++    }
-++
-++    // Obtain an allocator.
-++    if (surfaceFlinger == NULL) {
-++        ALOGE("Unable to connect to SurfaceFlinger");
-++        goto error_condition;
-++    }
-++    sc_data.writeInterfaceToken(String16("android.ui.ISurfaceComposer"));
-++    err = surfaceFlinger->transact(
-++            BnSurfaceComposer::CREATE_GRAPHIC_BUFFER_ALLOC, sc_data, &sc_reply);
-++    CHECK_ERROR_CONDITION("Unable to obtain allocator from SurfaceFlinger");
-++    allocator = sc_reply.readStrongBinder();
-++
-++    if (allocator == NULL) {
-++        ALOGE("Unable to obtain an ISurfaceComposer");
-++        goto error_condition;
-++    }
-++    data.writeInterfaceToken(String16("android.ui.IGraphicBufferAlloc"));
-++    err = data.writeUint32(width);
-++    CHECK_ERROR_CONDITION("Unable to write width");
-++    err = data.writeUint32(height);
-++    CHECK_ERROR_CONDITION("Unable to write height");
-++    err = data.writeInt32(static_cast<int32_t>(format));
-++    CHECK_ERROR_CONDITION("Unable to write format");
-++    err = data.writeUint32(usage);
-++    CHECK_ERROR_CONDITION("Unable to write usage");
-++    err = data.writeUtf8AsUtf16(
-++            std::string("[eglCreateNativeClientBufferANDROID pid ") +
-++            std::to_string(getpid()) + ']');
-++    CHECK_ERROR_CONDITION("Unable to write requestor name");
-++    err = allocator->transact(IBinder::FIRST_CALL_TRANSACTION, data,
-++            &reply);
-++    CHECK_ERROR_CONDITION(
-++            "Unable to request buffer allocation from surface composer");
-++    err = reply.readInt32();
-++    CHECK_ERROR_CONDITION("Unable to obtain buffer from surface composer");
-++    err = reply.read(*gBuffer);
-++    CHECK_ERROR_CONDITION("Unable to read buffer from surface composer");
-++
-++    err = gBuffer->initCheck();
-++    if (err != NO_ERROR) {
-++        ALOGE("Unable to create native buffer { w=%d, h=%d, f=%d, u=%#x }: %#x",
-++                width, height, format, usage, err);
-++        goto error_condition;
-++    }
-++    ALOGD("Created new native buffer %p { w=%d, h=%d, f=%d, u=%#x }",
-++            gBuffer, width, height, format, usage);
-++    return static_cast<EGLClientBuffer>(gBuffer->getNativeBuffer());
-++
-++#undef CHECK_ERROR_CONDITION
-++
-++error_condition:
-++    // Delete the buffer.
-++    sp<GraphicBuffer> holder(gBuffer);
-++    return setError(EGL_BAD_ALLOC, (EGLClientBuffer)0);
-++}
-++
-++// ----------------------------------------------------------------------------
-++// NVIDIA extensions
-++// ----------------------------------------------------------------------------
-++EGLuint64NV eglGetSystemTimeFrequencyNV()
-++{
-++    clearError();
-++
-++    if (egl_init_drivers() == EGL_FALSE) {
-++        return setError(EGL_BAD_PARAMETER, EGL_FALSE);
-++    }
-++
-++    EGLuint64NV ret = 0;
-++    egl_connection_t* const cnx = &gEGLImpl;
-++
-++    if (cnx->dso && cnx->egl.eglGetSystemTimeFrequencyNV) {
-++        return cnx->egl.eglGetSystemTimeFrequencyNV();
-++    }
-++
-++    return setErrorQuiet(EGL_BAD_DISPLAY, 0);
-++}
-++
-++EGLuint64NV eglGetSystemTimeNV()
-++{
-++    clearError();
-++
-++    if (egl_init_drivers() == EGL_FALSE) {
-++        return setError(EGL_BAD_PARAMETER, EGL_FALSE);
-++    }
-++
-++    EGLuint64NV ret = 0;
-++    egl_connection_t* const cnx = &gEGLImpl;
-++
-++    if (cnx->dso && cnx->egl.eglGetSystemTimeNV) {
-++        return cnx->egl.eglGetSystemTimeNV();
-++    }
-++
-++    return setErrorQuiet(EGL_BAD_DISPLAY, 0);
-++}
-++
-++// ----------------------------------------------------------------------------
-++// Partial update extension
-++// ----------------------------------------------------------------------------
-++EGLBoolean eglSetDamageRegionKHR(EGLDisplay dpy, EGLSurface surface,
-++        EGLint *rects, EGLint n_rects)
-++{
-++    clearError();
-++
-++    const egl_display_ptr dp = validate_display(dpy);
-++    if (!dp) {
-++        setError(EGL_BAD_DISPLAY, EGL_FALSE);
-++        return EGL_FALSE;
-++    }
-++
-++    SurfaceRef _s(dp.get(), surface);
-++    if (!_s.get()) {
-++        setError(EGL_BAD_SURFACE, EGL_FALSE);
-++        return EGL_FALSE;
-++    }
-++
-++    egl_surface_t const * const s = get_surface(surface);
-++    if (s->cnx->egl.eglSetDamageRegionKHR) {
-++        return s->cnx->egl.eglSetDamageRegionKHR(dp->disp.dpy, s->surface,
-++                rects, n_rects);
-++    }
-++
-++    return EGL_FALSE;
-++}
-++
-++EGLBoolean eglGetFrameTimestampsANDROID(EGLDisplay dpy, EGLSurface surface,
-++        EGLint framesAgo, EGLint numTimestamps, const EGLint *timestamps,
-++        EGLnsecsANDROID *values)
-++{
-++    clearError();
-++
-++    const egl_display_ptr dp = validate_display(dpy);
-++    if (!dp) {
-++        setError(EGL_BAD_DISPLAY, EGL_FALSE);
-++        return EGL_FALSE;
-++    }
-++
-++    SurfaceRef _s(dp.get(), surface);
-++    if (!_s.get()) {
-++        setError(EGL_BAD_SURFACE, EGL_FALSE);
-++        return EGL_FALSE;
-++    }
-++
-++    egl_surface_t const * const s = get_surface(surface);
-++
-++    if (!s->enableTimestamps) {
-++        setError(EGL_BAD_SURFACE, EGL_FALSE);
-++        return EGL_FALSE;
-++    }
-++
-++    nsecs_t* postedTime = nullptr;
-++    nsecs_t* acquireTime = nullptr;
-++    nsecs_t* refreshStartTime = nullptr;
-++    nsecs_t* GLCompositionDoneTime = nullptr;
-++    nsecs_t* displayRetireTime = nullptr;
-++    nsecs_t* releaseTime = nullptr;
-++
-++    for (int i = 0; i < numTimestamps; i++) {
-++        switch (timestamps[i]) {
-++            case EGL_QUEUE_TIME_ANDROID:
-++                postedTime = &values[i];
-++                break;
-++            case EGL_RENDERING_COMPLETE_TIME_ANDROID:
-++                acquireTime = &values[i];
-++                break;
-++            case EGL_COMPOSITION_START_TIME_ANDROID:
-++                refreshStartTime = &values[i];
-++                break;
-++            case EGL_COMPOSITION_FINISHED_TIME_ANDROID:
-++                GLCompositionDoneTime = &values[i];
-++                break;
-++            case EGL_DISPLAY_RETIRE_TIME_ANDROID:
-++                displayRetireTime = &values[i];
-++                break;
-++            case EGL_READS_DONE_TIME_ANDROID:
-++                releaseTime = &values[i];
-++                break;
-++            default:
-++                setError(EGL_BAD_PARAMETER, EGL_FALSE);
-++                return EGL_FALSE;
-++        }
-++    }
-++
-++    status_t ret = native_window_get_frame_timestamps(s->win.get(), framesAgo,
-++            postedTime, acquireTime, refreshStartTime, GLCompositionDoneTime,
-++            displayRetireTime, releaseTime);
-++
-++    if (ret != NO_ERROR) {
-++        setError(EGL_BAD_ACCESS, EGL_FALSE);
-++        return EGL_FALSE;
-++    }
-++
-++    return EGL_TRUE;
-++}
-++
-++EGLBoolean eglQueryTimestampSupportedANDROID(EGLDisplay dpy, EGLSurface surface,
-++        EGLint timestamp)
-++{
-++    clearError();
-++
-++    const egl_display_ptr dp = validate_display(dpy);
-++    if (!dp) {
-++        setError(EGL_BAD_DISPLAY, EGL_FALSE);
-++        return EGL_FALSE;
-++    }
-++
-++    SurfaceRef _s(dp.get(), surface);
-++    if (!_s.get()) {
-++        setError(EGL_BAD_SURFACE, EGL_FALSE);
-++        return EGL_FALSE;
-++    }
-++
-++    switch (timestamp) {
-++#if ENABLE_EGL_ANDROID_GET_FRAME_TIMESTAMPS
-++        case EGL_QUEUE_TIME_ANDROID:
-++        case EGL_RENDERING_COMPLETE_TIME_ANDROID:
-++        case EGL_COMPOSITION_START_TIME_ANDROID:
-++        case EGL_COMPOSITION_FINISHED_TIME_ANDROID:
-++        case EGL_DISPLAY_RETIRE_TIME_ANDROID:
-++        case EGL_READS_DONE_TIME_ANDROID:
-++            return EGL_TRUE;
-++#endif
-++        default:
-++            return EGL_FALSE;
-++    }
-++}
diff -Naur frameworksRaw/native/opengl/libs/EGL/eglApi.cpp.rej frameworksModified/native/opengl/libs/EGL/eglApi.cpp.rej
--- frameworksRaw/native/opengl/libs/EGL/eglApi.cpp.rej	2017-07-06 15:34:21.314456285 +0530
+++ frameworksModified/native/opengl/libs/EGL/eglApi.cpp.rej	1970-01-01 05:30:00.000000000 +0530
@@ -1,26 +0,0 @@
---- native/opengl/libs/EGL/eglApi.cpp	2017-07-06 09:54:21.591904057 +0530
-+++ native/opengl/libs/EGL/eglApi.cpp	2017-07-06 13:50:15.055672001 +0530
-@@ -496,10 +496,7 @@
-         cnx->egl.eglGetConfigAttrib(iDpy, config, EGL_ALPHA_SIZE, &a);
-         if (a > 0) {
-             // alpha-channel requested, there's really only one suitable format
--	    //default
--            //format = HAL_PIXEL_FORMAT_RGBA_8888;
--	    // RPI patch
--	    format = HAL_PIXEL_FORMAT_BGRA_8888;
-+            format = HAL_PIXEL_FORMAT_RGBA_8888;
-         } else {
-             EGLint r, g, b;
-             r = g = b = 0;
-@@ -1863,10 +1860,7 @@
-     // Validate format.
-     if (red_size == 8 && green_size == 8 && blue_size == 8) {
-         if (alpha_size == 8) {
--	    //default
--            //format = HAL_PIXEL_FORMAT_RGBA_8888;
--	    //rpi patch
--	    format = HAL_PIXEL_FORMAT_BGRA_8888;
-+            format = HAL_PIXEL_FORMAT_RGBA_8888;
-         } else {
-             format = HAL_PIXEL_FORMAT_RGB_888;
-         }
diff -Naur frameworksRaw/native/opengl/libs/EGL/eglApi.cpp.rej.orig frameworksModified/native/opengl/libs/EGL/eglApi.cpp.rej.orig
--- frameworksRaw/native/opengl/libs/EGL/eglApi.cpp.rej.orig	2017-07-06 15:34:21.290454272 +0530
+++ frameworksModified/native/opengl/libs/EGL/eglApi.cpp.rej.orig	1970-01-01 05:30:00.000000000 +0530
@@ -1,26 +0,0 @@
---- native/opengl/libs/EGL/eglApi.cpp	2017-07-06 09:54:21.591904057 +0530
-+++ native/opengl/libs/EGL/eglApi.cpp	2017-07-06 13:50:15.055672001 +0530
-@@ -496,10 +496,7 @@
-         cnx->egl.eglGetConfigAttrib(iDpy, config, EGL_ALPHA_SIZE, &a);
-         if (a > 0) {
-             // alpha-channel requested, there's really only one suitable format
--	    //default
--            //format = HAL_PIXEL_FORMAT_RGBA_8888;
--	    // RPI patch
--	    format = HAL_PIXEL_FORMAT_BGRA_8888;
-+            format = HAL_PIXEL_FORMAT_RGBA_8888;
-         } else {
-             EGLint r, g, b;
-             r = g = b = 0;
-@@ -1863,10 +1860,7 @@
-     // Validate format.
-     if (red_size == 8 && green_size == 8 && blue_size == 8) {
-         if (alpha_size == 8) {
--	    //default
--            //format = HAL_PIXEL_FORMAT_RGBA_8888;
--	    //rpi patch
--	    format = HAL_PIXEL_FORMAT_BGRA_8888;
-+            format = HAL_PIXEL_FORMAT_RGBA_8888;
-         } else {
-             format = HAL_PIXEL_FORMAT_RGB_888;
-         }
diff -Naur frameworksRaw/native/opengl/libs/EGL/eglApi.cpp.rej.orig.orig frameworksModified/native/opengl/libs/EGL/eglApi.cpp.rej.orig.orig
--- frameworksRaw/native/opengl/libs/EGL/eglApi.cpp.rej.orig.orig	2017-07-06 15:34:21.318456623 +0530
+++ frameworksModified/native/opengl/libs/EGL/eglApi.cpp.rej.orig.orig	1970-01-01 05:30:00.000000000 +0530
@@ -1,26 +0,0 @@
---- native/opengl/libs/EGL/eglApi.cpp	2017-07-06 09:54:21.591904057 +0530
-+++ native/opengl/libs/EGL/eglApi.cpp	2017-07-06 13:50:15.055672001 +0530
-@@ -496,10 +496,7 @@
-         cnx->egl.eglGetConfigAttrib(iDpy, config, EGL_ALPHA_SIZE, &a);
-         if (a > 0) {
-             // alpha-channel requested, there's really only one suitable format
--	    //default
--            //format = HAL_PIXEL_FORMAT_RGBA_8888;
--	    // RPI patch
--	    format = HAL_PIXEL_FORMAT_BGRA_8888;
-+            format = HAL_PIXEL_FORMAT_RGBA_8888;
-         } else {
-             EGLint r, g, b;
-             r = g = b = 0;
-@@ -1863,10 +1860,7 @@
-     // Validate format.
-     if (red_size == 8 && green_size == 8 && blue_size == 8) {
-         if (alpha_size == 8) {
--	    //default
--            //format = HAL_PIXEL_FORMAT_RGBA_8888;
--	    //rpi patch
--	    format = HAL_PIXEL_FORMAT_BGRA_8888;
-+            format = HAL_PIXEL_FORMAT_RGBA_8888;
-         } else {
-             format = HAL_PIXEL_FORMAT_RGB_888;
-         }
diff -Naur frameworksRaw/native/opengl/libs/EGL/eglApi.cpp.rej.orig.rej frameworksModified/native/opengl/libs/EGL/eglApi.cpp.rej.orig.rej
--- frameworksRaw/native/opengl/libs/EGL/eglApi.cpp.rej.orig.rej	2017-07-06 15:34:21.274452929 +0530
+++ frameworksModified/native/opengl/libs/EGL/eglApi.cpp.rej.orig.rej	1970-01-01 05:30:00.000000000 +0530
@@ -1,29 +0,0 @@
---- native/opengl/libs/EGL/eglApi.cpp.rej.orig	1970-01-01 05:30:00.000000000 +0530
-+++ native/opengl/libs/EGL/eglApi.cpp.rej.orig	2017-07-06 13:50:15.231677713 +0530
-@@ -0,0 +1,26 @@
-+--- native/opengl/libs/EGL/eglApi.cpp	2017-07-05 14:35:38.084027172 +0530
-++++ native/opengl/libs/EGL/eglApi.cpp	2017-07-05 17:28:25.650787122 +0530
-+@@ -496,10 +496,7 @@
-+         cnx->egl.eglGetConfigAttrib(iDpy, config, EGL_ALPHA_SIZE, &a);
-+         if (a > 0) {
-+             // alpha-channel requested, there's really only one suitable format
-+-	    //default
-+-            //format = HAL_PIXEL_FORMAT_RGBA_8888;
-+-	    // RPI patch
-+-	    format = HAL_PIXEL_FORMAT_BGRA_8888;
-++            format = HAL_PIXEL_FORMAT_RGBA_8888;
-+         } else {
-+             EGLint r, g, b;
-+             r = g = b = 0;
-+@@ -1863,10 +1860,7 @@
-+     // Validate format.
-+     if (red_size == 8 && green_size == 8 && blue_size == 8) {
-+         if (alpha_size == 8) {
-+-	    //default
-+-            //format = HAL_PIXEL_FORMAT_RGBA_8888;
-+-	    //rpi patch
-+-	    format = HAL_PIXEL_FORMAT_BGRA_8888;
-++            format = HAL_PIXEL_FORMAT_RGBA_8888;
-+         } else {
-+             format = HAL_PIXEL_FORMAT_RGB_888;
-+         }
diff -Naur frameworksRaw/native/opengl/libs/EGL/eglApi.cpp.rej.rej frameworksModified/native/opengl/libs/EGL/eglApi.cpp.rej.rej
--- frameworksRaw/native/opengl/libs/EGL/eglApi.cpp.rej.rej	2017-07-06 15:34:21.318456623 +0530
+++ frameworksModified/native/opengl/libs/EGL/eglApi.cpp.rej.rej	1970-01-01 05:30:00.000000000 +0530
@@ -1,29 +0,0 @@
---- native/opengl/libs/EGL/eglApi.cpp.rej	1970-01-01 05:30:00.000000000 +0530
-+++ native/opengl/libs/EGL/eglApi.cpp.rej	2017-07-06 13:50:15.207676932 +0530
-@@ -0,0 +1,26 @@
-+--- native/opengl/libs/EGL/eglApi.cpp	2017-07-05 14:35:38.084027172 +0530
-++++ native/opengl/libs/EGL/eglApi.cpp	2017-07-05 17:28:25.650787122 +0530
-+@@ -496,10 +496,7 @@
-+         cnx->egl.eglGetConfigAttrib(iDpy, config, EGL_ALPHA_SIZE, &a);
-+         if (a > 0) {
-+             // alpha-channel requested, there's really only one suitable format
-+-	    //default
-+-            //format = HAL_PIXEL_FORMAT_RGBA_8888;
-+-	    // RPI patch
-+-	    format = HAL_PIXEL_FORMAT_BGRA_8888;
-++            format = HAL_PIXEL_FORMAT_RGBA_8888;
-+         } else {
-+             EGLint r, g, b;
-+             r = g = b = 0;
-+@@ -1863,10 +1860,7 @@
-+     // Validate format.
-+     if (red_size == 8 && green_size == 8 && blue_size == 8) {
-+         if (alpha_size == 8) {
-+-	    //default
-+-            //format = HAL_PIXEL_FORMAT_RGBA_8888;
-+-	    //rpi patch
-+-	    format = HAL_PIXEL_FORMAT_BGRA_8888;
-++            format = HAL_PIXEL_FORMAT_RGBA_8888;
-+         } else {
-+             format = HAL_PIXEL_FORMAT_RGB_888;
-+         }
diff -Naur frameworksRaw/native/opengl/libs/EGL/eglApi.cpp.rej.rej.orig frameworksModified/native/opengl/libs/EGL/eglApi.cpp.rej.rej.orig
--- frameworksRaw/native/opengl/libs/EGL/eglApi.cpp.rej.rej.orig	2017-07-06 15:34:21.322456956 +0530
+++ frameworksModified/native/opengl/libs/EGL/eglApi.cpp.rej.rej.orig	1970-01-01 05:30:00.000000000 +0530
@@ -1,29 +0,0 @@
---- native/opengl/libs/EGL/eglApi.cpp.rej	1970-01-01 05:30:00.000000000 +0530
-+++ native/opengl/libs/EGL/eglApi.cpp.rej	2017-07-06 13:50:15.207676932 +0530
-@@ -0,0 +1,26 @@
-+--- native/opengl/libs/EGL/eglApi.cpp	2017-07-05 14:35:38.084027172 +0530
-++++ native/opengl/libs/EGL/eglApi.cpp	2017-07-05 17:28:25.650787122 +0530
-+@@ -496,10 +496,7 @@
-+         cnx->egl.eglGetConfigAttrib(iDpy, config, EGL_ALPHA_SIZE, &a);
-+         if (a > 0) {
-+             // alpha-channel requested, there's really only one suitable format
-+-	    //default
-+-            //format = HAL_PIXEL_FORMAT_RGBA_8888;
-+-	    // RPI patch
-+-	    format = HAL_PIXEL_FORMAT_BGRA_8888;
-++            format = HAL_PIXEL_FORMAT_RGBA_8888;
-+         } else {
-+             EGLint r, g, b;
-+             r = g = b = 0;
-+@@ -1863,10 +1860,7 @@
-+     // Validate format.
-+     if (red_size == 8 && green_size == 8 && blue_size == 8) {
-+         if (alpha_size == 8) {
-+-	    //default
-+-            //format = HAL_PIXEL_FORMAT_RGBA_8888;
-+-	    //rpi patch
-+-	    format = HAL_PIXEL_FORMAT_BGRA_8888;
-++            format = HAL_PIXEL_FORMAT_RGBA_8888;
-+         } else {
-+             format = HAL_PIXEL_FORMAT_RGB_888;
-+         }
diff -Naur frameworksRaw/native/opengl/libs/EGL/eglApi.cpp.rej.rej.rej frameworksModified/native/opengl/libs/EGL/eglApi.cpp.rej.rej.rej
--- frameworksRaw/native/opengl/libs/EGL/eglApi.cpp.rej.rej.rej	2017-07-06 15:34:21.322456956 +0530
+++ frameworksModified/native/opengl/libs/EGL/eglApi.cpp.rej.rej.rej	1970-01-01 05:30:00.000000000 +0530
@@ -1,32 +0,0 @@
---- native/opengl/libs/EGL/eglApi.cpp.rej.rej	1970-01-01 05:30:00.000000000 +0530
-+++ native/opengl/libs/EGL/eglApi.cpp.rej.rej	2017-07-06 13:50:15.223677451 +0530
-@@ -0,0 +1,29 @@
-+--- native/opengl/libs/EGL/eglApi.cpp.rej	1970-01-01 05:30:00.000000000 +0530
-++++ native/opengl/libs/EGL/eglApi.cpp.rej	2017-07-05 18:25:26.600577787 +0530
-+@@ -0,0 +1,26 @@
-++--- frameworks/native/opengl/libs/EGL/eglApi.cpp	2017-07-05 14:35:38.084027172 +0530
-+++++ frameworks/native/opengl/libs/EGL/eglApi.cpp	2017-07-05 17:28:25.650787122 +0530
-++@@ -496,10 +496,7 @@
-++         cnx->egl.eglGetConfigAttrib(iDpy, config, EGL_ALPHA_SIZE, &a);
-++         if (a > 0) {
-++             // alpha-channel requested, there's really only one suitable format
-++-	    //default
-++-            //format = HAL_PIXEL_FORMAT_RGBA_8888;
-++-	    // RPI patch
-++-	    format = HAL_PIXEL_FORMAT_BGRA_8888;
-+++            format = HAL_PIXEL_FORMAT_RGBA_8888;
-++         } else {
-++             EGLint r, g, b;
-++             r = g = b = 0;
-++@@ -1863,10 +1860,7 @@
-++     // Validate format.
-++     if (red_size == 8 && green_size == 8 && blue_size == 8) {
-++         if (alpha_size == 8) {
-++-	    //default
-++-            //format = HAL_PIXEL_FORMAT_RGBA_8888;
-++-	    //rpi patch
-++-	    format = HAL_PIXEL_FORMAT_BGRA_8888;
-+++            format = HAL_PIXEL_FORMAT_RGBA_8888;
-++         } else {
-++             format = HAL_PIXEL_FORMAT_RGB_888;
-++         }
diff -Naur frameworksRaw/native/opengl/libs/EGL/README.rej frameworksModified/native/opengl/libs/EGL/README.rej
--- frameworksRaw/native/opengl/libs/EGL/README.rej	2017-07-06 15:34:21.322456956 +0530
+++ frameworksModified/native/opengl/libs/EGL/README.rej	1970-01-01 05:30:00.000000000 +0530
@@ -1,4 +0,0 @@
---- native/opengl/libs/EGL/README	2017-07-06 09:54:21.599904385 +0530
-+++ native/opengl/libs/EGL/README	1970-01-01 05:30:00.000000000 +0530
-@@ -1 +0,0 @@
--#patch for hal_pixel_formet
diff -Naur frameworksRaw/native/opengl/libs/EGL/README.rej.orig frameworksModified/native/opengl/libs/EGL/README.rej.orig
--- frameworksRaw/native/opengl/libs/EGL/README.rej.orig	2017-07-06 15:34:21.306455616 +0530
+++ frameworksModified/native/opengl/libs/EGL/README.rej.orig	1970-01-01 05:30:00.000000000 +0530
@@ -1,4 +0,0 @@
---- native/opengl/libs/EGL/README	2017-07-06 09:54:21.599904385 +0530
-+++ native/opengl/libs/EGL/README	1970-01-01 05:30:00.000000000 +0530
-@@ -1 +0,0 @@
--#patch for hal_pixel_formet
diff -Naur frameworksRaw/native/opengl/libs/EGL/README.rej.orig.orig frameworksModified/native/opengl/libs/EGL/README.rej.orig.orig
--- frameworksRaw/native/opengl/libs/EGL/README.rej.orig.orig	2017-07-06 15:34:21.322456956 +0530
+++ frameworksModified/native/opengl/libs/EGL/README.rej.orig.orig	1970-01-01 05:30:00.000000000 +0530
@@ -1,4 +0,0 @@
---- native/opengl/libs/EGL/README	2017-07-06 09:54:21.599904385 +0530
-+++ native/opengl/libs/EGL/README	1970-01-01 05:30:00.000000000 +0530
-@@ -1 +0,0 @@
--#patch for hal_pixel_formet
diff -Naur frameworksRaw/native/opengl/libs/EGL/README.rej.orig.rej frameworksModified/native/opengl/libs/EGL/README.rej.orig.rej
--- frameworksRaw/native/opengl/libs/EGL/README.rej.orig.rej	2017-07-06 15:34:21.250450915 +0530
+++ frameworksModified/native/opengl/libs/EGL/README.rej.orig.rej	1970-01-01 05:30:00.000000000 +0530
@@ -1,7 +0,0 @@
---- native/opengl/libs/EGL/README.rej.orig	1970-01-01 05:30:00.000000000 +0530
-+++ native/opengl/libs/EGL/README.rej.orig	2017-07-06 13:50:15.231677713 +0530
-@@ -0,0 +1,4 @@
-+--- native/opengl/libs/EGL/README	2017-07-04 12:15:34.813678465 +0530
-++++ native/opengl/libs/EGL/README	1970-01-01 05:30:00.000000000 +0530
-+@@ -1 +0,0 @@
-+-#patch for hal_pixel_formet
diff -Naur frameworksRaw/native/opengl/libs/EGL/README.rej.rej frameworksModified/native/opengl/libs/EGL/README.rej.rej
--- frameworksRaw/native/opengl/libs/EGL/README.rej.rej	2017-07-06 15:34:21.302455279 +0530
+++ frameworksModified/native/opengl/libs/EGL/README.rej.rej	1970-01-01 05:30:00.000000000 +0530
@@ -1,7 +0,0 @@
---- native/opengl/libs/EGL/README.rej	1970-01-01 05:30:00.000000000 +0530
-+++ native/opengl/libs/EGL/README.rej	2017-07-06 13:50:15.231677713 +0530
-@@ -0,0 +1,4 @@
-+--- native/opengl/libs/EGL/README	2017-07-04 12:15:34.813678465 +0530
-++++ native/opengl/libs/EGL/README	1970-01-01 05:30:00.000000000 +0530
-+@@ -1 +0,0 @@
-+-#patch for hal_pixel_formet
diff -Naur frameworksRaw/native/opengl/libs/EGL/README.rej.rej.orig frameworksModified/native/opengl/libs/EGL/README.rej.rej.orig
--- frameworksRaw/native/opengl/libs/EGL/README.rej.rej.orig	2017-07-06 15:34:21.322456956 +0530
+++ frameworksModified/native/opengl/libs/EGL/README.rej.rej.orig	1970-01-01 05:30:00.000000000 +0530
@@ -1,7 +0,0 @@
---- native/opengl/libs/EGL/README.rej	1970-01-01 05:30:00.000000000 +0530
-+++ native/opengl/libs/EGL/README.rej	2017-07-06 13:50:15.231677713 +0530
-@@ -0,0 +1,4 @@
-+--- native/opengl/libs/EGL/README	2017-07-04 12:15:34.813678465 +0530
-++++ native/opengl/libs/EGL/README	1970-01-01 05:30:00.000000000 +0530
-+@@ -1 +0,0 @@
-+-#patch for hal_pixel_formet
diff -Naur frameworksRaw/native/opengl/libs/EGL/README.rej.rej.rej frameworksModified/native/opengl/libs/EGL/README.rej.rej.rej
--- frameworksRaw/native/opengl/libs/EGL/README.rej.rej.rej	2017-07-06 15:34:21.322456956 +0530
+++ frameworksModified/native/opengl/libs/EGL/README.rej.rej.rej	1970-01-01 05:30:00.000000000 +0530
@@ -1,10 +0,0 @@
---- native/opengl/libs/EGL/README.rej.rej	1970-01-01 05:30:00.000000000 +0530
-+++ native/opengl/libs/EGL/README.rej.rej	2017-07-06 13:50:15.207676932 +0530
-@@ -0,0 +1,7 @@
-+--- native/opengl/libs/EGL/README.rej	1970-01-01 05:30:00.000000000 +0530
-++++ native/opengl/libs/EGL/README.rej	2017-07-05 18:25:26.652579622 +0530
-+@@ -0,0 +1,4 @@
-++--- frameworks/native/opengl/libs/EGL/README	2017-07-04 12:15:34.813678465 +0530
-+++++ frameworks/native/opengl/libs/EGL/README	1970-01-01 05:30:00.000000000 +0530
-++@@ -1 +0,0 @@
-++-#patch for hal_pixel_formet
